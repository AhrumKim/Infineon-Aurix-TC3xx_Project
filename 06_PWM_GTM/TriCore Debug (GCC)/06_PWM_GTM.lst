
06_PWM_GTM.elf:     file format elf32-tricore

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .bmhd_0       00000020  80000000  80000000  00000274  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .bmhd_1       00000020  80020000  80020000  00005930  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .startup      00000010  80000020  80000020  00000294  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .interface_const 00000000  80000040  80000040  00005ba4  2**0
                  CONTENTS
  4 .traptab_tc0  00000100  80000100  80000100  000002c0  2**5
                  CONTENTS, ALLOC, LOAD, CODE
  5 .rodata       000003b8  80000200  80000200  000003c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .CPU2.zbss    00000000  50000000  50000000  00005ba4  2**0
                  CONTENTS
  7 .CPU2.bss     00000000  50000000  50000000  00005ba4  2**0
                  CONTENTS
  8 .CPU1.zbss    00000000  60000000  60000000  00005ba4  2**0
                  CONTENTS
  9 .CPU1.bss     00000000  600011a4  600011a4  00005ba4  2**0
                  CONTENTS
 10 .CPU0.zbss    00000000  70000000  70000000  00005ba4  2**0
                  CONTENTS
 11 .CPU0.bss     00000000  70000000  70000000  00005ba4  2**0
                  CONTENTS
 12 .zbss         00000000  60000000  801f6300  00000000  2**0
                  ALLOC
 13 .sbss         00000000  60000000  801f6300  00000000  2**0
                  ALLOC, SMALL_DATA
 14 .bss          0000017c  60000028  801f6324  00005ba8  2**3
                  ALLOC
 15 .CPU2.zdata   00000000  50000000  50000000  00005ba4  2**0
                  CONTENTS
 16 .CPU2.data    00000000  50000000  50000000  00005ba4  2**0
                  CONTENTS
 17 .CPU1.zdata   00000000  60000000  60000000  00005ba4  2**0
                  CONTENTS
 18 .CPU1.data    00000000  600011a4  600011a4  00005ba4  2**0
                  CONTENTS
 19 .CPU0.zdata   00000000  70000000  70000000  00005ba4  2**0
                  CONTENTS
 20 .CPU0.data    00000000  70000000  70000000  00005ba4  2**0
                  CONTENTS
 21 .zdata        00000000  60000000  801f6324  00005ba4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 22 .sdata        00000000  60000000  801f6324  00005ba4  2**0
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
 23 .data         00000024  60000000  801f6300  00005b80  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 24 .lmu_zdata    00000000  90000000  90000000  00005ba4  2**0
                  CONTENTS
 25 .lmu_sdata    00000000  90000000  90000000  00005ba4  2**0
                  CONTENTS
 26 .lmu_data     00000000  90000000  90000000  00005ba4  2**0
                  CONTENTS
 27 .CPU0.psram_text 00000000  70100000  70100000  00005ba4  2**0
                  CONTENTS
 28 .CPU1.psram_text 00000000  60100000  60100000  00005ba4  2**0
                  CONTENTS
 29 .CPU2.psram_text 00000000  50100000  50100000  00005ba4  2**0
                  CONTENTS
 30 .text         00005184  800005b8  800005b8  00000778  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .init         0000000c  8000573c  8000573c  000058fc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .fini         00000008  80005748  80005748  00005908  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .eh_frame     00000000  80005750  80005750  00005ba4  2**0
                  CONTENTS
 34 .gcc_except_table 00000000  80005750  80005750  00005ba4  2**0
                  CONTENTS
 35 .ctors        00000010  80005750  80005750  00005910  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 36 .dtors        00000010  80005760  80005760  00005920  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 37 .traptab_tc2  00000100  801f6100  801f6100  00005980  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 38 .traptab_tc1  00000100  801f6200  801f6200  00005a80  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 39 .heap         00001000  600001a4  801f6324  00005ba4  2**0
                  ALLOC
 40 .CPU2.ustack  00000800  5001ae00  5001ae00  00000274  2**0
                  ALLOC
 41 .CPU2.istack  00000400  5001b700  5001b700  00000274  2**0
                  ALLOC
 42 .CPU2.csa     00002000  5001bc00  5001bc00  00000274  2**0
                  ALLOC
 43 .CPU1.ustack  00000800  6001ae00  6001ae00  00000274  2**0
                  ALLOC
 44 .CPU1.istack  00000400  6001b700  6001b700  00000274  2**0
                  ALLOC
 45 .CPU1.csa     00002000  6001bc00  6001bc00  00000274  2**0
                  ALLOC
 46 .CPU0.ustack  00000800  70018e00  70018e00  00000274  2**0
                  ALLOC
 47 .CPU0.istack  00000400  70019700  70019700  00000274  2**0
                  ALLOC
 48 .CPU0.csa     00002000  70019c00  70019c00  00000274  2**0
                  ALLOC
 49 .inttab_tc0_000 00000000  801f4000  801f4000  00005ba4  2**0
                  CONTENTS
 50 .inttab_tc0_001 00000000  801f4020  801f4020  00005ba4  2**0
                  CONTENTS
 51 .inttab_tc0_002 00000000  801f4040  801f4040  00005ba4  2**0
                  CONTENTS
 52 .inttab_tc0_003 00000000  801f4060  801f4060  00005ba4  2**0
                  CONTENTS
 53 .inttab_tc0_004 00000000  801f4080  801f4080  00005ba4  2**0
                  CONTENTS
 54 .inttab_tc0_005 00000000  801f40a0  801f40a0  00005ba4  2**0
                  CONTENTS
 55 .inttab_tc0_006 00000000  801f40c0  801f40c0  00005ba4  2**0
                  CONTENTS
 56 .inttab_tc0_007 00000000  801f40e0  801f40e0  00005ba4  2**0
                  CONTENTS
 57 .inttab_tc0_008 00000000  801f4100  801f4100  00005ba4  2**0
                  CONTENTS
 58 .inttab_tc0_009 00000000  801f4120  801f4120  00005ba4  2**0
                  CONTENTS
 59 .inttab_tc0_00A 00000000  801f4140  801f4140  00005ba4  2**0
                  CONTENTS
 60 .inttab_tc0_00B 00000000  801f4160  801f4160  00005ba4  2**0
                  CONTENTS
 61 .inttab_tc0_00C 00000000  801f4180  801f4180  00005ba4  2**0
                  CONTENTS
 62 .inttab_tc0_00D 00000000  801f41a0  801f41a0  00005ba4  2**0
                  CONTENTS
 63 .inttab_tc0_00E 00000000  801f41c0  801f41c0  00005ba4  2**0
                  CONTENTS
 64 .inttab_tc0_00F 00000000  801f41e0  801f41e0  00005ba4  2**0
                  CONTENTS
 65 .inttab_tc0_010 00000000  801f4200  801f4200  00005ba4  2**0
                  CONTENTS
 66 .inttab_tc0_011 00000000  801f4220  801f4220  00005ba4  2**0
                  CONTENTS
 67 .inttab_tc0_012 00000000  801f4240  801f4240  00005ba4  2**0
                  CONTENTS
 68 .inttab_tc0_013 00000000  801f4260  801f4260  00005ba4  2**0
                  CONTENTS
 69 .inttab_tc0_014 00000000  801f4280  801f4280  00005ba4  2**0
                  CONTENTS
 70 .inttab_tc0_015 00000000  801f42a0  801f42a0  00005ba4  2**0
                  CONTENTS
 71 .inttab_tc0_016 00000000  801f42c0  801f42c0  00005ba4  2**0
                  CONTENTS
 72 .inttab_tc0_017 00000000  801f42e0  801f42e0  00005ba4  2**0
                  CONTENTS
 73 .inttab_tc0_018 00000000  801f4300  801f4300  00005ba4  2**0
                  CONTENTS
 74 .inttab_tc0_019 00000000  801f4320  801f4320  00005ba4  2**0
                  CONTENTS
 75 .inttab_tc0_01A 00000000  801f4340  801f4340  00005ba4  2**0
                  CONTENTS
 76 .inttab_tc0_01B 00000000  801f4360  801f4360  00005ba4  2**0
                  CONTENTS
 77 .inttab_tc0_01C 00000000  801f4380  801f4380  00005ba4  2**0
                  CONTENTS
 78 .inttab_tc0_01D 00000000  801f43a0  801f43a0  00005ba4  2**0
                  CONTENTS
 79 .inttab_tc0_01E 00000000  801f43c0  801f43c0  00005ba4  2**0
                  CONTENTS
 80 .inttab_tc0_01F 00000000  801f43e0  801f43e0  00005ba4  2**0
                  CONTENTS
 81 .inttab_tc0_020 00000000  801f4400  801f4400  00005ba4  2**0
                  CONTENTS
 82 .inttab_tc0_021 00000000  801f4420  801f4420  00005ba4  2**0
                  CONTENTS
 83 .inttab_tc0_022 00000000  801f4440  801f4440  00005ba4  2**0
                  CONTENTS
 84 .inttab_tc0_023 00000000  801f4460  801f4460  00005ba4  2**0
                  CONTENTS
 85 .inttab_tc0_024 00000000  801f4480  801f4480  00005ba4  2**0
                  CONTENTS
 86 .inttab_tc0_025 00000000  801f44a0  801f44a0  00005ba4  2**0
                  CONTENTS
 87 .inttab_tc0_026 00000000  801f44c0  801f44c0  00005ba4  2**0
                  CONTENTS
 88 .inttab_tc0_027 00000000  801f44e0  801f44e0  00005ba4  2**0
                  CONTENTS
 89 .inttab_tc0_028 00000000  801f4500  801f4500  00005ba4  2**0
                  CONTENTS
 90 .inttab_tc0_029 00000000  801f4520  801f4520  00005ba4  2**0
                  CONTENTS
 91 .inttab_tc0_02A 00000000  801f4540  801f4540  00005ba4  2**0
                  CONTENTS
 92 .inttab_tc0_02B 00000000  801f4560  801f4560  00005ba4  2**0
                  CONTENTS
 93 .inttab_tc0_02C 00000000  801f4580  801f4580  00005ba4  2**0
                  CONTENTS
 94 .inttab_tc0_02D 00000000  801f45a0  801f45a0  00005ba4  2**0
                  CONTENTS
 95 .inttab_tc0_02E 00000000  801f45c0  801f45c0  00005ba4  2**0
                  CONTENTS
 96 .inttab_tc0_02F 00000000  801f45e0  801f45e0  00005ba4  2**0
                  CONTENTS
 97 .inttab_tc0_030 00000000  801f4600  801f4600  00005ba4  2**0
                  CONTENTS
 98 .inttab_tc0_031 00000000  801f4620  801f4620  00005ba4  2**0
                  CONTENTS
 99 .inttab_tc0_032 00000000  801f4640  801f4640  00005ba4  2**0
                  CONTENTS
100 .inttab_tc0_033 00000000  801f4660  801f4660  00005ba4  2**0
                  CONTENTS
101 .inttab_tc0_034 00000000  801f4680  801f4680  00005ba4  2**0
                  CONTENTS
102 .inttab_tc0_035 00000000  801f46a0  801f46a0  00005ba4  2**0
                  CONTENTS
103 .inttab_tc0_036 00000000  801f46c0  801f46c0  00005ba4  2**0
                  CONTENTS
104 .inttab_tc0_037 00000000  801f46e0  801f46e0  00005ba4  2**0
                  CONTENTS
105 .inttab_tc0_038 00000000  801f4700  801f4700  00005ba4  2**0
                  CONTENTS
106 .inttab_tc0_039 00000000  801f4720  801f4720  00005ba4  2**0
                  CONTENTS
107 .inttab_tc0_03A 00000000  801f4740  801f4740  00005ba4  2**0
                  CONTENTS
108 .inttab_tc0_03B 00000000  801f4760  801f4760  00005ba4  2**0
                  CONTENTS
109 .inttab_tc0_03C 00000000  801f4780  801f4780  00005ba4  2**0
                  CONTENTS
110 .inttab_tc0_03D 00000000  801f47a0  801f47a0  00005ba4  2**0
                  CONTENTS
111 .inttab_tc0_03E 00000000  801f47c0  801f47c0  00005ba4  2**0
                  CONTENTS
112 .inttab_tc0_03F 00000000  801f47e0  801f47e0  00005ba4  2**0
                  CONTENTS
113 .inttab_tc0_040 00000000  801f4800  801f4800  00005ba4  2**0
                  CONTENTS
114 .inttab_tc0_041 00000000  801f4820  801f4820  00005ba4  2**0
                  CONTENTS
115 .inttab_tc0_042 00000000  801f4840  801f4840  00005ba4  2**0
                  CONTENTS
116 .inttab_tc0_043 00000000  801f4860  801f4860  00005ba4  2**0
                  CONTENTS
117 .inttab_tc0_044 00000000  801f4880  801f4880  00005ba4  2**0
                  CONTENTS
118 .inttab_tc0_045 00000000  801f48a0  801f48a0  00005ba4  2**0
                  CONTENTS
119 .inttab_tc0_046 00000000  801f48c0  801f48c0  00005ba4  2**0
                  CONTENTS
120 .inttab_tc0_047 00000000  801f48e0  801f48e0  00005ba4  2**0
                  CONTENTS
121 .inttab_tc0_048 00000000  801f4900  801f4900  00005ba4  2**0
                  CONTENTS
122 .inttab_tc0_049 00000000  801f4920  801f4920  00005ba4  2**0
                  CONTENTS
123 .inttab_tc0_04A 00000000  801f4940  801f4940  00005ba4  2**0
                  CONTENTS
124 .inttab_tc0_04B 00000000  801f4960  801f4960  00005ba4  2**0
                  CONTENTS
125 .inttab_tc0_04C 00000000  801f4980  801f4980  00005ba4  2**0
                  CONTENTS
126 .inttab_tc0_04D 00000000  801f49a0  801f49a0  00005ba4  2**0
                  CONTENTS
127 .inttab_tc0_04E 00000000  801f49c0  801f49c0  00005ba4  2**0
                  CONTENTS
128 .inttab_tc0_04F 00000000  801f49e0  801f49e0  00005ba4  2**0
                  CONTENTS
129 .inttab_tc0_050 00000000  801f4a00  801f4a00  00005ba4  2**0
                  CONTENTS
130 .inttab_tc0_051 00000000  801f4a20  801f4a20  00005ba4  2**0
                  CONTENTS
131 .inttab_tc0_052 00000000  801f4a40  801f4a40  00005ba4  2**0
                  CONTENTS
132 .inttab_tc0_053 00000000  801f4a60  801f4a60  00005ba4  2**0
                  CONTENTS
133 .inttab_tc0_054 00000000  801f4a80  801f4a80  00005ba4  2**0
                  CONTENTS
134 .inttab_tc0_055 00000000  801f4aa0  801f4aa0  00005ba4  2**0
                  CONTENTS
135 .inttab_tc0_056 00000000  801f4ac0  801f4ac0  00005ba4  2**0
                  CONTENTS
136 .inttab_tc0_057 00000000  801f4ae0  801f4ae0  00005ba4  2**0
                  CONTENTS
137 .inttab_tc0_058 00000000  801f4b00  801f4b00  00005ba4  2**0
                  CONTENTS
138 .inttab_tc0_059 00000000  801f4b20  801f4b20  00005ba4  2**0
                  CONTENTS
139 .inttab_tc0_05A 00000000  801f4b40  801f4b40  00005ba4  2**0
                  CONTENTS
140 .inttab_tc0_05B 00000000  801f4b60  801f4b60  00005ba4  2**0
                  CONTENTS
141 .inttab_tc0_05C 00000000  801f4b80  801f4b80  00005ba4  2**0
                  CONTENTS
142 .inttab_tc0_05D 00000000  801f4ba0  801f4ba0  00005ba4  2**0
                  CONTENTS
143 .inttab_tc0_05E 00000000  801f4bc0  801f4bc0  00005ba4  2**0
                  CONTENTS
144 .inttab_tc0_05F 00000000  801f4be0  801f4be0  00005ba4  2**0
                  CONTENTS
145 .inttab_tc0_060 00000000  801f4c00  801f4c00  00005ba4  2**0
                  CONTENTS
146 .inttab_tc0_061 00000000  801f4c20  801f4c20  00005ba4  2**0
                  CONTENTS
147 .inttab_tc0_062 00000000  801f4c40  801f4c40  00005ba4  2**0
                  CONTENTS
148 .inttab_tc0_063 00000000  801f4c60  801f4c60  00005ba4  2**0
                  CONTENTS
149 .inttab_tc0_064 0000000e  801f4c80  801f4c80  00005950  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
150 .inttab_tc0_065 00000000  801f4ca0  801f4ca0  00005ba4  2**0
                  CONTENTS
151 .inttab_tc0_066 00000000  801f4cc0  801f4cc0  00005ba4  2**0
                  CONTENTS
152 .inttab_tc0_067 00000000  801f4ce0  801f4ce0  00005ba4  2**0
                  CONTENTS
153 .inttab_tc0_068 00000000  801f4d00  801f4d00  00005ba4  2**0
                  CONTENTS
154 .inttab_tc0_069 00000000  801f4d20  801f4d20  00005ba4  2**0
                  CONTENTS
155 .inttab_tc0_06A 00000000  801f4d40  801f4d40  00005ba4  2**0
                  CONTENTS
156 .inttab_tc0_06B 00000000  801f4d60  801f4d60  00005ba4  2**0
                  CONTENTS
157 .inttab_tc0_06C 00000000  801f4d80  801f4d80  00005ba4  2**0
                  CONTENTS
158 .inttab_tc0_06D 00000000  801f4da0  801f4da0  00005ba4  2**0
                  CONTENTS
159 .inttab_tc0_06E 00000000  801f4dc0  801f4dc0  00005ba4  2**0
                  CONTENTS
160 .inttab_tc0_06F 00000000  801f4de0  801f4de0  00005ba4  2**0
                  CONTENTS
161 .inttab_tc0_070 00000000  801f4e00  801f4e00  00005ba4  2**0
                  CONTENTS
162 .inttab_tc0_071 00000000  801f4e20  801f4e20  00005ba4  2**0
                  CONTENTS
163 .inttab_tc0_072 00000000  801f4e40  801f4e40  00005ba4  2**0
                  CONTENTS
164 .inttab_tc0_073 00000000  801f4e60  801f4e60  00005ba4  2**0
                  CONTENTS
165 .inttab_tc0_074 00000000  801f4e80  801f4e80  00005ba4  2**0
                  CONTENTS
166 .inttab_tc0_075 00000000  801f4ea0  801f4ea0  00005ba4  2**0
                  CONTENTS
167 .inttab_tc0_076 00000000  801f4ec0  801f4ec0  00005ba4  2**0
                  CONTENTS
168 .inttab_tc0_077 00000000  801f4ee0  801f4ee0  00005ba4  2**0
                  CONTENTS
169 .inttab_tc0_078 00000000  801f4f00  801f4f00  00005ba4  2**0
                  CONTENTS
170 .inttab_tc0_079 00000000  801f4f20  801f4f20  00005ba4  2**0
                  CONTENTS
171 .inttab_tc0_07A 00000000  801f4f40  801f4f40  00005ba4  2**0
                  CONTENTS
172 .inttab_tc0_07B 00000000  801f4f60  801f4f60  00005ba4  2**0
                  CONTENTS
173 .inttab_tc0_07C 00000000  801f4f80  801f4f80  00005ba4  2**0
                  CONTENTS
174 .inttab_tc0_07D 00000000  801f4fa0  801f4fa0  00005ba4  2**0
                  CONTENTS
175 .inttab_tc0_07E 00000000  801f4fc0  801f4fc0  00005ba4  2**0
                  CONTENTS
176 .inttab_tc0_07F 00000000  801f4fe0  801f4fe0  00005ba4  2**0
                  CONTENTS
177 .inttab_tc0_080 00000000  801f5000  801f5000  00005ba4  2**0
                  CONTENTS
178 .inttab_tc0_081 00000000  801f5020  801f5020  00005ba4  2**0
                  CONTENTS
179 .inttab_tc0_082 00000000  801f5040  801f5040  00005ba4  2**0
                  CONTENTS
180 .inttab_tc0_083 00000000  801f5060  801f5060  00005ba4  2**0
                  CONTENTS
181 .inttab_tc0_084 00000000  801f5080  801f5080  00005ba4  2**0
                  CONTENTS
182 .inttab_tc0_085 00000000  801f50a0  801f50a0  00005ba4  2**0
                  CONTENTS
183 .inttab_tc0_086 00000000  801f50c0  801f50c0  00005ba4  2**0
                  CONTENTS
184 .inttab_tc0_087 00000000  801f50e0  801f50e0  00005ba4  2**0
                  CONTENTS
185 .inttab_tc0_088 00000000  801f5100  801f5100  00005ba4  2**0
                  CONTENTS
186 .inttab_tc0_089 00000000  801f5120  801f5120  00005ba4  2**0
                  CONTENTS
187 .inttab_tc0_08A 00000000  801f5140  801f5140  00005ba4  2**0
                  CONTENTS
188 .inttab_tc0_08B 00000000  801f5160  801f5160  00005ba4  2**0
                  CONTENTS
189 .inttab_tc0_08C 00000000  801f5180  801f5180  00005ba4  2**0
                  CONTENTS
190 .inttab_tc0_08D 00000000  801f51a0  801f51a0  00005ba4  2**0
                  CONTENTS
191 .inttab_tc0_08E 00000000  801f51c0  801f51c0  00005ba4  2**0
                  CONTENTS
192 .inttab_tc0_08F 00000000  801f51e0  801f51e0  00005ba4  2**0
                  CONTENTS
193 .inttab_tc0_090 00000000  801f5200  801f5200  00005ba4  2**0
                  CONTENTS
194 .inttab_tc0_091 00000000  801f5220  801f5220  00005ba4  2**0
                  CONTENTS
195 .inttab_tc0_092 00000000  801f5240  801f5240  00005ba4  2**0
                  CONTENTS
196 .inttab_tc0_093 00000000  801f5260  801f5260  00005ba4  2**0
                  CONTENTS
197 .inttab_tc0_094 00000000  801f5280  801f5280  00005ba4  2**0
                  CONTENTS
198 .inttab_tc0_095 00000000  801f52a0  801f52a0  00005ba4  2**0
                  CONTENTS
199 .inttab_tc0_096 00000000  801f52c0  801f52c0  00005ba4  2**0
                  CONTENTS
200 .inttab_tc0_097 00000000  801f52e0  801f52e0  00005ba4  2**0
                  CONTENTS
201 .inttab_tc0_098 00000000  801f5300  801f5300  00005ba4  2**0
                  CONTENTS
202 .inttab_tc0_099 00000000  801f5320  801f5320  00005ba4  2**0
                  CONTENTS
203 .inttab_tc0_09A 00000000  801f5340  801f5340  00005ba4  2**0
                  CONTENTS
204 .inttab_tc0_09B 00000000  801f5360  801f5360  00005ba4  2**0
                  CONTENTS
205 .inttab_tc0_09C 00000000  801f5380  801f5380  00005ba4  2**0
                  CONTENTS
206 .inttab_tc0_09D 00000000  801f53a0  801f53a0  00005ba4  2**0
                  CONTENTS
207 .inttab_tc0_09E 00000000  801f53c0  801f53c0  00005ba4  2**0
                  CONTENTS
208 .inttab_tc0_09F 00000000  801f53e0  801f53e0  00005ba4  2**0
                  CONTENTS
209 .inttab_tc0_0A0 00000000  801f5400  801f5400  00005ba4  2**0
                  CONTENTS
210 .inttab_tc0_0A1 00000000  801f5420  801f5420  00005ba4  2**0
                  CONTENTS
211 .inttab_tc0_0A2 00000000  801f5440  801f5440  00005ba4  2**0
                  CONTENTS
212 .inttab_tc0_0A3 00000000  801f5460  801f5460  00005ba4  2**0
                  CONTENTS
213 .inttab_tc0_0A4 00000000  801f5480  801f5480  00005ba4  2**0
                  CONTENTS
214 .inttab_tc0_0A5 00000000  801f54a0  801f54a0  00005ba4  2**0
                  CONTENTS
215 .inttab_tc0_0A6 00000000  801f54c0  801f54c0  00005ba4  2**0
                  CONTENTS
216 .inttab_tc0_0A7 00000000  801f54e0  801f54e0  00005ba4  2**0
                  CONTENTS
217 .inttab_tc0_0A8 00000000  801f5500  801f5500  00005ba4  2**0
                  CONTENTS
218 .inttab_tc0_0A9 00000000  801f5520  801f5520  00005ba4  2**0
                  CONTENTS
219 .inttab_tc0_0AA 00000000  801f5540  801f5540  00005ba4  2**0
                  CONTENTS
220 .inttab_tc0_0AB 00000000  801f5560  801f5560  00005ba4  2**0
                  CONTENTS
221 .inttab_tc0_0AC 00000000  801f5580  801f5580  00005ba4  2**0
                  CONTENTS
222 .inttab_tc0_0AD 00000000  801f55a0  801f55a0  00005ba4  2**0
                  CONTENTS
223 .inttab_tc0_0AE 00000000  801f55c0  801f55c0  00005ba4  2**0
                  CONTENTS
224 .inttab_tc0_0AF 00000000  801f55e0  801f55e0  00005ba4  2**0
                  CONTENTS
225 .inttab_tc0_0B0 00000000  801f5600  801f5600  00005ba4  2**0
                  CONTENTS
226 .inttab_tc0_0B1 00000000  801f5620  801f5620  00005ba4  2**0
                  CONTENTS
227 .inttab_tc0_0B2 00000000  801f5640  801f5640  00005ba4  2**0
                  CONTENTS
228 .inttab_tc0_0B3 00000000  801f5660  801f5660  00005ba4  2**0
                  CONTENTS
229 .inttab_tc0_0B4 00000000  801f5680  801f5680  00005ba4  2**0
                  CONTENTS
230 .inttab_tc0_0B5 00000000  801f56a0  801f56a0  00005ba4  2**0
                  CONTENTS
231 .inttab_tc0_0B6 00000000  801f56c0  801f56c0  00005ba4  2**0
                  CONTENTS
232 .inttab_tc0_0B7 00000000  801f56e0  801f56e0  00005ba4  2**0
                  CONTENTS
233 .inttab_tc0_0B8 00000000  801f5700  801f5700  00005ba4  2**0
                  CONTENTS
234 .inttab_tc0_0B9 00000000  801f5720  801f5720  00005ba4  2**0
                  CONTENTS
235 .inttab_tc0_0BA 00000000  801f5740  801f5740  00005ba4  2**0
                  CONTENTS
236 .inttab_tc0_0BB 00000000  801f5760  801f5760  00005ba4  2**0
                  CONTENTS
237 .inttab_tc0_0BC 00000000  801f5780  801f5780  00005ba4  2**0
                  CONTENTS
238 .inttab_tc0_0BD 00000000  801f57a0  801f57a0  00005ba4  2**0
                  CONTENTS
239 .inttab_tc0_0BE 00000000  801f57c0  801f57c0  00005ba4  2**0
                  CONTENTS
240 .inttab_tc0_0BF 00000000  801f57e0  801f57e0  00005ba4  2**0
                  CONTENTS
241 .inttab_tc0_0C0 00000000  801f5800  801f5800  00005ba4  2**0
                  CONTENTS
242 .inttab_tc0_0C1 00000000  801f5820  801f5820  00005ba4  2**0
                  CONTENTS
243 .inttab_tc0_0C2 00000000  801f5840  801f5840  00005ba4  2**0
                  CONTENTS
244 .inttab_tc0_0C3 00000000  801f5860  801f5860  00005ba4  2**0
                  CONTENTS
245 .inttab_tc0_0C4 00000000  801f5880  801f5880  00005ba4  2**0
                  CONTENTS
246 .inttab_tc0_0C5 00000000  801f58a0  801f58a0  00005ba4  2**0
                  CONTENTS
247 .inttab_tc0_0C6 00000000  801f58c0  801f58c0  00005ba4  2**0
                  CONTENTS
248 .inttab_tc0_0C7 00000000  801f58e0  801f58e0  00005ba4  2**0
                  CONTENTS
249 .inttab_tc0_0C8 0000000e  801f5900  801f5900  0000595e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
250 .inttab_tc0_0C9 00000000  801f5920  801f5920  00005ba4  2**0
                  CONTENTS
251 .inttab_tc0_0CA 00000000  801f5940  801f5940  00005ba4  2**0
                  CONTENTS
252 .inttab_tc0_0CB 00000000  801f5960  801f5960  00005ba4  2**0
                  CONTENTS
253 .inttab_tc0_0CC 00000000  801f5980  801f5980  00005ba4  2**0
                  CONTENTS
254 .inttab_tc0_0CD 00000000  801f59a0  801f59a0  00005ba4  2**0
                  CONTENTS
255 .inttab_tc0_0CE 00000000  801f59c0  801f59c0  00005ba4  2**0
                  CONTENTS
256 .inttab_tc0_0CF 00000000  801f59e0  801f59e0  00005ba4  2**0
                  CONTENTS
257 .inttab_tc0_0D0 00000000  801f5a00  801f5a00  00005ba4  2**0
                  CONTENTS
258 .inttab_tc0_0D1 00000000  801f5a20  801f5a20  00005ba4  2**0
                  CONTENTS
259 .inttab_tc0_0D2 00000000  801f5a40  801f5a40  00005ba4  2**0
                  CONTENTS
260 .inttab_tc0_0D3 00000000  801f5a60  801f5a60  00005ba4  2**0
                  CONTENTS
261 .inttab_tc0_0D4 00000000  801f5a80  801f5a80  00005ba4  2**0
                  CONTENTS
262 .inttab_tc0_0D5 00000000  801f5aa0  801f5aa0  00005ba4  2**0
                  CONTENTS
263 .inttab_tc0_0D6 00000000  801f5ac0  801f5ac0  00005ba4  2**0
                  CONTENTS
264 .inttab_tc0_0D7 00000000  801f5ae0  801f5ae0  00005ba4  2**0
                  CONTENTS
265 .inttab_tc0_0D8 00000000  801f5b00  801f5b00  00005ba4  2**0
                  CONTENTS
266 .inttab_tc0_0D9 00000000  801f5b20  801f5b20  00005ba4  2**0
                  CONTENTS
267 .inttab_tc0_0DA 00000000  801f5b40  801f5b40  00005ba4  2**0
                  CONTENTS
268 .inttab_tc0_0DB 00000000  801f5b60  801f5b60  00005ba4  2**0
                  CONTENTS
269 .inttab_tc0_0DC 00000000  801f5b80  801f5b80  00005ba4  2**0
                  CONTENTS
270 .inttab_tc0_0DD 00000000  801f5ba0  801f5ba0  00005ba4  2**0
                  CONTENTS
271 .inttab_tc0_0DE 00000000  801f5bc0  801f5bc0  00005ba4  2**0
                  CONTENTS
272 .inttab_tc0_0DF 00000000  801f5be0  801f5be0  00005ba4  2**0
                  CONTENTS
273 .inttab_tc0_0E0 00000000  801f5c00  801f5c00  00005ba4  2**0
                  CONTENTS
274 .inttab_tc0_0E1 00000000  801f5c20  801f5c20  00005ba4  2**0
                  CONTENTS
275 .inttab_tc0_0E2 00000000  801f5c40  801f5c40  00005ba4  2**0
                  CONTENTS
276 .inttab_tc0_0E3 00000000  801f5c60  801f5c60  00005ba4  2**0
                  CONTENTS
277 .inttab_tc0_0E4 00000000  801f5c80  801f5c80  00005ba4  2**0
                  CONTENTS
278 .inttab_tc0_0E5 00000000  801f5ca0  801f5ca0  00005ba4  2**0
                  CONTENTS
279 .inttab_tc0_0E6 00000000  801f5cc0  801f5cc0  00005ba4  2**0
                  CONTENTS
280 .inttab_tc0_0E7 00000000  801f5ce0  801f5ce0  00005ba4  2**0
                  CONTENTS
281 .inttab_tc0_0E8 00000000  801f5d00  801f5d00  00005ba4  2**0
                  CONTENTS
282 .inttab_tc0_0E9 00000000  801f5d20  801f5d20  00005ba4  2**0
                  CONTENTS
283 .inttab_tc0_0EA 00000000  801f5d40  801f5d40  00005ba4  2**0
                  CONTENTS
284 .inttab_tc0_0EB 00000000  801f5d60  801f5d60  00005ba4  2**0
                  CONTENTS
285 .inttab_tc0_0EC 00000000  801f5d80  801f5d80  00005ba4  2**0
                  CONTENTS
286 .inttab_tc0_0ED 00000000  801f5da0  801f5da0  00005ba4  2**0
                  CONTENTS
287 .inttab_tc0_0EE 00000000  801f5dc0  801f5dc0  00005ba4  2**0
                  CONTENTS
288 .inttab_tc0_0EF 00000000  801f5de0  801f5de0  00005ba4  2**0
                  CONTENTS
289 .inttab_tc0_0F0 00000000  801f5e00  801f5e00  00005ba4  2**0
                  CONTENTS
290 .inttab_tc0_0F1 00000000  801f5e20  801f5e20  00005ba4  2**0
                  CONTENTS
291 .inttab_tc0_0F2 00000000  801f5e40  801f5e40  00005ba4  2**0
                  CONTENTS
292 .inttab_tc0_0F3 00000000  801f5e60  801f5e60  00005ba4  2**0
                  CONTENTS
293 .inttab_tc0_0F4 00000000  801f5e80  801f5e80  00005ba4  2**0
                  CONTENTS
294 .inttab_tc0_0F5 00000000  801f5ea0  801f5ea0  00005ba4  2**0
                  CONTENTS
295 .inttab_tc0_0F6 00000000  801f5ec0  801f5ec0  00005ba4  2**0
                  CONTENTS
296 .inttab_tc0_0F7 00000000  801f5ee0  801f5ee0  00005ba4  2**0
                  CONTENTS
297 .inttab_tc0_0F8 00000000  801f5f00  801f5f00  00005ba4  2**0
                  CONTENTS
298 .inttab_tc0_0F9 00000000  801f5f20  801f5f20  00005ba4  2**0
                  CONTENTS
299 .inttab_tc0_0FA 00000000  801f5f40  801f5f40  00005ba4  2**0
                  CONTENTS
300 .inttab_tc0_0FB 00000000  801f5f60  801f5f60  00005ba4  2**0
                  CONTENTS
301 .inttab_tc0_0FC 00000000  801f5f80  801f5f80  00005ba4  2**0
                  CONTENTS
302 .inttab_tc0_0FD 00000000  801f5fa0  801f5fa0  00005ba4  2**0
                  CONTENTS
303 .inttab_tc0_0FE 00000000  801f5fc0  801f5fc0  00005ba4  2**0
                  CONTENTS
304 .inttab_tc0_0FF 00000000  801f5fe0  801f5fe0  00005ba4  2**0
                  CONTENTS
305 .comment      0000001b  00000000  00000000  00005ba4  2**0
                  CONTENTS, READONLY
306 .debug_aranges 00000d08  00000000  00000000  00005bc0  2**3
                  CONTENTS, READONLY, DEBUGGING
307 .debug_info   00180dd7  00000000  00000000  000068c8  2**0
                  CONTENTS, READONLY, DEBUGGING
308 .debug_abbrev 000073be  00000000  00000000  0018769f  2**0
                  CONTENTS, READONLY, DEBUGGING
309 .debug_line   0001b704  00000000  00000000  0018ea5d  2**0
                  CONTENTS, READONLY, DEBUGGING
310 .debug_frame  00001b88  00000000  00000000  001aa164  2**2
                  CONTENTS, READONLY, DEBUGGING
311 .debug_str    00005bc5  00000000  00000000  001abcec  2**0
                  CONTENTS, READONLY, DEBUGGING
312 .debug_loc    0000bd27  00000000  00000000  001b18b1  2**0
                  CONTENTS, READONLY, DEBUGGING
313 .debug_ranges 00001280  00000000  00000000  001bd5d8  2**3
                  CONTENTS, READONLY, DEBUGGING
314 .debug_macro  000ed554  00000000  00000000  001be858  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .startup:

80000020 <_START>:
#elif defined(__DCC__)
#pragma section CODE ".start" X
#endif

void _START(void)
{
80000020:	40 ae       	mov.aa %a14,%sp
    __non_return_call(_Core0_start);
80000022:	91 00 00 28 	movh.a %a2,32768
80000026:	d9 22 d2 b3 	lea %a2,[%a2]16082 <80003ed2 <_Core0_start>>
8000002a:	dc 02       	ji %a2
}
8000002c:	00 90       	ret 

8000002e <_START_end>:
8000002e:	08 00       	ld.bu %d0,[%a15]0

Disassembly of section .traptab_tc0:

80000100 <IfxCpu_Trap_vectorTable0>:
#pragma ghs section
#pragma ghs section text=".traptab_cpu0"
#endif
void IfxCpu_Trap_vectorTable0(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
80000100:	0d 00 00 02 	svlcx 
80000104:	02 f4       	mov %d4,%d15
80000106:	91 00 00 28 	movh.a %a2,32768
8000010a:	d9 22 94 a3 	lea %a2,[%a2]14996 <80003a94 <IfxCpu_Trap_memoryManagementError>>
8000010e:	dc 02       	ji %a2
80000110:	00 80       	rfe 
	...
8000011e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
80000120:	0d 00 00 02 	svlcx 
80000124:	02 f4       	mov %d4,%d15
80000126:	91 00 00 28 	movh.a %a2,32768
8000012a:	d9 22 82 b3 	lea %a2,[%a2]15042 <80003ac2 <IfxCpu_Trap_internalProtectionError>>
8000012e:	dc 02       	ji %a2
80000130:	00 80       	rfe 
	...
8000013e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
80000140:	0d 00 00 02 	svlcx 
80000144:	02 f4       	mov %d4,%d15
80000146:	91 00 00 28 	movh.a %a2,32768
8000014a:	d9 22 b0 b3 	lea %a2,[%a2]15088 <80003af0 <IfxCpu_Trap_instructionError>>
8000014e:	dc 02       	ji %a2
80000150:	00 80       	rfe 
	...
8000015e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
80000160:	02 f4       	mov %d4,%d15
80000162:	91 00 00 28 	movh.a %a2,32768
80000166:	d9 22 9e c3 	lea %a2,[%a2]15134 <80003b1e <IfxCpu_Trap_contextManagementError>>
8000016a:	dc 02       	ji %a2
8000016c:	00 80       	rfe 
	...
8000017e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
80000180:	0d 00 00 02 	svlcx 
80000184:	02 f4       	mov %d4,%d15
80000186:	91 00 00 28 	movh.a %a2,32768
8000018a:	d9 22 8c d3 	lea %a2,[%a2]15180 <80003b4c <IfxCpu_Trap_busError>>
8000018e:	dc 02       	ji %a2
80000190:	00 80       	rfe 
	...
8000019e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
800001a0:	0d 00 00 02 	svlcx 
800001a4:	02 f4       	mov %d4,%d15
800001a6:	91 00 00 28 	movh.a %a2,32768
800001aa:	d9 22 ba d3 	lea %a2,[%a2]15226 <80003b7a <IfxCpu_Trap_assertion>>
800001ae:	dc 02       	ji %a2
800001b0:	00 80       	rfe 
	...
800001be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu0);
800001c0:	0d 00 00 02 	svlcx 
800001c4:	02 f4       	mov %d4,%d15
800001c6:	91 00 00 28 	movh.a %a2,32768
800001ca:	d9 22 ae e3 	lea %a2,[%a2]15278 <80003bae <IfxCpu_Trap_systemCall_Cpu0>>
800001ce:	dc 02       	ji %a2
800001d0:	00 80       	rfe 
	...
800001de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
800001e0:	0d 00 00 02 	svlcx 
800001e4:	02 f4       	mov %d4,%d15
800001e6:	91 00 00 28 	movh.a %a2,32768
800001ea:	d9 22 f2 03 	lea %a2,[%a2]15410 <80003c32 <IfxCpu_Trap_nonMaskableInterrupt>>
800001ee:	dc 02       	ji %a2
800001f0:	00 80       	rfe 
}
800001f2:	00 90       	ret 

800001f4 <IfxCpu_Trap_vectorTable0_end>:
	...

Disassembly of section .text:

800005b8 <deregister_tm_clones>:
800005b8:	7b 00 00 26 	movh %d2,24576
800005bc:	1b 42 02 20 	addi %d2,%d2,36
800005c0:	91 00 00 46 	movh.a %a4,24576
800005c4:	60 22       	mov.a %a2,%d2
800005c6:	d9 44 24 00 	lea %a4,[%a4]36 <60000024 <__TMC_END__>>
800005ca:	7d 42 0a 00 	jeq.a %a2,%a4,800005de <deregister_tm_clones+0x26>
800005ce:	91 00 00 20 	movh.a %a2,0
800005d2:	d9 22 00 00 	lea %a2,[%a2]0 <0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x270>>
800005d6:	bd 02 04 00 	jz.a %a2,800005de <deregister_tm_clones+0x26>
800005da:	2d 02 00 00 	calli %a2
800005de:	00 90       	ret 

800005e0 <register_tm_clones>:
800005e0:	7b 00 00 26 	movh %d2,24576
800005e4:	1b 42 02 20 	addi %d2,%d2,36
800005e8:	91 00 00 46 	movh.a %a4,24576
800005ec:	60 22       	mov.a %a2,%d2
800005ee:	d9 44 24 00 	lea %a4,[%a4]36 <60000024 <__TMC_END__>>
800005f2:	01 42 20 20 	sub.a %a2,%a2,%a4
800005f6:	80 22       	mov.d %d2,%a2
800005f8:	8f e2 3f 30 	sha %d3,%d2,-2
800005fc:	8f 12 1e 20 	sh %d2,%d2,-31
80000600:	42 32       	add %d2,%d3
80000602:	8f f2 3f 40 	sha %d4,%d2,-1
80000606:	df 04 0a 00 	jeq %d4,0,8000061a <register_tm_clones+0x3a>
8000060a:	91 00 00 20 	movh.a %a2,0
8000060e:	d9 22 00 00 	lea %a2,[%a2]0 <0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x270>>
80000612:	bd 02 04 00 	jz.a %a2,8000061a <register_tm_clones+0x3a>
80000616:	2d 02 00 00 	calli %a2
8000061a:	00 90       	ret 

8000061c <__do_global_dtors_aux>:
8000061c:	91 00 00 e6 	movh.a %a14,24576
80000620:	39 e2 28 00 	ld.bu %d2,[%a14]40 <60000028 <completed.1>>
80000624:	df 02 2d 80 	jne %d2,0,8000067e <__do_global_dtors_aux+0x62>
80000628:	91 00 00 38 	movh.a %a3,32768
8000062c:	91 00 00 28 	movh.a %a2,32768
80000630:	d9 33 70 d5 	lea %a3,[%a3]22384 <80005770 <__DTOR_END__>>
80000634:	d9 22 64 d5 	lea %a2,[%a2]22372 <80005764 <__DTOR_LIST__>>
80000638:	01 23 20 20 	sub.a %a2,%a3,%a2
8000063c:	80 22       	mov.d %d2,%a2
8000063e:	86 e2       	sha %d2,-2
80000640:	1b f2 ff 8f 	addi %d8,%d2,-1
80000644:	91 00 00 c6 	movh.a %a12,24576
80000648:	7b 00 00 28 	movh %d2,32768
8000064c:	1b 42 76 25 	addi %d2,%d2,22372
80000650:	60 2d       	mov.a %a13,%d2
80000652:	19 c2 2c 00 	ld.w %d2,[%a12]44 <6000002c <dtor_idx.0>>
80000656:	7f 82 0f 80 	jge.u %d2,%d8,80000674 <__do_global_dtors_aux+0x58>
8000065a:	d9 cc 2c 00 	lea %a12,[%a12]44 <6000002c <dtor_idx.0>>
8000065e:	c2 12       	add %d2,1
80000660:	74 c2       	st.w [%a12],%d2
80000662:	06 22       	sh %d2,2
80000664:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000668:	d4 22       	ld.a %a2,[%a2]
8000066a:	2d 02 00 00 	calli %a2
8000066e:	54 c2       	ld.w %d2,[%a12]
80000670:	3f 82 f7 ff 	jlt.u %d2,%d8,8000065e <__do_global_dtors_aux+0x42>
80000674:	6d ff a2 ff 	call 800005b8 <deregister_tm_clones>
80000678:	82 12       	mov %d2,1
8000067a:	e9 e2 28 00 	st.b [%a14]40 <60000028 <completed.1>>,%d2
8000067e:	00 90       	ret 

80000680 <frame_dummy>:
80000680:	6d ff b0 ff 	call 800005e0 <register_tm_clones>
80000684:	00 90       	ret 

80000686 <Task1ms>:
    }
}


void Task1ms(void)
{
80000686:	40 ae       	mov.aa %a14,%sp
    cnt1ms++;
80000688:	91 00 00 26 	movh.a %a2,24576
8000068c:	d9 23 04 60 	lea %a3,[%a2]388 <60000184 <cnt1ms>>
80000690:	54 32       	ld.w %d2,[%a3]
80000692:	c2 12       	add %d2,1
80000694:	59 22 04 60 	st.w [%a2]388 <60000184 <cnt1ms>>,%d2
}
80000698:	00 90       	ret 

8000069a <Task10ms>:
void Task10ms(void)
{
8000069a:	40 ae       	mov.aa %a14,%sp
    cnt10ms++;
8000069c:	91 00 00 26 	movh.a %a2,24576
800006a0:	d9 23 00 60 	lea %a3,[%a2]384 <60000180 <cnt10ms>>
800006a4:	54 32       	ld.w %d2,[%a3]
800006a6:	c2 12       	add %d2,1
800006a8:	59 22 00 60 	st.w [%a2]384 <60000180 <cnt10ms>>,%d2
}
800006ac:	00 90       	ret 

800006ae <Task100ms>:
void Task100ms(void)
{
800006ae:	40 ae       	mov.aa %a14,%sp
    cnt100ms++;
800006b0:	91 00 00 26 	movh.a %a2,24576
800006b4:	d9 23 3c 50 	lea %a3,[%a2]380 <6000017c <cnt100ms>>
800006b8:	54 32       	ld.w %d2,[%a3]
800006ba:	c2 12       	add %d2,1
800006bc:	59 22 3c 50 	st.w [%a2]380 <6000017c <cnt100ms>>,%d2

    ADC_G3_GetData();
800006c0:	6d 00 08 22 	call 80004ad0 <ADC_G3_GetData>
    PWM_dutyUpdate();
800006c4:	6d 00 ac 00 	call 8000081c <PWM_dutyUpdate>
}
800006c8:	00 90       	ret 

800006ca <AppScheduling>:
{
800006ca:	40 ae       	mov.aa %a14,%sp
    if (Scheduler1msFlag == 1)
800006cc:	91 00 00 26 	movh.a %a2,24576
800006d0:	19 22 38 00 	ld.w %d2,[%a2]56 <60000038 <Scheduler1msFlag>>
800006d4:	df 12 03 00 	jeq %d2,1,800006da <AppScheduling+0x10>
}
800006d8:	00 90       	ret 
        Scheduler1msFlag = 0;
800006da:	82 02       	mov %d2,0
800006dc:	59 22 38 00 	st.w [%a2]56,%d2
        Task1ms();
800006e0:	6d ff d3 ff 	call 80000686 <Task1ms>
        if (Scheduler10msFlag == 1)
800006e4:	91 00 00 26 	movh.a %a2,24576
800006e8:	19 22 34 00 	ld.w %d2,[%a2]52 <60000034 <Scheduler10msFlag>>
800006ec:	df 12 0f 00 	jeq %d2,1,8000070a <AppScheduling+0x40>
        if (Scheduler100msFlag == 1)
800006f0:	91 00 00 26 	movh.a %a2,24576
800006f4:	19 22 30 00 	ld.w %d2,[%a2]48 <60000030 <Scheduler100msFlag>>
800006f8:	df 12 f0 ff 	jne %d2,1,800006d8 <AppScheduling+0xe>
            Scheduler100msFlag = 0;
800006fc:	82 02       	mov %d2,0
800006fe:	59 22 30 00 	st.w [%a2]48 <60000030 <Scheduler100msFlag>>,%d2
            Task100ms();
80000702:	6d ff d6 ff 	call 800006ae <Task100ms>
}
80000706:	1d ff e9 ff 	j 800006d8 <AppScheduling+0xe>
            Scheduler10msFlag = 0;
8000070a:	82 02       	mov %d2,0
8000070c:	59 22 34 00 	st.w [%a2]52,%d2
            Task10ms();
80000710:	6d ff c5 ff 	call 8000069a <Task10ms>
80000714:	1d ff ee ff 	j 800006f0 <AppScheduling+0x26>

80000718 <init_STM>:
uint32 Scheduler1msFlag = 0;
uint32 Scheduler10msFlag = 0;
uint32 Scheduler100msFlag = 0;

void init_STM(void)
{
80000718:	40 ae       	mov.aa %a14,%sp
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000071a:	4d c0 e2 8f 	mfcr %d8,$icr
    return reg.B.IE != 0;
8000071e:	37 08 e1 87 	extr.u %d8,%d8,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80000722:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80000726:	00 00       	nop 
    boolean ISR_State = IfxCpu_disableInterrupts();     // 진행 중인 인터럽트를 반환 및 인터럽트 중지

    IfxStm_enableOcdsSuspend(STM0);                     //OCDS: on chip debugging system [디버깅 시,cpu 중단하면 타이머도 같이 중단되도록 설정(시스템 상태분석 용이)]
80000728:	c5 f4 00 00 	lea %a4,f0000000 <_SMALL_DATA4_+0x5fff8000>
8000072c:	6d 00 1f 08 	call 8000176a <IfxStm_enableOcdsSuspend>
    IfxStm_initCompareConfig(&stmConfig);                // 비교기능 구조체 초기화 (초기값 정의)
80000730:	91 00 00 c6 	movh.a %a12,24576
80000734:	d9 cc 08 60 	lea %a12,[%a12]392 <60000188 <stmConfig>>
80000738:	40 c4       	mov.aa %a4,%a12
8000073a:	6d 00 f5 08 	call 80001924 <IfxStm_initCompareConfig>

    stmConfig.ticks           = 100000u;             // 주기 (비교 값) 설정 1밀리초 뒤 시작
8000073e:	7b 20 00 20 	movh %d2,2
80000742:	1b 02 6a 28 	addi %d2,%d2,-31072
80000746:	59 c2 10 00 	st.w [%a12]16 <60000010 <LCF_DSPR1_START+0x10>>,%d2
    stmConfig.triggerPriority = 100u;                   // STM 모듈에서 발생한 인터럽트 우선순위 설정 100번째 함수
8000074a:	3b 40 06 20 	mov %d2,100
8000074e:	f9 c2 14 00 	st.h [%a12]20 <60000014 <LCF_DSPR1_START+0x14>>,%d2
    stmConfig.typeOfService   = IfxSrc_Tos_cpu0;        // STM에서 발생한 인터럽트를 cpu0에서 처리하도록 설정
80000752:	82 02       	mov %d2,0
80000754:	59 c2 18 00 	st.w [%a12]24 <60000018 <increasing>>,%d2

    IfxStm_initCompare(STM0, &stmConfig);               // STM0의 비교기 초기화 및 설정 값 적용 (stmConfig로 바꿈)
80000758:	40 c5       	mov.aa %a5,%a12
8000075a:	c5 f4 00 00 	lea %a4,f0000000 <_SMALL_DATA4_+0x5fff8000>
8000075e:	6d 00 3a 08 	call 800017d2 <IfxStm_initCompare>
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80000762:	df 08 04 00 	jeq %d8,0,8000076a <init_STM+0x52>
    {
        __enable();
80000766:	0d 00 00 03 	enable 

    IfxCpu_restoreInterrupts(ISR_State);                // 진행 중이던 인터럽트 상태 복원
}
8000076a:	00 90       	ret 

8000076c <ISR_STM>:


IFX_INTERRUPT(ISR_STM,0,100);                           // 인터럽트 등록 명령어 (실행할 함수, 벡터 테이블 번호, 우선순위)

void ISR_STM(void)
{
8000076c:	40 ae       	mov.aa %a14,%sp
    __enable();
8000076e:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    IfxStm_clearCompareFlag(STM0, stmConfig.comparator);                // 비교 flag 초기화 (완료 표시 초기화)
80000772:	91 00 00 c6 	movh.a %a12,24576
80000776:	19 c4 08 60 	ld.w %d4,[%a12]392 <60000188 <stmConfig>>
8000077a:	c5 f4 00 00 	lea %a4,f0000000 <_SMALL_DATA4_+0x5fff8000>
8000077e:	6d 00 c8 07 	call 8000170e <IfxStm_clearCompareFlag>
    IfxStm_increaseCompare(STM0, stmConfig.comparator, 300000u);     // 비교 값 업데이트 (100000u >> 100000/100M = 0.001 = 1ms)
80000782:	19 c2 08 60 	ld.w %d2,[%a12]392 <60000188 <stmConfig>>
}


IFX_INLINE void IfxStm_increaseCompare(Ifx_STM *stm, IfxStm_Comparator comparator, uint32 ticks)
{
    stm->CMP[comparator].B.CMPVAL = stm->CMP[comparator].B.CMPVAL + ticks;
80000786:	1b c2 00 20 	addi %d2,%d2,12
8000078a:	06 22       	sh %d2,2
8000078c:	60 22       	mov.a %a2,%d2
8000078e:	11 02 00 2f 	addih.a %a2,%a2,61440
80000792:	54 22       	ld.w %d2,[%a2]
80000794:	7b 50 00 30 	movh %d3,5
80000798:	1b 03 3e 39 	addi %d3,%d3,-27680
8000079c:	42 32       	add %d2,%d3
8000079e:	74 22       	st.w [%a2],%d2

    counter1ms++;
800007a0:	91 00 00 26 	movh.a %a2,24576
800007a4:	d9 23 3c 00 	lea %a3,[%a2]60 <6000003c <counter1ms>>
800007a8:	54 32       	ld.w %d2,[%a3]
800007aa:	c2 12       	add %d2,1
800007ac:	59 22 3c 00 	st.w [%a2]60 <6000003c <counter1ms>>,%d2

    if ((counter1ms % 1) == 0){Scheduler1msFlag = 1;}           //1밀리초에 한번 flag가 1로 올라감 1초에 실행되는 scheduler 실행
800007b0:	91 00 00 26 	movh.a %a2,24576
800007b4:	82 13       	mov %d3,1
800007b6:	59 23 38 00 	st.w [%a2]56 <60000038 <Scheduler1msFlag>>,%d3
    if ((counter1ms % 10) == 0){Scheduler10msFlag = 1;}         //
800007ba:	7b d0 cc 4c 	movh %d4,52429
800007be:	1b d4 cc 4c 	addi %d4,%d4,-13107
800007c2:	73 42 68 40 	mul.u %e4,%d2,%d4
800007c6:	8f d5 1f 30 	sh %d3,%d5,-3
800007ca:	53 a3 20 30 	mul %d3,%d3,10
800007ce:	5f 32 07 80 	jne %d2,%d3,800007dc <ISR_STM+0x70>
800007d2:	91 00 00 26 	movh.a %a2,24576
800007d6:	82 13       	mov %d3,1
800007d8:	59 23 34 00 	st.w [%a2]52 <60000034 <Scheduler10msFlag>>,%d3
    if ((counter1ms % 100) == 0){Scheduler100msFlag = 1;}       //1000000u >> 10ms, 10ms&100 = 1s
800007dc:	7b c0 1e 45 	movh %d4,20972
800007e0:	1b f4 51 48 	addi %d4,%d4,-31457
800007e4:	73 42 68 40 	mul.u %e4,%d2,%d4
800007e8:	8f b5 1f 30 	sh %d3,%d5,-5
800007ec:	53 43 26 30 	mul %d3,%d3,100
800007f0:	5f 32 07 80 	jne %d2,%d3,800007fe <ISR_STM+0x92>
800007f4:	91 00 00 26 	movh.a %a2,24576
800007f8:	82 12       	mov %d2,1
800007fa:	59 22 30 00 	st.w [%a2]48 <60000030 <Scheduler100msFlag>>,%d2

}
800007fe:	0d 00 40 02 	rslcx 
80000802:	00 80       	rfe 

80000804 <ISR_PWM_GTM>:
   init_PWM(&timerConfig);       /* PWM 초기 설정 */
}

IFX_INTERRUPT(ISR_PWM_GTM, 0, PRIORITY_GTM);
void ISR_PWM_GTM(void)
{
80000804:	40 ae       	mov.aa %a14,%sp
80000806:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    IfxGtm_Tom_Timer_acknowledgeTimerIrq(&GtmPwmHl.timer);
8000080a:	91 00 00 46 	movh.a %a4,24576
8000080e:	d9 44 04 10 	lea %a4,[%a4]68 <60000044 <GtmPwmHl>>
80000812:	6d 00 a9 0d 	call 80002364 <IfxGtm_Tom_Timer_acknowledgeTimerIrq>
}
80000816:	0d 00 40 02 	rslcx 
8000081a:	00 80       	rfe 

8000081c <PWM_dutyUpdate>:
}
float dutyStep = 0.01; // 증가/감소 단계
boolean increasing = TRUE; // 증가/감소 방향 플래그

void PWM_dutyUpdate()
{
8000081c:	40 ae       	mov.aa %a14,%sp
8000081e:	20 08       	sub.a %sp,8
    GtmPwmHl.duty[0] += 0.1 * direction;
80000820:	91 00 00 26 	movh.a %a2,24576
80000824:	19 24 28 30 	ld.w %d4,[%a2]232 <600000e8 <direction>>
80000828:	6d 00 07 25 	call 80005236 <__floatsidf>
8000082c:	7b a0 99 69 	movh %d6,39322
80000830:	1b a6 99 69 	addi %d6,%d6,-26214
80000834:	7b a0 fb 73 	movh %d7,16314
80000838:	1b 97 99 79 	addi %d7,%d7,-26215
8000083c:	0b 23 10 48 	mov %e4,%d3,%d2
80000840:	6d 00 41 23 	call 80004ec2 <__muldf3>
80000844:	02 29       	mov %d9,%d2
80000846:	02 38       	mov %d8,%d3
80000848:	91 00 00 c6 	movh.a %a12,24576
8000084c:	d9 cc 04 10 	lea %a12,[%a12]68 <60000044 <GtmPwmHl>>
80000850:	19 c4 1c 20 	ld.w %d4,[%a12]156 <6000009c <GtmPwmHl+0x58>>
80000854:	6d 00 d5 21 	call 80004bfe <__extendsfdf2>
80000858:	0b 23 10 48 	mov %e4,%d3,%d2
8000085c:	02 96       	mov %d6,%d9
8000085e:	02 87       	mov %d7,%d8
80000860:	6d 00 14 23 	call 80004e88 <__adddf3>
80000864:	0b 23 10 48 	mov %e4,%d3,%d2
80000868:	6d 00 32 25 	call 800052cc <__truncdfsf2>
8000086c:	59 c2 1c 20 	st.w [%a12]156 <6000009c <GtmPwmHl+0x58>>,%d2
    if (GtmPwmHl.duty[0] >= 1.0) {
80000870:	7b 00 f8 33 	movh %d3,16256
80000874:	4b 32 01 30 	cmp.f %d3,%d2,%d3
80000878:	87 33 a2 30 	or.t %d3,%d3,2,%d3,1
8000087c:	df 03 4b 00 	jeq %d3,0,80000912 <PWM_dutyUpdate+0xf6>
        GtmPwmHl.duty[0] = 1.0;
80000880:	7b 00 f8 23 	movh %d2,16256
80000884:	59 c2 1c 20 	st.w [%a12]156 <6000009c <GtmPwmHl+0x58>>,%d2
        direction = -1;
80000888:	91 00 00 26 	movh.a %a2,24576
8000088c:	82 f2       	mov %d2,-1
8000088e:	59 22 28 30 	st.w [%a2]232 <600000e8 <direction>>,%d2
            }

    IfxGtm_Tom_PwmHl *pwmHl = &GtmPwmHl.pwm;
    IfxGtm_Tom_Timer *timer = &GtmPwmHl.timer;

    Ifx_TimerValue timerPeriod = IfxGtm_Tom_Timer_getPeriod(timer); /* = 타이머 한 주기 Tic 수 */
80000892:	91 00 00 c6 	movh.a %a12,24576
80000896:	d9 cc 04 10 	lea %a12,[%a12]68 <60000044 <GtmPwmHl>>
8000089a:	40 c4       	mov.aa %a4,%a12
8000089c:	6d 00 97 0d 	call 800023ca <IfxGtm_Tom_Timer_getPeriod>
    Ifx_TimerValue Duty2Tic[2];

    Duty2Tic[0] = (uint32)(GtmPwmHl.duty[0]*timerPeriod);           /* 듀티 값을 Tic 수로 한산 */
800008a0:	19 c3 1c 20 	ld.w %d3,[%a12]156 <6000009c <GtmPwmHl+0x58>>
800008a4:	4b 02 61 21 	utof %d2,%d2
800008a8:	4b 32 41 20 	mul.f %d2,%d2,%d3
800008ac:	4b 02 71 21 	ftouz %d2,%d2
800008b0:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    Duty2Tic[1] = (uint32)(GtmPwmHl.duty[0]*timerPeriod);;          /* 듀티 값을 Tic 수로 한산 */
800008b4:	59 e2 fc ff 	st.w [%a14]-4,%d2

    IfxGtm_Tom_Timer_disableUpdate(timer);                          /* 업데이트 비활성화 */
800008b8:	40 c4       	mov.aa %a4,%a12
800008ba:	6d 00 7a 0d 	call 800023ae <IfxGtm_Tom_Timer_disableUpdate>
    IfxGtm_Tom_PwmHl_setOnTime(pwmHl, Duty2Tic);                    /* 듀티 값 변경 */
800008be:	d9 e5 f8 ff 	lea %a5,[%a14]-8
800008c2:	d9 c4 04 10 	lea %a4,[%a12]68 <60000044 <GtmPwmHl>>
800008c6:	6d 00 98 11 	call 80002bf6 <IfxGtm_Tom_PwmHl_setOnTime>
    IfxGtm_Tom_Timer_applyUpdate(timer);                            /* 듀티 변경 값 적용 */
800008ca:	40 c4       	mov.aa %a4,%a12
800008cc:	6d 00 63 0d 	call 80002392 <IfxGtm_Tom_Timer_applyUpdate>

    // 듀티 사이클을 증가 또는 감소
     if (increasing) {
800008d0:	91 00 00 26 	movh.a %a2,24576
800008d4:	39 22 18 00 	ld.bu %d2,[%a2]24 <60000018 <increasing>>
800008d8:	df 02 31 00 	jeq %d2,0,8000093a <PWM_dutyUpdate+0x11e>
         GtmPwmHl.duty[0] += dutyStep; // Ch.1 듀티 증가
800008dc:	19 c3 1c 20 	ld.w %d3,[%a12]156 <6000009c <GtmPwmHl+0x58>>
800008e0:	91 00 00 36 	movh.a %a3,24576
800008e4:	d9 33 1c 00 	lea %a3,[%a3]28 <6000001c <dutyStep>>
800008e8:	54 32       	ld.w %d2,[%a3]
800008ea:	6b 02 21 23 	add.f %d2,%d3,%d2
800008ee:	59 c2 1c 20 	st.w [%a12]156 <6000009c <GtmPwmHl+0x58>>,%d2
         if (GtmPwmHl.duty[0] >= 1.0) {
800008f2:	7b 00 f8 33 	movh %d3,16256
800008f6:	4b 32 01 20 	cmp.f %d2,%d2,%d3
800008fa:	87 22 a2 20 	or.t %d2,%d2,2,%d2,1
800008fe:	df 02 34 00 	jeq %d2,0,80000966 <PWM_dutyUpdate+0x14a>
             GtmPwmHl.duty[0] = 1.0;
80000902:	59 c3 1c 20 	st.w [%a12]156 <6000009c <GtmPwmHl+0x58>>,%d3
             increasing = FALSE; // 방향 변경
80000906:	91 00 00 26 	movh.a %a2,24576
8000090a:	82 02       	mov %d2,0
8000090c:	e9 22 18 00 	st.b [%a2]24 <60000018 <increasing>>,%d2
80000910:	00 90       	ret 
    else if (GtmPwmHl.duty[0] <= 0.0) {
80000912:	82 03       	mov %d3,0
80000914:	4b 32 01 20 	cmp.f %d2,%d2,%d3
80000918:	87 22 a0 20 	or.t %d2,%d2,0,%d2,1
8000091c:	df 02 bb 7f 	jeq %d2,0,80000892 <PWM_dutyUpdate+0x76>
        GtmPwmHl.duty[0] = 0.0;
80000920:	91 00 00 26 	movh.a %a2,24576
80000924:	d9 22 04 10 	lea %a2,[%a2]68 <60000044 <GtmPwmHl>>
80000928:	59 23 1c 20 	st.w [%a2]156 <6000009c <GtmPwmHl+0x58>>,%d3
        direction = 1;
8000092c:	91 00 00 26 	movh.a %a2,24576
80000930:	82 12       	mov %d2,1
80000932:	59 22 28 30 	st.w [%a2]232 <600000e8 <direction>>,%d2
80000936:	1d ff ae ff 	j 80000892 <PWM_dutyUpdate+0x76>
         }
     } else {
         GtmPwmHl.duty[0] -= dutyStep; // Ch.1 듀티 감소
8000093a:	91 00 00 26 	movh.a %a2,24576
8000093e:	d9 22 04 10 	lea %a2,[%a2]68 <60000044 <GtmPwmHl>>
80000942:	19 23 1c 20 	ld.w %d3,[%a2]156 <6000009c <GtmPwmHl+0x58>>
80000946:	91 00 00 36 	movh.a %a3,24576
8000094a:	d9 33 1c 00 	lea %a3,[%a3]28 <6000001c <dutyStep>>
8000094e:	54 32       	ld.w %d2,[%a3]
80000950:	6b 02 31 23 	sub.f %d2,%d3,%d2
80000954:	59 22 1c 20 	st.w [%a2]156 <6000009c <GtmPwmHl+0x58>>,%d2
         if (GtmPwmHl.duty[0] <= 0.0) {
80000958:	82 03       	mov %d3,0
8000095a:	4b 32 01 20 	cmp.f %d2,%d2,%d3
8000095e:	87 22 a0 20 	or.t %d2,%d2,0,%d2,1
80000962:	df 02 03 80 	jne %d2,0,80000968 <PWM_dutyUpdate+0x14c>
             GtmPwmHl.duty[0] = 0.0;
             increasing = TRUE; // 방향 변경
         }
     }
 }
80000966:	00 90       	ret 
             GtmPwmHl.duty[0] = 0.0;
80000968:	91 00 00 26 	movh.a %a2,24576
8000096c:	d9 22 04 10 	lea %a2,[%a2]68 <60000044 <GtmPwmHl>>
80000970:	59 23 1c 20 	st.w [%a2]156 <6000009c <GtmPwmHl+0x58>>,%d3
             increasing = TRUE; // 방향 변경
80000974:	91 00 00 26 	movh.a %a2,24576
80000978:	82 12       	mov %d2,1
8000097a:	e9 22 18 00 	st.b [%a2]24 <60000018 <increasing>>,%d2
 }
8000097e:	1d ff f4 ff 	j 80000966 <PWM_dutyUpdate+0x14a>

80000982 <init_PWM>:
{
80000982:	40 ae       	mov.aa %a14,%sp
80000984:	20 48       	sub.a %sp,72
80000986:	40 4d       	mov.aa %a13,%a4
    IfxGtm_Tom_PwmHl_initConfig(&pwmHlConfig);   /* 구조체 디폴트 값으로 초기화 */
80000988:	d9 e4 c8 ff 	lea %a4,[%a14]-56
8000098c:	6d 00 a2 16 	call 800036d0 <IfxGtm_Tom_PwmHl_initConfig>
    ccx[0]   = &IfxGtm_TOM0_4_TOUT22_P33_0_OUT; /* PWM 출력 핀 설정 Ch.1 ccx */
80000990:	91 00 00 28 	movh.a %a2,32768
80000994:	d9 22 30 80 	lea %a2,[%a2]560 <80000230 <IfxGtm_TOM0_4_TOUT22_P33_0_OUT>>
80000998:	b5 e2 c0 ff 	st.a [%a14]-64 <80000230 <IfxGtm_TOM0_4_TOUT22_P33_0_OUT>>,%a2
    coutx[0] = &IfxGtm_TOM0_3_TOUT105_P10_3_OUT;/* PWM 출력 핀 설정 Ch.1 coutx */
8000099c:	91 00 00 28 	movh.a %a2,32768
800009a0:	d9 22 0c 90 	lea %a2,[%a2]588 <8000024c <IfxGtm_TOM0_3_TOUT105_P10_3_OUT>>
800009a4:	b5 e2 f8 ef 	st.a [%a14]-72 <8000024c <IfxGtm_TOM0_3_TOUT105_P10_3_OUT>>,%a2
    ccx[1]   = &IfxGtm_TOM0_5_TOUT23_P33_1_OUT; /* PWM 출력 핀 설정 Ch.2 ccx */
800009a8:	91 00 00 28 	movh.a %a2,32768
800009ac:	d9 22 14 80 	lea %a2,[%a2]532 <80000214 <IfxGtm_TOM0_5_TOUT23_P33_1_OUT>>
800009b0:	b5 e2 c4 ff 	st.a [%a14]-60 <80000214 <IfxGtm_TOM0_5_TOUT23_P33_1_OUT>>,%a2
    coutx[1] = &IfxGtm_TOM0_2_TOUT107_P10_5_OUT;/* PWM 출력 핀 설정 Ch.2 coutx */
800009b4:	91 00 00 28 	movh.a %a2,32768
800009b8:	d9 22 28 90 	lea %a2,[%a2]616 <80000268 <IfxGtm_TOM0_2_TOUT107_P10_5_OUT>>
800009bc:	b5 e2 fc ef 	st.a [%a14]-68 <80000268 <IfxGtm_TOM0_2_TOUT107_P10_5_OUT>>,%a2
    pwmHlConfig.timer                   = &GtmPwmHl.timer;                          /* 타이머 객체 설정 */
800009c0:	91 00 00 c6 	movh.a %a12,24576
800009c4:	d9 cc 04 10 	lea %a12,[%a12]68 <60000044 <GtmPwmHl>>
800009c8:	b5 ec ec ff 	st.a [%a14]-20 <60000044 <GtmPwmHl>>,%a12
    pwmHlConfig.tom                     = timerConfig ->tom;                        /* TOM 설정 */
800009cc:	19 d2 38 00 	ld.w %d2,[%a13]56 <60000044 <GtmPwmHl>>
800009d0:	59 e2 f0 ff 	st.w [%a14]-16 <60000044 <GtmPwmHl>>,%d2
    pwmHlConfig.base.deadtime           = 2e-6;                                     /* 데드 타임 설정 */
800009d4:	7b 60 60 23 	movh %d2,13830
800009d8:	1b d2 7b 23 	addi %d2,%d2,14269
800009dc:	59 e2 c8 ff 	st.w [%a14]-56,%d2
    pwmHlConfig.base.minPulse           = 1e-6;                                     /* 최소 펄스 시간 설정 */
800009e0:	7b 60 58 23 	movh %d2,13702
800009e4:	1b d2 7b 23 	addi %d2,%d2,14269
800009e8:	59 e2 cc ff 	st.w [%a14]-52,%d2
    pwmHlConfig.base.channelCount       = 2;                                        /* PWM 채널 수 설정 */
800009ec:	82 22       	mov %d2,2
800009ee:	e9 e2 d0 ff 	st.b [%a14]-48,%d2
    pwmHlConfig.base.emergencyEnabled   = FALSE;                                    /* 비상 기능 설정 */
800009f2:	82 02       	mov %d2,0
800009f4:	e9 e2 d1 ff 	st.b [%a14]-47,%d2
    pwmHlConfig.base.outputMode         = IfxPort_OutputMode_none;                  /* 출력 모드 설정 */
800009f8:	82 02       	mov %d2,0
800009fa:	59 e2 d4 ff 	st.w [%a14]-44,%d2
    pwmHlConfig.base.outputDriver       = IfxPort_PadDriver_cmosAutomotiveSpeed1;   /* PWM 드라이버 타입 설정) */
800009fe:	59 e2 d8 ff 	st.w [%a14]-40,%d2
    pwmHlConfig.base.ccxActiveState     = Ifx_ActiveState_high;                     /* 핀 활성 상태 설정 (Low or High일 때 활성 설정) */
80000a02:	82 12       	mov %d2,1
80000a04:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    pwmHlConfig.base.coutxActiveState   = Ifx_ActiveState_high;                     /* 핀 활성 상태 설정 (Low or High일 때 활성 설정) */
80000a08:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    pwmHlConfig.ccx                     = ccx;                                      /* 핀 적용 (Compare capture x) */
80000a0c:	d9 e2 c0 ff 	lea %a2,[%a14]-64
80000a10:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
    pwmHlConfig.coutx                   = coutx;                                    /* 핀 적용 (Compare output x) */
80000a14:	d9 e2 f8 ef 	lea %a2,[%a14]-72
80000a18:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
    IfxGtm_Tom_PwmHl_init(&GtmPwmHl.pwm, &pwmHlConfig);                             /* PWM 설정 값 적용 */
80000a1c:	80 c2       	mov.d %d2,%a12
80000a1e:	1b 42 04 80 	addi %d8,%d2,68
80000a22:	d9 e5 c8 ff 	lea %a5,[%a14]-56
80000a26:	60 84       	mov.a %a4,%d8
80000a28:	6d 00 59 14 	call 800032da <IfxGtm_Tom_PwmHl_init>
    IfxGtm_Tom_PwmHl_setMode(&GtmPwmHl.pwm, Ifx_Pwm_Mode_centerAligned);            /* PWM 생성 방식 설정 */
80000a2c:	82 04       	mov %d4,0
80000a2e:	60 84       	mov.a %a4,%d8
80000a30:	6d 00 3a 10 	call 80002aa4 <IfxGtm_Tom_PwmHl_setMode>
    GtmPwmHl.duty[0] = 0;    /* Ch.1 듀티 설정 */
80000a34:	82 02       	mov %d2,0
80000a36:	59 c2 1c 20 	st.w [%a12]156 <6000009c <GtmPwmHl+0x58>>,%d2
    GtmPwmHl.duty[1] = 0;     /* Ch.2 듀티 설정 */
80000a3a:	59 c2 20 20 	st.w [%a12]160 <600000a0 <GtmPwmHl+0x5c>>,%d2
    PWM_dutyUpdate();           /* 듀티 설정 */
80000a3e:	6d ff ef fe 	call 8000081c <PWM_dutyUpdate>
    IfxGtm_Tom_Timer_run(&GtmPwmHl.timer);  /* 타이머 및 PWM 시작 */
80000a42:	40 c4       	mov.aa %a4,%a12
80000a44:	6d 00 09 0d 	call 80002456 <IfxGtm_Tom_Timer_run>
}
80000a48:	00 90       	ret 

80000a4a <init_Tom>:
{
80000a4a:	40 ae       	mov.aa %a14,%sp
80000a4c:	20 58       	sub.a %sp,88
   IfxGtm_Tom_Timer_initConfig(&timerConfig, &MODULE_GTM);
80000a4e:	91 00 01 5f 	movh.a %a5,61456
80000a52:	d9 e4 ec ef 	lea %a4,[%a14]-84
80000a56:	6d 00 ed 0f 	call 80002a30 <IfxGtm_Tom_Timer_initConfig>
   timerConfig.base.frequency       = 2000;                                          /* PWM 주기 */
80000a5a:	7b a0 4f 24 	movh %d2,17658
80000a5e:	59 e2 ec ef 	st.w [%a14]-84,%d2
   timerConfig.base.isrPriority     = PRIORITY_GTM;                                  /* 인터럽트 우선순위 */
80000a62:	3b 80 0c 20 	mov %d2,200
80000a66:	f9 e2 f0 ef 	st.h [%a14]-80,%d2
   timerConfig.base.isrProvider     = IfxSrc_Tos_cpu0;                               /* 인터럽트 처리 cpu 설정 */
80000a6a:	82 03       	mov %d3,0
80000a6c:	59 e3 f4 ef 	st.w [%a14]-76,%d3
   timerConfig.base.minResolution   = (1.0/timerConfig.base.frequency) / 1000;       /* 최소 분해능 설정 */
80000a70:	7b 60 50 23 	movh %d2,13574
80000a74:	1b d2 7b 23 	addi %d2,%d2,14269
80000a78:	59 e2 f8 ef 	st.w [%a14]-72,%d2
   timerConfig.clock                = IfxGtm_Tom_Ch_ClkSrc_cmuFxclk0;                /* Base clock (100MHz)에서 몇을 나누어 사용할지 */
80000a7c:	59 e3 f0 ff 	st.w [%a14]-16,%d3
   timerConfig.base.countDir        = IfxStdIf_Timer_CountDir_upAndDown;             /* 비교파 모양 설정 */
80000a80:	82 12       	mov %d2,1
80000a82:	59 e2 d8 ff 	st.w [%a14]-40,%d2
   timerConfig.tom                  = IfxGtm_Tom_0;                                  /* 몇 번째 TOM 사용할지 설정 */
80000a86:	59 e3 e4 ff 	st.w [%a14]-28,%d3
   timerConfig.timerChannel         = IfxGtm_Tom_Ch_0;                               /* TOM 채널 설정 */
80000a8a:	59 e3 e8 ff 	st.w [%a14]-24,%d3
   timerConfig.triggerOut           = &IfxGtm_TOM0_0_TOUT77_P15_6_OUT;               /* trigger 출력 핀 설정 */
80000a8e:	91 00 00 28 	movh.a %a2,32768
80000a92:	d9 22 04 a0 	lea %a2,[%a2]644 <80000284 <IfxGtm_TOM0_0_TOUT77_P15_6_OUT>>
80000a96:	b5 e2 ec ff 	st.a [%a14]-20 <80000284 <IfxGtm_TOM0_0_TOUT77_P15_6_OUT>>,%a2
   timerConfig.base.trigger.enabled             = TRUE;                              /* trigger 활성화 */
80000a9a:	e9 e2 fc ef 	st.b [%a14]-68 <80000284 <IfxGtm_TOM0_0_TOUT77_P15_6_OUT>>,%d2
   timerConfig.base.trigger.outputEnabled       = TRUE;                              /* trigger 출력 활성화 */
80000a9e:	e9 e2 d5 ff 	st.b [%a14]-43 <80000284 <IfxGtm_TOM0_0_TOUT77_P15_6_OUT>>,%d2
   timerConfig.base.trigger.triggerPoint        = 500;                               /* 이벤트 발생(ex: 1) 후 몇 틱(tick) 후에 이벤트를 끝낼지 (ex:0) */
80000aa2:	3b 40 1f 30 	mov %d3,500
80000aa6:	59 e3 c0 ff 	st.w [%a14]-64,%d3
   timerConfig.base.trigger.risingEdgeAtPeriod  = TRUE;                              /* 디폴트를 0으로할지 1로 할지 (ex: TRUE --> 디폴트 0, 이벤트 발생 시 1) */
80000aaa:	e9 e2 d4 ff 	st.b [%a14]-44,%d2
   IfxGtm_Tom_Timer_init(&GtmPwmHl.timer, &timerConfig);                             /* 설정 값 반영 */
80000aae:	d9 e5 ec ef 	lea %a5,[%a14]-84
80000ab2:	91 00 00 46 	movh.a %a4,24576
80000ab6:	d9 44 04 10 	lea %a4,[%a4]68 <60000044 <GtmPwmHl>>
80000aba:	6d 00 77 0d 	call 800025a8 <IfxGtm_Tom_Timer_init>
   init_PWM(&timerConfig);       /* PWM 초기 설정 */
80000abe:	d9 e4 ec ef 	lea %a4,[%a14]-84
80000ac2:	6d ff 60 ff 	call 80000982 <init_PWM>
}
80000ac6:	00 90       	ret 

80000ac8 <init_GTM>:

void init_GTM(void)
{
80000ac8:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_ICR);
80000aca:	4d c0 e2 8f 	mfcr %d8,$icr
    return reg.B.IE != 0;
80000ace:	37 08 e1 87 	extr.u %d8,%d8,15,1
    __disable();
80000ad2:	0d 00 40 03 	disable 
80000ad6:	00 00       	nop 
    boolean interruptState = IfxCpu_disableInterrupts();

    Ifx_GTM *gtm = &MODULE_GTM;
    float32 gtmFreq = IfxGtm_Cmu_getModuleFrequency(gtm);           /* GTM 모듈 클럭 주파수 가져오기(100MHz) */
80000ad8:	91 00 01 4f 	movh.a %a4,61456
80000adc:	6d 00 35 16 	call 80003746 <IfxGtm_Cmu_getModuleFrequency>
80000ae0:	02 29       	mov %d9,%d2
    IfxGtm_enable(gtm);
80000ae2:	91 00 01 4f 	movh.a %a4,61456
80000ae6:	6d 00 06 16 	call 800036f2 <IfxGtm_enable>

    IfxGtm_Cmu_setGclkFrequency(&MODULE_GTM, gtmFreq);              /* Global clock 주기 설정) */
80000aea:	02 94       	mov %d4,%d9
80000aec:	91 00 01 4f 	movh.a %a4,61456
80000af0:	6d 00 56 17 	call 8000399c <IfxGtm_Cmu_setGclkFrequency>

    float32 gtmGclkFreq = IfxGtm_Cmu_getGclkFrequency(gtm);
80000af4:	91 00 01 4f 	movh.a %a4,61456
80000af8:	6d 00 2b 16 	call 8000374e <IfxGtm_Cmu_getGclkFrequency>
    IfxGtm_Cmu_setClkFrequency(&MODULE_GTM, IfxGtm_Cmu_Clk_0, gtmGclkFreq); /* clk_0 클럭 주파수 설정) */
80000afc:	02 25       	mov %d5,%d2
80000afe:	82 04       	mov %d4,0
80000b00:	91 00 01 4f 	movh.a %a4,61456
80000b04:	6d 00 06 17 	call 80003910 <IfxGtm_Cmu_setClkFrequency>

    init_Tom();         /* TOM 및 PWM 초기 설정 */
80000b08:	6d ff a1 ff 	call 80000a4a <init_Tom>
    if (enabled != FALSE)
80000b0c:	df 08 04 00 	jeq %d8,0,80000b14 <init_GTM+0x4c>
        __enable();
80000b10:	0d 00 00 03 	enable 

    IfxCpu_restoreInterrupts(interruptState);   /* enable interrupts again */
    IfxGtm_Cmu_enableClocks(gtm, IFXGTM_CMU_CLKEN_FXCLK | IFXGTM_CMU_CLKEN_CLK0);
80000b14:	7b 00 08 40 	movh %d4,128
80000b18:	c2 24       	add %d4,2
80000b1a:	91 00 01 4f 	movh.a %a4,61456
80000b1e:	6d 00 10 16 	call 8000373e <IfxGtm_Cmu_enableClocks>
}
80000b22:	00 90       	ret 

80000b24 <IfxGtm_PinMap_setTomTout>:
    IfxPort_setPinModeOutput(config->pin.port, config->pin.pinIndex, outputMode, config->select);
    IfxPort_setPinPadDriver(config->pin.port, config->pin.pinIndex, padDriver);
}

void IfxGtm_PinMap_setTomTout(IfxGtm_Tom_ToutMap *config, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
80000b24:	40 ae       	mov.aa %a14,%sp
80000b26:	40 4c       	mov.aa %a12,%a4
80000b28:	02 58       	mov %d8,%d5
    uint32 outselReg = (config->toutn >> 4);
80000b2a:	19 42 0c 00 	ld.w %d2,[%a4]12
80000b2e:	8f c2 1f 70 	sh %d7,%d2,-4
    uint32 shift = (config->toutn & 0xFU) * 2;
80000b32:	8f f2 00 21 	and %d2,%d2,15
80000b36:	06 12       	sh %d2,1
    uint32 outsel = (uint32)config->toutSel << shift;
80000b38:	19 43 08 00 	ld.w %d3,[%a4]8
80000b3c:	0f 23 00 60 	sh %d6,%d3,%d2
    uint32 mask = 0x3U << shift;
80000b40:	82 33       	mov %d3,3
80000b42:	0f 23 00 30 	sh %d3,%d3,%d2

    __ldmst_c(&(MODULE_GTM.INOUTSEL.T.OUTSEL[outselReg].U), mask, outsel);
80000b46:	8f 27 00 20 	sh %d2,%d7,2
80000b4a:	7b a0 01 5f 	movh %d5,61466
80000b4e:	1b 05 d3 5f 	addi %d5,%d5,-720
80000b52:	60 52       	mov.a %a2,%d5
80000b54:	01 22 00 26 	addsc.a %a2,%a2,%d2,0


/******************************************************************************/
IFX_INLINE void __ldmst_c(volatile void *address, unsigned mask, unsigned value)
{
    *(volatile uint32 *)address = (*(volatile uint32 *)address & ~(mask)) | (mask & value);
80000b58:	54 22       	ld.w %d2,[%a2]
80000b5a:	c6 26       	xor %d6,%d2
80000b5c:	26 63       	and %d3,%d6
80000b5e:	c6 32       	xor %d2,%d3
80000b60:	74 22       	st.w [%a2],%d2
    IfxPort_setPinModeOutput(config->pin.port, config->pin.pinIndex, outputMode, config->select);
80000b62:	19 45 18 00 	ld.w %d5,[%a4]24
}


IFX_INLINE void IfxPort_setPinModeOutput(Ifx_P *port, uint8 pinIndex, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
80000b66:	a6 45       	or %d5,%d4
80000b68:	39 44 14 00 	ld.bu %d4,[%a4]20
80000b6c:	99 44 10 00 	ld.a %a4,[%a4]16
80000b70:	6d 00 9e 0b 	call 800022ac <IfxPort_setPinMode>
    IfxPort_setPinPadDriver(config->pin.port, config->pin.pinIndex, padDriver);
80000b74:	02 85       	mov %d5,%d8
80000b76:	39 c4 14 00 	ld.bu %d4,[%a12]20
80000b7a:	99 c4 10 00 	ld.a %a4,[%a12]16
80000b7e:	6d 00 ce 0b 	call 8000231a <IfxPort_setPinPadDriver>
}
80000b82:	00 90       	ret 

80000b84 <IfxVadc_disableAccess>:
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
}


void IfxVadc_disableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
80000b84:	40 ae       	mov.aa %a14,%sp
80000b86:	40 4c       	mov.aa %a12,%a4
80000b88:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
80000b8a:	6d 00 39 0b 	call 800021fc <IfxScuWdt_getSafetyWatchdogPassword>
80000b8e:	02 29       	mov %d9,%d2
    IfxScuWdt_clearSafetyEndinit(passwd);
80000b90:	02 24       	mov %d4,%d2
80000b92:	6d 00 df 09 	call 80001f50 <IfxScuWdt_clearSafetyEndinit>

    if (protectionSet < IFXVADC_MAXIMUM_BITFIELDS_IN_ACCPROT0_REGISTER)
80000b96:	8b 08 a2 32 	ge.u %d3,%d8,32
80000b9a:	df 03 0d 80 	jne %d3,0,80000bb4 <IfxVadc_disableAccess+0x30>
    {
        vadc->ACCPROT0.U |= (0x00000001 << protectionSet);
80000b9e:	d9 c2 08 20 	lea %a2,[%a12]136
80000ba2:	19 c2 08 20 	ld.w %d2,[%a12]136
80000ba6:	d7 12 01 28 	insert %d2,%d2,1,%d8,1
80000baa:	74 22       	st.w [%a2],%d2
    else
    {
        vadc->ACCPROT1.U |= (0x00000001 << (protectionSet & 0x1F));
    }

    IfxScuWdt_setSafetyEndinit(passwd);
80000bac:	02 94       	mov %d4,%d9
80000bae:	6d 00 57 0b 	call 8000225c <IfxScuWdt_setSafetyEndinit>
}
80000bb2:	00 90       	ret 
        vadc->ACCPROT1.U |= (0x00000001 << (protectionSet & 0x1F));
80000bb4:	d9 c2 0c 20 	lea %a2,[%a12]140
80000bb8:	19 c3 0c 20 	ld.w %d3,[%a12]140
80000bbc:	8f f8 01 21 	and %d2,%d8,31
80000bc0:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
80000bc4:	74 22       	st.w [%a2],%d2
80000bc6:	1d ff f3 ff 	j 80000bac <IfxVadc_disableAccess+0x28>

80000bca <IfxVadc_enableAccess>:
    }
}


void IfxVadc_enableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
80000bca:	40 ae       	mov.aa %a14,%sp
80000bcc:	40 4c       	mov.aa %a12,%a4
80000bce:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
80000bd0:	6d 00 16 0b 	call 800021fc <IfxScuWdt_getSafetyWatchdogPassword>
80000bd4:	02 29       	mov %d9,%d2
    IfxScuWdt_clearSafetyEndinit(passwd);
80000bd6:	02 24       	mov %d4,%d2
80000bd8:	6d 00 bc 09 	call 80001f50 <IfxScuWdt_clearSafetyEndinit>

    if (protectionSet < IFXVADC_MAXIMUM_BITFIELDS_IN_ACCPROT0_REGISTER)
80000bdc:	8b 08 a2 32 	ge.u %d3,%d8,32
80000be0:	df 03 0d 80 	jne %d3,0,80000bfa <IfxVadc_enableAccess+0x30>
    {
        vadc->ACCPROT0.U &= ~(0x00000001 << protectionSet);
80000be4:	d9 c2 08 20 	lea %a2,[%a12]136
80000be8:	19 c2 08 20 	ld.w %d2,[%a12]136
80000bec:	d7 02 01 28 	insert %d2,%d2,0,%d8,1
80000bf0:	74 22       	st.w [%a2],%d2
    else
    {
        vadc->ACCPROT1.U &= ~(0x00000001 << (protectionSet & 0x1F));
    }

    IfxScuWdt_setSafetyEndinit(passwd);
80000bf2:	02 94       	mov %d4,%d9
80000bf4:	6d 00 34 0b 	call 8000225c <IfxScuWdt_setSafetyEndinit>
}
80000bf8:	00 90       	ret 
        vadc->ACCPROT1.U &= ~(0x00000001 << (protectionSet & 0x1F));
80000bfa:	d9 c2 0c 20 	lea %a2,[%a12]140
80000bfe:	19 c3 0c 20 	ld.w %d3,[%a12]140
80000c02:	8f f8 01 21 	and %d2,%d8,31
80000c06:	d7 03 01 22 	insert %d2,%d3,0,%d2,1
80000c0a:	74 22       	st.w [%a2],%d2
80000c0c:	1d ff f3 ff 	j 80000bf2 <IfxVadc_enableAccess+0x28>

80000c10 <IfxVadc_disablePostCalibration>:
{
80000c10:	40 ae       	mov.aa %a14,%sp
80000c12:	40 4c       	mov.aa %a12,%a4
80000c14:	02 48       	mov %d8,%d4
80000c16:	8f f5 0f 91 	and %d9,%d5,255
    if (group < IFXVADC_NUM_ADC_CAL_GROUPS)
80000c1a:	bf 84 03 80 	jlt.u %d4,8,80000c20 <IfxVadc_disablePostCalibration+0x10>
}
80000c1e:	00 90       	ret 
        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80000c20:	3b f0 01 40 	mov %d4,31
80000c24:	6d ff d3 ff 	call 80000bca <IfxVadc_enableAccess>
        uint32 mask = 1 << (IFX_VADC_GLOBCFG_DPCAL0_OFF + group);
80000c28:	1b 08 01 80 	addi %d8,%d8,16
80000c2c:	82 12       	mov %d2,1
80000c2e:	0f 82 00 20 	sh %d2,%d2,%d8
        if (disable == TRUE)
80000c32:	df 19 10 00 	jeq %d9,1,80000c52 <IfxVadc_disablePostCalibration+0x42>
            vadc->GLOBCFG.U &= ~mask;
80000c36:	d9 c2 00 20 	lea %a2,[%a12]128
80000c3a:	19 c3 00 20 	ld.w %d3,[%a12]128
80000c3e:	0f 23 e0 20 	andn %d2,%d3,%d2
80000c42:	74 22       	st.w [%a2],%d2
        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80000c44:	3b f0 01 40 	mov %d4,31
80000c48:	40 c4       	mov.aa %a4,%a12
80000c4a:	6d ff 9d ff 	call 80000b84 <IfxVadc_disableAccess>
}
80000c4e:	1d ff e8 ff 	j 80000c1e <IfxVadc_disablePostCalibration+0xe>
            vadc->GLOBCFG.U |= mask;
80000c52:	d9 c2 00 20 	lea %a2,[%a12]128
80000c56:	19 c3 00 20 	ld.w %d3,[%a12]128
80000c5a:	a6 32       	or %d2,%d3
80000c5c:	74 22       	st.w [%a2],%d2
80000c5e:	1d ff f3 ff 	j 80000c44 <IfxVadc_disablePostCalibration+0x34>

80000c62 <IfxVadc_getAdcAnalogFrequency>:
    IfxScuWdt_setCpuEndinit(passwd);
}


float32 IfxVadc_getAdcAnalogFrequency(Ifx_VADC *vadc)
{
80000c62:	40 ae       	mov.aa %a14,%sp
80000c64:	40 4c       	mov.aa %a12,%a4
    return IfxScuCcu_getSpbFrequency() / (1U + vadc->GLOBCFG.B.DIVA);
80000c66:	6d 00 67 07 	call 80001b34 <IfxScuCcu_getSpbFrequency>
80000c6a:	19 c3 00 20 	ld.w %d3,[%a12]128
80000c6e:	8f f3 01 31 	and %d3,%d3,31
80000c72:	c2 13       	add %d3,1
80000c74:	4b 03 61 31 	utof %d3,%d3
}
80000c78:	4b 32 51 20 	div.f %d2,%d2,%d3
80000c7c:	00 90       	ret 

80000c7e <IfxVadc_getAdcDigitalFrequency>:


float32 IfxVadc_getAdcDigitalFrequency(Ifx_VADC *vadc)
{
80000c7e:	40 ae       	mov.aa %a14,%sp
80000c80:	40 4c       	mov.aa %a12,%a4
    return IfxScuCcu_getSpbFrequency() / (1U + vadc->GLOBCFG.B.DIVD);
80000c82:	6d 00 59 07 	call 80001b34 <IfxScuCcu_getSpbFrequency>
80000c86:	19 c3 00 20 	ld.w %d3,[%a12]128
80000c8a:	37 03 62 34 	extr.u %d3,%d3,8,2
80000c8e:	c2 13       	add %d3,1
80000c90:	4b 03 61 31 	utof %d3,%d3
}
80000c94:	4b 32 51 20 	div.f %d2,%d2,%d3
80000c98:	00 90       	ret 

80000c9a <IfxVadc_getSrcAddress>:
    }
}


volatile Ifx_SRC_SRCR *IfxVadc_getSrcAddress(IfxVadc_GroupId group, IfxVadc_SrcNr index)
{
80000c9a:	40 ae       	mov.aa %a14,%sp
    Ifx_SRC_SRCR *base;

    if (IfxVadc_SrcNr_shared0 <= index)
80000c9c:	bf 45 07 80 	jlt.u %d5,4,80000caa <IfxVadc_getSrcAddress+0x10>
    {
        index -= 4;
80000ca0:	c2 c5       	add %d5,-4

        if ((group & 0x1) != 0)
80000ca2:	6f 04 10 00 	jz.t %d4,0,80000cc2 <IfxVadc_getSrcAddress+0x28>
        {
            group = IfxVadc_GroupId_global1;    /* Shared interrupt common 1 is used */
80000ca6:	3b 90 00 40 	mov %d4,9
    else
    {
        /* do nothing */
    }

    base = (Ifx_SRC_SRCR *)IfxVadc_cfg_srcAddresses[(group * 4) + index];
80000caa:	8f 24 00 20 	sh %d2,%d4,2
80000cae:	42 52       	add %d2,%d5
80000cb0:	06 22       	sh %d2,2
80000cb2:	91 00 00 28 	movh.a %a2,32768
80000cb6:	d9 22 10 b0 	lea %a2,[%a2]720 <800002d0 <IfxVadc_cfg_srcAddresses>>
80000cba:	01 22 00 26 	addsc.a %a2,%a2,%d2,0

    return &(base[0]);
}
80000cbe:	d4 22       	ld.a %a2,[%a2]
80000cc0:	00 90       	ret 
            group = IfxVadc_GroupId_global0;    /* Shared interrupt common 0 is used */
80000cc2:	3b 80 00 40 	mov %d4,8
80000cc6:	1d ff f2 ff 	j 80000caa <IfxVadc_getSrcAddress+0x10>

80000cca <IfxVadc_initialiseAdcArbiterClock>:


void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
80000cca:	40 ae       	mov.aa %a14,%sp
80000ccc:	40 4c       	mov.aa %a12,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
80000cce:	19 42 00 20 	ld.w %d2,[%a4]128
80000cd2:	02 28       	mov %d8,%d2
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
80000cd4:	37 48 02 84 	insert %d8,%d8,%d4,8,2
    tempGLOBCFG.B.DIVWC = 1;
80000cd8:	b7 18 81 87 	insert %d8,%d8,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80000cdc:	3b f0 01 40 	mov %d4,31
80000ce0:	6d ff 75 ff 	call 80000bca <IfxVadc_enableAccess>
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
80000ce4:	59 c8 00 20 	st.w [%a12]128,%d8
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80000ce8:	3b f0 01 40 	mov %d4,31
80000cec:	40 c4       	mov.aa %a4,%a12
80000cee:	6d ff 4b ff 	call 80000b84 <IfxVadc_disableAccess>
}
80000cf2:	00 90       	ret 

80000cf4 <IfxVadc_initialiseAdcConverterClock>:


void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
80000cf4:	40 ae       	mov.aa %a14,%sp
80000cf6:	40 4c       	mov.aa %a12,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
80000cf8:	19 42 00 20 	ld.w %d2,[%a4]128
80000cfc:	02 28       	mov %d8,%d2
    tempGLOBCFG.B.DIVA  = converterClockDivider;
80000cfe:	37 48 05 80 	insert %d8,%d8,%d4,0,5
    tempGLOBCFG.B.DIVWC = 1;
80000d02:	b7 18 81 87 	insert %d8,%d8,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80000d06:	3b f0 01 40 	mov %d4,31
80000d0a:	6d ff 60 ff 	call 80000bca <IfxVadc_enableAccess>
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
80000d0e:	59 c8 00 20 	st.w [%a12]128,%d8
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80000d12:	3b f0 01 40 	mov %d4,31
80000d16:	40 c4       	mov.aa %a4,%a12
80000d18:	6d ff 36 ff 	call 80000b84 <IfxVadc_disableAccess>
}
80000d1c:	00 90       	ret 

80000d1e <IfxVadc_initializeFAdcD>:


uint32 IfxVadc_initializeFAdcD(Ifx_VADC *vadc, uint32 fAdcD)
{
80000d1e:	40 ae       	mov.aa %a14,%sp
80000d20:	80 4a       	mov.d %d10,%a4
80000d22:	02 48       	mov %d8,%d4
    uint32 divD;
    uint32 result;
    uint32 fadc = IfxScuCcu_getSpbFrequency();
80000d24:	6d 00 08 07 	call 80001b34 <IfxScuCcu_getSpbFrequency>
80000d28:	4b 02 71 21 	ftouz %d2,%d2

    divD   = (fadc / fAdcD - 1);
80000d2c:	4b 82 11 82 	div.u %e8,%d2,%d8
80000d30:	1b f8 ff 3f 	addi %d3,%d8,-1
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80000d34:	82 34       	mov %d4,3
80000d36:	0b 43 90 41 	min.u %d4,%d3,%d4

    divD   = __minu(divD, 0x3u);

    result = fadc / (divD + 1);
80000d3a:	1b 14 00 80 	addi %d8,%d4,1
80000d3e:	4b 82 11 82 	div.u %e8,%d2,%d8
    IfxVadc_initialiseAdcArbiterClock(vadc, divD);
80000d42:	60 a4       	mov.a %a4,%d10
80000d44:	6d ff c3 ff 	call 80000cca <IfxVadc_initialiseAdcArbiterClock>
    return result;
}
80000d48:	02 82       	mov %d2,%d8
80000d4a:	00 90       	ret 

80000d4c <IfxVadc_initializeFAdcI>:


uint32 IfxVadc_initializeFAdcI(Ifx_VADC *vadc, uint32 fAdcI)
{
80000d4c:	40 ae       	mov.aa %a14,%sp
80000d4e:	80 49       	mov.d %d9,%a4
80000d50:	02 48       	mov %d8,%d4
    uint32 divA;
    uint32 result;
    uint32 fadc = IfxScuCcu_getSpbFrequency();
80000d52:	6d 00 f1 06 	call 80001b34 <IfxScuCcu_getSpbFrequency>
80000d56:	4b 02 71 31 	ftouz %d3,%d2

    /*    DivA = min(max(0, Fadc / FAdcI - 1), 0x3F); */
    divA   = (fadc << 2) / fAdcI;
80000d5a:	8f 23 00 40 	sh %d4,%d3,2
80000d5e:	4b 84 11 42 	div.u %e4,%d4,%d8

    divA   = (divA + 2) >> 2; /* Round to nearest integer */
80000d62:	1b 24 00 20 	addi %d2,%d4,2
80000d66:	06 e2       	sh %d2,-2
    divA   = __minu(divA - 1, 0x1Fu);
80000d68:	c2 f2       	add %d2,-1
80000d6a:	3b f0 01 40 	mov %d4,31
80000d6e:	0b 42 90 41 	min.u %d4,%d2,%d4
    result = fadc / (divA + 1);
80000d72:	1b 14 00 20 	addi %d2,%d4,1
80000d76:	4b 23 11 62 	div.u %e6,%d3,%d2
80000d7a:	02 68       	mov %d8,%d6

    if (result > IFXVADC_ANALOG_FREQUENCY_MAX)
80000d7c:	7b 10 13 50 	movh %d5,305
80000d80:	1b 05 d0 52 	addi %d5,%d5,11520
80000d84:	7f 65 0b 80 	jge.u %d5,%d6,80000d9a <IfxVadc_initializeFAdcI+0x4e>
80000d88:	3b f0 01 40 	mov %d4,31
80000d8c:	0b 42 90 41 	min.u %d4,%d2,%d4
    {
        divA   = __minu(divA + 1, 0x1Fu);

        result = fadc / (divA + 1);
80000d90:	1b 14 00 20 	addi %d2,%d4,1
80000d94:	4b 23 11 22 	div.u %e2,%d3,%d2
80000d98:	02 28       	mov %d8,%d2
    else
    {
        /* do nothing */
    }

    if (!((result >= IFXVADC_ANALOG_FREQUENCY_MIN) && (result <= IFXVADC_ANALOG_FREQUENCY_MAX)))
80000d9a:	7b 80 ff 2f 	movh %d2,65528
80000d9e:	1b 02 ee 25 	addi %d2,%d2,24288
80000da2:	42 82       	add %d2,%d8
80000da4:	7b a0 12 30 	movh %d3,298
80000da8:	1b 03 be 38 	addi %d3,%d3,-29728
80000dac:	7f 23 05 80 	jge.u %d3,%d2,80000db6 <IfxVadc_initializeFAdcI+0x6a>
    {
        result = 0;             /* Min / Max FAdcI frequency */
80000db0:	82 08       	mov %d8,0
    {
        IfxVadc_initialiseAdcConverterClock(vadc, divA);
    }

    return result;
}
80000db2:	02 82       	mov %d2,%d8
80000db4:	00 90       	ret 
        IfxVadc_initialiseAdcConverterClock(vadc, divA);
80000db6:	60 94       	mov.a %a4,%d9
80000db8:	6d ff 9e ff 	call 80000cf4 <IfxVadc_initialiseAdcConverterClock>
80000dbc:	1d ff fb ff 	j 80000db2 <IfxVadc_initializeFAdcI+0x66>

80000dc0 <IfxVadc_selectPowerSupplyVoltage>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
80000dc0:	40 ae       	mov.aa %a14,%sp
80000dc2:	40 4c       	mov.aa %a12,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
80000dc4:	19 42 00 20 	ld.w %d2,[%a4]128
80000dc8:	02 28       	mov %d8,%d2
    tempGLOBCFG.B.LOSUP = supplyVoltage;
80000dca:	67 48 0e 80 	ins.t %d8,%d8,14,%d4,0
    tempGLOBCFG.B.DIVWC = 1;
80000dce:	b7 18 81 87 	insert %d8,%d8,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80000dd2:	3b f0 01 40 	mov %d4,31
80000dd6:	6d ff fa fe 	call 80000bca <IfxVadc_enableAccess>
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
80000dda:	59 c8 00 20 	st.w [%a12]128,%d8
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80000dde:	3b f0 01 40 	mov %d4,31
80000de2:	40 c4       	mov.aa %a4,%a12
80000de4:	6d ff d0 fe 	call 80000b84 <IfxVadc_disableAccess>
}
80000de8:	00 90       	ret 

80000dea <IfxVadc_setArbiterPriority>:


void IfxVadc_setArbiterPriority(Ifx_VADC_G *vadcG, boolean slotEnable, IfxVadc_RequestSlotPriority prio, IfxVadc_RequestSlotStartMode mode, IfxVadc_RequestSource slot)
{
80000dea:	40 ae       	mov.aa %a14,%sp
80000dec:	02 50       	mov %d0,%d5
    if (slotEnable != FALSE)
80000dee:	df 04 2a 00 	jeq %d4,0,80000e42 <IfxVadc_setArbiterPriority+0x58>
    {
        vadcG->ARBPR.U |= slotEnable << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot); /* enable Slot */
80000df2:	d9 42 04 00 	lea %a2,[%a4]4
80000df6:	19 43 04 00 	ld.w %d3,[%a4]4
80000dfa:	1b 87 01 20 	addi %d2,%d7,24
80000dfe:	0f 24 00 20 	sh %d2,%d4,%d2
80000e02:	a6 32       	or %d2,%d3
80000e04:	74 22       	st.w [%a2],%d2
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_PRIO0_MSK << (slot * 4u));      /* clear Priority */
80000e06:	54 23       	ld.w %d3,[%a2]
80000e08:	06 27       	sh %d7,2
80000e0a:	82 32       	mov %d2,3
80000e0c:	0f 72 00 20 	sh %d2,%d2,%d7
80000e10:	0f 23 e0 20 	andn %d2,%d3,%d2
80000e14:	74 22       	st.w [%a2],%d2
        vadcG->ARBPR.U |= (prio << (slot * 4u));                             /* Set Priority */
80000e16:	54 23       	ld.w %d3,[%a2]
80000e18:	0f 70 00 20 	sh %d2,%d0,%d7
80000e1c:	a6 32       	or %d2,%d3
80000e1e:	74 22       	st.w [%a2],%d2

        if (mode != IfxVadc_RequestSlotStartMode_waitForStart)
80000e20:	df 06 08 00 	jeq %d6,0,80000e30 <IfxVadc_setArbiterPriority+0x46>
        {
            vadcG->ARBPR.U |= 0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)); /* Set cancel inject mode */
80000e24:	54 22       	ld.w %d2,[%a2]
80000e26:	c2 37       	add %d7,3
80000e28:	d7 12 01 27 	insert %d2,%d2,1,%d7,1
80000e2c:	74 22       	st.w [%a2],%d2
80000e2e:	00 90       	ret 
        }
        else
        {
            vadcG->ARBPR.U &= ~(0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)));  /* Set Wait for Start mode */
80000e30:	d9 42 04 00 	lea %a2,[%a4]4
80000e34:	19 42 04 00 	ld.w %d2,[%a4]4
80000e38:	c2 37       	add %d7,3
80000e3a:	d7 02 01 27 	insert %d2,%d2,0,%d7,1
80000e3e:	74 22       	st.w [%a2],%d2
80000e40:	00 90       	ret 
        }
    }
    else
    {
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_ASEN0_MSK << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot));  /* disable Slot */
80000e42:	d9 42 04 00 	lea %a2,[%a4]4
80000e46:	19 43 04 00 	ld.w %d3,[%a4]4
80000e4a:	1b 87 01 20 	addi %d2,%d7,24
80000e4e:	d7 03 01 22 	insert %d2,%d3,0,%d2,1
80000e52:	74 22       	st.w [%a2],%d2
    }
}
80000e54:	00 90       	ret 

80000e56 <IfxVadc_setScan>:


void IfxVadc_setScan(Ifx_VADC_G *group, uint32 channels, uint32 mask)
{
80000e56:	40 ae       	mov.aa %a14,%sp
    /* select channels which should take part in the scan sequence */
    /* the mask allows to specify the channels which should be enabled/disabled */
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
80000e58:	d9 42 28 20 	lea %a2,[%a4]168
80000e5c:	19 42 28 20 	ld.w %d2,[%a4]168
80000e60:	0f 42 c0 30 	xor %d3,%d2,%d4
80000e64:	26 53       	and %d3,%d5
80000e66:	c6 32       	xor %d2,%d3
80000e68:	74 22       	st.w [%a2],%d2
}
80000e6a:	00 90       	ret 

80000e6c <IfxVadc_startupCalibration>:


void IfxVadc_startupCalibration(Ifx_VADC *vadc)
{
80000e6c:	40 ae       	mov.aa %a14,%sp
80000e6e:	40 4c       	mov.aa %a12,%a4
    boolean calibrationRunning;
    uint8   adcCalGroupNum;

    /* Start calibration */
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80000e70:	3b f0 01 40 	mov %d4,31
80000e74:	6d ff ab fe 	call 80000bca <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_initiateStartupCalibration(Ifx_VADC *vadc)
{
    vadc->GLOBCFG.B.SUCAL = 1;
80000e78:	d9 c2 00 20 	lea %a2,[%a12]128
80000e7c:	19 c2 00 20 	ld.w %d2,[%a12]128
80000e80:	b7 12 81 2f 	insert %d2,%d2,1,31,1
80000e84:	74 22       	st.w [%a2],%d2
    /* Set SUCAL bit */
    IfxVadc_initiateStartupCalibration(vadc);
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80000e86:	3b f0 01 40 	mov %d4,31
80000e8a:	40 c4       	mov.aa %a4,%a12
80000e8c:	6d ff 7c fe 	call 80000b84 <IfxVadc_disableAccess>
    /* Wait until Calibration is done */
    do
    {
        calibrationRunning = FALSE;

        for (adcCalGroupNum = 0; adcCalGroupNum < IFXVADC_NUM_ADC_CAL_GROUPS; adcCalGroupNum++)
80000e90:	82 02       	mov %d2,0
        calibrationRunning = FALSE;
80000e92:	82 04       	mov %d4,0
        for (adcCalGroupNum = 0; adcCalGroupNum < IFXVADC_NUM_ADC_CAL_GROUPS; adcCalGroupNum++)
80000e94:	1d 00 05 00 	j 80000e9e <IfxVadc_startupCalibration+0x32>
80000e98:	c2 12       	add %d2,1
80000e9a:	8f f2 0f 21 	and %d2,%d2,255
80000e9e:	ff 82 0d 80 	jge.u %d2,8,80000eb8 <IfxVadc_startupCalibration+0x4c>
    status = vadc->G[adcCalGroupNum].ARBCFG.B.CAL;
80000ea2:	8f a2 00 30 	sh %d3,%d2,10
80000ea6:	01 c3 00 26 	addsc.a %a2,%a12,%d3,0
80000eaa:	19 23 40 20 	ld.w %d3,[%a2]1152
        {
            if (IfxVadc_getAdcCalibrationActiveState(vadc, adcCalGroupNum) != 0)     /* Check ADC Calibration Flag CAL */
80000eae:	ef c3 f5 7f 	jz.t %d3,28,80000e98 <IfxVadc_startupCalibration+0x2c>
            {
                calibrationRunning = TRUE;
80000eb2:	82 14       	mov %d4,1
80000eb4:	1d ff f2 ff 	j 80000e98 <IfxVadc_startupCalibration+0x2c>
            else
            {
                /* do nothing */
            }
        }
    } while (calibrationRunning == TRUE); /* wait until calibration of all calibrated kernels are done */
80000eb8:	df 04 ec ff 	jne %d4,0,80000e90 <IfxVadc_startupCalibration+0x24>
}
80000ebc:	00 90       	ret 

80000ebe <IfxVadc_Adc_initChannel>:
    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
}


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
80000ebe:	40 ae       	mov.aa %a14,%sp
80000ec0:	40 4f       	mov.aa %a15,%a4
80000ec2:	40 5c       	mov.aa %a12,%a5
    IfxVadc_Status    Status = IfxVadc_Status_noError;
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
80000ec4:	99 52 38 00 	ld.a %a2,[%a5]56
}


IFX_INLINE Ifx_VADC *IfxVadc_Adc_getVadcFromGroup(const IfxVadc_Adc_Group *group)
{
    return group->module.vadc;
80000ec8:	54 28       	ld.w %d8,[%a2]
    return group->group;
80000eca:	99 2d 04 00 	ld.a %a13,[%a2]4
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
80000ece:	b5 42 08 00 	st.a [%a4]8,%a2
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
80000ed2:	19 29 08 00 	ld.w %d9,[%a2]8
    IfxVadc_ChannelId channelIndex = config->channelId;
80000ed6:	19 5a 18 00 	ld.w %d10,[%a5]24

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
80000eda:	02 94       	mov %d4,%d9
80000edc:	60 84       	mov.a %a4,%d8
80000ede:	6d ff 76 fe 	call 80000bca <IfxVadc_enableAccess>

    /* Configure Channel */
    {
        IfxVadc_setReferenceInput(vadcG, channelIndex, config->reference);
80000ee2:	19 c3 20 00 	ld.w %d3,[%a12]32
}


IFX_INLINE void IfxVadc_setReferenceInput(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_ChannelReference reference)
{
    vadcG->CHCTR[channelIndex].B.REFSEL = reference;
80000ee6:	1b 0a 06 20 	addi %d2,%d10,96
80000eea:	06 22       	sh %d2,2
80000eec:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000ef0:	54 22       	ld.w %d2,[%a2]
80000ef2:	67 32 0b 20 	ins.t %d2,%d2,11,%d3,0
80000ef6:	74 22       	st.w [%a2],%d2
        IfxVadc_storeGroupResult(vadcG, channelIndex, config->resultRegister);
80000ef8:	19 c3 24 00 	ld.w %d3,[%a12]36
}


IFX_INLINE void IfxVadc_storeGroupResult(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_ChannelResult resultRegister)
{
    vadcG->CHCTR[channelIndex].B.RESREG = resultRegister;
80000efc:	54 22       	ld.w %d2,[%a2]
80000efe:	37 32 04 28 	insert %d2,%d2,%d3,16,4
80000f02:	74 22       	st.w [%a2],%d2
        IfxVadc_setLowerBoundary(vadcG, channelIndex, config->lowerBoundary);
80000f04:	19 c3 28 00 	ld.w %d3,[%a12]40
    vadcG->CHCTR[channelIndex].B.BNDSELL = lowerBoundary;
80000f08:	54 22       	ld.w %d2,[%a2]
80000f0a:	37 32 02 22 	insert %d2,%d2,%d3,4,2
80000f0e:	74 22       	st.w [%a2],%d2
        IfxVadc_setUpperBoundary(vadcG, channelIndex, config->upperBoundary);
80000f10:	19 c3 2c 00 	ld.w %d3,[%a12]44
    vadcG->CHCTR[channelIndex].B.BNDSELU = upperBoundary;
80000f14:	54 22       	ld.w %d2,[%a2]
80000f16:	37 32 02 23 	insert %d2,%d2,%d3,6,2
80000f1a:	74 22       	st.w [%a2],%d2
        IfxVadc_setSyncRequest(vadcG, channelIndex, config->synchonize);
80000f1c:	39 c3 01 00 	ld.bu %d3,[%a12]1
    vadcG->CHCTR[channelIndex].B.SYNC = synchonize;
80000f20:	54 22       	ld.w %d2,[%a2]
80000f22:	67 32 0a 20 	ins.t %d2,%d2,10,%d3,0
80000f26:	74 22       	st.w [%a2],%d2
        IfxVadc_setChannelInputClass(vadcG, channelIndex, config->inputClass);
80000f28:	19 c3 1c 00 	ld.w %d3,[%a12]28
    vadcG->CHCTR[channelIndex].B.ICLSEL = inputClass;
80000f2c:	54 22       	ld.w %d2,[%a2]
80000f2e:	37 32 02 20 	insert %d2,%d2,%d3,0,2
80000f32:	74 22       	st.w [%a2],%d2
        IfxVadc_setChannelLimitCheckMode(vadcG, channelIndex, config->limitCheck);
80000f34:	19 c3 34 00 	ld.w %d3,[%a12]52
    vadcG->CHCTR[channelIndex].B.CHEVMODE = limitCheck;
80000f38:	54 22       	ld.w %d2,[%a2]
80000f3a:	37 32 02 24 	insert %d2,%d2,%d3,8,2
80000f3e:	74 22       	st.w [%a2],%d2
        IfxVadc_setResultPosition(vadcG, channelIndex, config->rightAlignedStorage);
80000f40:	39 c3 03 00 	ld.bu %d3,[%a12]3
    vadcG->CHCTR[channelIndex].B.RESPOS = rightAlignedStorage;
80000f44:	54 22       	ld.w %d2,[%a2]
80000f46:	67 32 15 20 	ins.t %d2,%d2,21,%d3,0
80000f4a:	74 22       	st.w [%a2],%d2
        IfxVadc_setBackgroundResultTarget(vadcG, channelIndex, config->globalResultUsage);
80000f4c:	14 c3       	ld.bu %d3,[%a12]
    vadcG->CHCTR[channelIndex].B.RESTBS = globalResultUsage;
80000f4e:	54 22       	ld.w %d2,[%a2]
80000f50:	67 32 14 20 	ins.t %d2,%d2,20,%d3,0
80000f54:	74 22       	st.w [%a2],%d2
        IfxVadc_setBoundaryMode(vadcG, channelIndex, config->boundaryMode);
80000f56:	19 c3 30 00 	ld.w %d3,[%a12]48
    vadcG->CHCTR[channelIndex].B.BNDSELX = boundaryMode;
80000f5a:	54 22       	ld.w %d2,[%a2]
80000f5c:	37 32 04 26 	insert %d2,%d2,%d3,12,4
80000f60:	74 22       	st.w [%a2],%d2
    }

    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80000f62:	1b 09 01 b0 	addi %d11,%d9,16
80000f66:	02 b4       	mov %d4,%d11
80000f68:	60 84       	mov.a %a4,%d8
80000f6a:	6d ff 30 fe 	call 80000bca <IfxVadc_enableAccess>

    if (config->backgroundChannel == FALSE)
80000f6e:	39 c2 02 00 	ld.bu %d2,[%a12]2
80000f72:	df 02 4c 80 	jne %d2,0,8000100a <IfxVadc_Adc_initChannel+0x14c>
    vadcG->CHASS.U |= (1 << channelIndex);
80000f76:	d9 d2 08 00 	lea %a2,[%a13]8
80000f7a:	19 d2 08 00 	ld.w %d2,[%a13]8
80000f7e:	d7 12 01 2a 	insert %d2,%d2,1,%d10,1
80000f82:	74 22       	st.w [%a2],%d2
    else
    {
        IfxVadc_setBackgroundPriorityChannel(vadcG, channelIndex);
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80000f84:	02 b4       	mov %d4,%d11
80000f86:	60 84       	mov.a %a4,%d8
80000f88:	6d ff fe fd 	call 80000b84 <IfxVadc_disableAccess>

    IfxVadc_setChannelEventNodePointer0(vadcG, config->channelSrcNr, channel->channel);
80000f8c:	19 c4 14 00 	ld.w %d4,[%a12]20
80000f90:	48 02       	ld.w %d2,[%a15]0
    vadcG->CEVNP0.U &= ~(IFX_VADC_G_CEVNP0_CEV0NP_MSK << (channel * 4));
80000f92:	d9 d2 20 40 	lea %a2,[%a13]288
80000f96:	19 d5 20 40 	ld.w %d5,[%a13]288
80000f9a:	06 22       	sh %d2,2
80000f9c:	3b f0 00 30 	mov %d3,15
80000fa0:	0f 23 00 30 	sh %d3,%d3,%d2
80000fa4:	0f 35 e0 30 	andn %d3,%d5,%d3
80000fa8:	74 23       	st.w [%a2],%d3
    vadcG->CEVNP0.U |= (channelSrcNr << (channel * 4));
80000faa:	54 23       	ld.w %d3,[%a2]
80000fac:	0f 24 00 20 	sh %d2,%d4,%d2
80000fb0:	a6 32       	or %d2,%d3
80000fb2:	74 22       	st.w [%a2],%d2

    if (config->channelPriority > 0)
80000fb4:	b9 c2 06 00 	ld.hu %d2,[%a12]6
80000fb8:	df 02 32 80 	jne %d2,0,8000101c <IfxVadc_Adc_initChannel+0x15e>
    else
    {
        /* do nothing */
    }

    if (config->resultRegister < IfxVadc_ChannelResult_8)
80000fbc:	19 c2 24 00 	ld.w %d2,[%a12]36
80000fc0:	ff 82 51 80 	jge.u %d2,8,80001062 <IfxVadc_Adc_initChannel+0x1a4>
    {
        IfxVadc_setResultNodeEventPointer0(vadcG, config->resultSrcNr, config->resultRegister);
80000fc4:	19 c4 10 00 	ld.w %d4,[%a12]16
    vadcG->REVNP0.U &= ~(IFX_VADC_G_REVNP0_REV0NP_MSK << (resultRegister * 4));
80000fc8:	d9 d2 30 40 	lea %a2,[%a13]304
80000fcc:	19 d5 30 40 	ld.w %d5,[%a13]304
80000fd0:	06 22       	sh %d2,2
80000fd2:	3b f0 00 30 	mov %d3,15
80000fd6:	0f 23 00 30 	sh %d3,%d3,%d2
80000fda:	0f 35 e0 30 	andn %d3,%d5,%d3
80000fde:	74 23       	st.w [%a2],%d3
    vadcG->REVNP0.U |= (resultSrcNr << (resultRegister * 4));
80000fe0:	54 23       	ld.w %d3,[%a2]
80000fe2:	0f 24 00 20 	sh %d2,%d4,%d2
80000fe6:	a6 32       	or %d2,%d3
80000fe8:	74 22       	st.w [%a2],%d2
    else
    {
        IfxVadc_setResultNodeEventPointer1(vadcG, config->resultSrcNr, config->resultRegister);
    }

    if (config->resultPriority > 0)
80000fea:	b9 c2 04 00 	ld.hu %d2,[%a12]4
80000fee:	df 02 50 80 	jne %d2,0,8000108e <IfxVadc_Adc_initChannel+0x1d0>
    else
    {
        /* do nothing */
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
80000ff2:	02 94       	mov %d4,%d9
80000ff4:	60 84       	mov.a %a4,%d8
80000ff6:	6d ff c7 fd 	call 80000b84 <IfxVadc_disableAccess>
    /* Software initialization */
    channel->resultreg = config->resultRegister;
80000ffa:	19 c2 24 00 	ld.w %d2,[%a12]36
80000ffe:	68 12       	st.w [%a15]4,%d2
    channel->channel   = config->channelId;
80001000:	19 c2 18 00 	ld.w %d2,[%a12]24
80001004:	68 02       	st.w [%a15]0,%d2

    return Status;
}
80001006:	82 02       	mov %d2,0
80001008:	00 90       	ret 
    vadcG->CHASS.U &= ~(1 << channelIndex);
8000100a:	d9 d2 08 00 	lea %a2,[%a13]8
8000100e:	19 d2 08 00 	ld.w %d2,[%a13]8
80001012:	d7 02 01 2a 	insert %d2,%d2,0,%d10,1
80001016:	74 22       	st.w [%a2],%d2
}
80001018:	1d ff b6 ff 	j 80000f84 <IfxVadc_Adc_initChannel+0xc6>
        volatile Ifx_SRC_SRCR *src = IfxVadc_getSrcAddress(groupIndex, config->channelSrcNr);
8000101c:	19 c5 14 00 	ld.w %d5,[%a12]20
80001020:	02 94       	mov %d4,%d9
80001022:	6d ff 3c fe 	call 80000c9a <IfxVadc_getSrcAddress>
        IfxVadc_clearChannelRequest(vadcG, config->channelId);
80001026:	19 c4 18 00 	ld.w %d4,[%a12]24
    vadcG->CEFCLR.U = 1 << channelId;
8000102a:	82 13       	mov %d3,1
8000102c:	82 12       	mov %d2,1
8000102e:	0f 42 00 20 	sh %d2,%d2,%d4
80001032:	59 d2 10 40 	st.w [%a13]272,%d2
        IfxSrc_init(src, config->channelServProvider, config->channelPriority);
80001036:	19 c5 0c 00 	ld.w %d5,[%a12]12
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
8000103a:	39 c4 06 00 	ld.bu %d4,[%a12]6
8000103e:	54 22       	ld.w %d2,[%a2]
80001040:	37 42 08 20 	insert %d2,%d2,%d4,0,8
80001044:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80001046:	54 22       	ld.w %d2,[%a2]
80001048:	37 52 82 25 	insert %d2,%d2,%d5,11,2
8000104c:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
8000104e:	54 22       	ld.w %d2,[%a2]
80001050:	67 32 19 20 	ins.t %d2,%d2,25,%d3,0
80001054:	74 22       	st.w [%a2],%d2
    src->B.SRE = 1;
80001056:	54 22       	ld.w %d2,[%a2]
80001058:	67 32 0a 20 	ins.t %d2,%d2,10,%d3,0
8000105c:	74 22       	st.w [%a2],%d2
}
8000105e:	1d ff af ff 	j 80000fbc <IfxVadc_Adc_initChannel+0xfe>
        IfxVadc_setResultNodeEventPointer1(vadcG, config->resultSrcNr, config->resultRegister);
80001062:	19 c4 10 00 	ld.w %d4,[%a12]16
    vadcG->REVNP1.U &= ~(IFX_VADC_G_REVNP1_REV8NP_MSK << ((resultRegister - IfxVadc_ChannelResult_8) * 4));
80001066:	d9 d2 34 40 	lea %a2,[%a13]308
8000106a:	19 d5 34 40 	ld.w %d5,[%a13]308
8000106e:	c2 82       	add %d2,-8
80001070:	06 22       	sh %d2,2
80001072:	3b f0 00 30 	mov %d3,15
80001076:	0f 23 00 30 	sh %d3,%d3,%d2
8000107a:	0f 35 e0 30 	andn %d3,%d5,%d3
8000107e:	74 23       	st.w [%a2],%d3
    vadcG->REVNP1.U |= (resultSrcNr << ((resultRegister - IfxVadc_ChannelResult_8) * 4));
80001080:	54 23       	ld.w %d3,[%a2]
80001082:	0f 24 00 20 	sh %d2,%d4,%d2
80001086:	a6 32       	or %d2,%d3
80001088:	74 22       	st.w [%a2],%d2
}
8000108a:	1d ff b0 ff 	j 80000fea <IfxVadc_Adc_initChannel+0x12c>
        volatile Ifx_SRC_SRCR *src = IfxVadc_getSrcAddress(groupIndex, config->resultSrcNr);
8000108e:	19 c5 10 00 	ld.w %d5,[%a12]16
80001092:	02 94       	mov %d4,%d9
80001094:	6d ff 03 fe 	call 80000c9a <IfxVadc_getSrcAddress>
    vadcG->RCR[resultRegister].B.SRGEN = 1;
80001098:	19 c2 24 00 	ld.w %d2,[%a12]36
8000109c:	1b 02 08 20 	addi %d2,%d2,128
800010a0:	06 22       	sh %d2,2
800010a2:	01 d2 00 36 	addsc.a %a3,%a13,%d2,0
800010a6:	54 32       	ld.w %d2,[%a3]
800010a8:	b7 12 81 2f 	insert %d2,%d2,1,31,1
800010ac:	74 32       	st.w [%a3],%d2
    vadcG->REFCLR.U = 0x0000FFFFu;
800010ae:	bb f0 ff 2f 	mov.u %d2,65535
800010b2:	59 d2 14 40 	st.w [%a13]276,%d2
        IfxSrc_init(src, config->resultServProvider, config->resultPriority);
800010b6:	19 c4 08 00 	ld.w %d4,[%a12]8
    src->B.SRPN = priority;
800010ba:	39 c3 04 00 	ld.bu %d3,[%a12]4
800010be:	54 22       	ld.w %d2,[%a2]
800010c0:	37 32 08 20 	insert %d2,%d2,%d3,0,8
800010c4:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
800010c6:	54 22       	ld.w %d2,[%a2]
800010c8:	37 42 82 25 	insert %d2,%d2,%d4,11,2
800010cc:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
800010ce:	54 22       	ld.w %d2,[%a2]
800010d0:	b7 12 81 2c 	insert %d2,%d2,1,25,1
800010d4:	74 22       	st.w [%a2],%d2
    src->B.SRE = 1;
800010d6:	54 22       	ld.w %d2,[%a2]
800010d8:	b7 12 01 25 	insert %d2,%d2,1,10,1
800010dc:	74 22       	st.w [%a2],%d2
}
800010de:	1d ff 8a ff 	j 80000ff2 <IfxVadc_Adc_initChannel+0x134>

800010e2 <IfxVadc_Adc_initChannelConfig>:


void IfxVadc_Adc_initChannelConfig(IfxVadc_Adc_ChannelConfig *config, const IfxVadc_Adc_Group *group)
{
800010e2:	40 ae       	mov.aa %a14,%sp
800010e4:	40 4c       	mov.aa %a12,%a4
800010e6:	80 58       	mov.d %d8,%a5
        .resultServProvider  = IfxSrc_Tos_cpu0,
        .channelPriority     = 0,
        .channelSrcNr        = IfxVadc_SrcNr_group0,
        .channelServProvider = IfxSrc_Tos_cpu0
    };
    *config       = IfxVadc_Adc_defaultChannelConfig;
800010e8:	3b c0 03 50 	mov %d5,60
800010ec:	82 04       	mov %d4,0
800010ee:	6d 00 7f 1d 	call 80004bec <memset>
    config->group = group;
800010f2:	59 c8 38 00 	st.w [%a12]56,%d8
}
800010f6:	00 90       	ret 

800010f8 <IfxVadc_Adc_initGroup>:


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
800010f8:	40 ae       	mov.aa %a14,%sp
800010fa:	40 5c       	mov.aa %a12,%a5
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
800010fc:	d4 52       	ld.a %a2,[%a5]
800010fe:	d4 2d       	ld.a %a13,[%a2]
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];
80001100:	19 58 04 00 	ld.w %d8,[%a5]4
80001104:	8f a8 00 20 	sh %d2,%d8,10
80001108:	1b 02 48 20 	addi %d2,%d2,1152
8000110c:	80 d3       	mov.d %d3,%a13
8000110e:	0b 23 00 90 	add %d9,%d3,%d2

    /* check for write access */
    group->group   = vadcG;
80001112:	59 49 04 00 	st.w [%a4]4,%d9
    group->module  = *config->module;
80001116:	d4 52       	ld.a %a2,[%a5]
80001118:	54 22       	ld.w %d2,[%a2]
8000111a:	74 42       	st.w [%a4],%d2
    IfxVadc_GroupId groupIndex      = config->groupId;
8000111c:	19 5a 04 00 	ld.w %d10,[%a5]4
    group->groupId = groupIndex;
80001120:	59 4a 08 00 	st.w [%a4]8,%d10
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
80001124:	40 d4       	mov.aa %a4,%a13
80001126:	6d ff 9e fd 	call 80000c62 <IfxVadc_getAdcAnalogFrequency>
8000112a:	02 2c       	mov %d12,%d2

    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
8000112c:	1b 0a 01 b0 	addi %d11,%d10,16
80001130:	02 b4       	mov %d4,%d11
80001132:	40 d4       	mov.aa %a4,%a13
80001134:	6d ff 4b fd 	call 80000bca <IfxVadc_enableAccess>

    if (config->arbiter.requestSlotQueueEnabled == TRUE)
80001138:	39 c4 38 10 	ld.bu %d4,[%a12]120
8000113c:	df 14 7c 00 	jeq %d4,1,80001234 <IfxVadc_Adc_initGroup+0x13c>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotQueueEnabled, config->queueRequest.requestSlotPrio, config->queueRequest.requestSlotStartMode, IfxVadc_RequestSource_queue);
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_queue);
80001140:	82 07       	mov %d7,0
80001142:	82 06       	mov %d6,0
80001144:	82 05       	mov %d5,0
80001146:	82 04       	mov %d4,0
80001148:	60 94       	mov.a %a4,%d9
8000114a:	6d ff 50 fe 	call 80000dea <IfxVadc_setArbiterPriority>
    }

    if (config->arbiter.requestSlotScanEnabled == TRUE)
8000114e:	39 c4 39 10 	ld.bu %d4,[%a12]121
80001152:	df 14 7b 00 	jeq %d4,1,80001248 <IfxVadc_Adc_initGroup+0x150>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotScanEnabled, config->scanRequest.requestSlotPrio, config->scanRequest.requestSlotStartMode, IfxVadc_RequestSource_scan);
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_scan);
80001156:	82 17       	mov %d7,1
80001158:	82 06       	mov %d6,0
8000115a:	82 05       	mov %d5,0
8000115c:	82 04       	mov %d4,0
8000115e:	60 94       	mov.a %a4,%d9
80001160:	6d ff 45 fe 	call 80000dea <IfxVadc_setArbiterPriority>
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80001164:	39 c4 3a 10 	ld.bu %d4,[%a12]122
80001168:	df 14 7a 00 	jeq %d4,1,8000125c <IfxVadc_Adc_initGroup+0x164>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotBackgroundScanEnabled, config->backgroundScanRequest.requestSlotPrio, config->backgroundScanRequest.requestSlotStartMode, IfxVadc_RequestSource_background);
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_background);
8000116c:	82 27       	mov %d7,2
8000116e:	82 06       	mov %d6,0
80001170:	82 05       	mov %d5,0
80001172:	82 04       	mov %d4,0
80001174:	60 94       	mov.a %a4,%d9
80001176:	6d ff 3a fe 	call 80000dea <IfxVadc_setArbiterPriority>
    }

    /* master slave configuration */
    if (config->master != groupIndex)
8000117a:	19 c2 08 00 	ld.w %d2,[%a12]8
8000117e:	5f a2 22 00 	jeq %d2,%d10,800011c2 <IfxVadc_Adc_initGroup+0xca>
    return IfxVadc_Adc_masterIndex[slave][master];
80001182:	8f 3a 00 30 	sh %d3,%d10,3
80001186:	91 00 00 28 	movh.a %a2,32768
8000118a:	d9 22 30 d0 	lea %a2,[%a2]880 <80000370 <IfxVadc_Adc_masterIndex>>
8000118e:	80 24       	mov.d %d4,%a2
80001190:	42 34       	add %d4,%d3
80001192:	60 42       	mov.a %a2,%d4
80001194:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80001198:	14 22       	ld.bu %d2,[%a2]
    vadcG->SYNCTR.B.STSEL = (masterIndex % 4);
8000119a:	8f a8 00 30 	sh %d3,%d8,10
8000119e:	01 d3 00 26 	addsc.a %a2,%a13,%d3,0
800011a2:	d9 23 40 30 	lea %a3,[%a2]1216
800011a6:	19 23 40 30 	ld.w %d3,[%a2]1216
800011aa:	37 23 02 30 	insert %d3,%d3,%d2,0,2
800011ae:	74 33       	st.w [%a3],%d3
    vadcG->SYNCTR.U      |= (0x00000008U << (masterIndex % 4));
800011b0:	54 33       	ld.w %d3,[%a3]
800011b2:	8f 32 00 21 	and %d2,%d2,3
800011b6:	3b 80 00 40 	mov %d4,8
800011ba:	0f 24 00 20 	sh %d2,%d4,%d2
800011be:	a6 32       	or %d2,%d3
800011c0:	74 32       	st.w [%a3],%d2
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
800011c2:	8f a8 00 20 	sh %d2,%d8,10
800011c6:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
800011ca:	d9 23 40 20 	lea %a3,[%a2]1152
800011ce:	19 23 40 20 	ld.w %d3,[%a2]1152
800011d2:	8f 33 c0 31 	andn %d3,%d3,3
800011d6:	74 33       	st.w [%a3],%d3

    /* Setup arbiter */
    /* turn off the group during initialization, see UM for sync mode */
    IfxVadc_setAnalogConvertControl(vadcG, IfxVadc_AnalogConverterMode_off);

    IfxVadc_setArbitrationRoundLength(vadcG, config->arbiter.arbiterRoundLength);
800011d8:	19 c2 34 10 	ld.w %d2,[%a12]116
    vadcG->ARBCFG.B.ARBRND = arbiterRoundLength;
800011dc:	d9 23 40 20 	lea %a3,[%a2]1152
800011e0:	19 23 40 20 	ld.w %d3,[%a2]1152
800011e4:	37 23 02 32 	insert %d3,%d3,%d2,4,2
800011e8:	74 33       	st.w [%a3],%d3

    /* Setup queue request if enabled */
    if (config->arbiter.requestSlotQueueEnabled == TRUE)
800011ea:	39 c2 38 10 	ld.bu %d2,[%a12]120
800011ee:	df 12 41 00 	jeq %d2,1,80001270 <IfxVadc_Adc_initGroup+0x178>
    {
        /* do nothing */
    }

    /* Setup scan request if enabled */
    if (config->arbiter.requestSlotScanEnabled == TRUE)
800011f2:	39 c2 39 10 	ld.bu %d2,[%a12]121
800011f6:	df 12 b0 00 	jeq %d2,1,80001356 <IfxVadc_Adc_initGroup+0x25e>
    else
    {
        /* do nothing */
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
800011fa:	39 c2 3a 10 	ld.bu %d2,[%a12]122
800011fe:	df 12 1f 01 	jeq %d2,1,8000143c <IfxVadc_Adc_initGroup+0x344>
    {
        /* do nothing */
    }

    /* turn on group after initialisation, only in master mode */
    IfxVadc_AnalogConverterMode convertMode = (config->master == groupIndex) ? IfxVadc_AnalogConverterMode_normalOperation : IfxVadc_AnalogConverterMode_off;
80001202:	19 c2 08 00 	ld.w %d2,[%a12]8
80001206:	5f a2 76 01 	jeq %d2,%d10,800014f2 <IfxVadc_Adc_initGroup+0x3fa>
8000120a:	82 04       	mov %d4,0
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
8000120c:	8f a8 00 20 	sh %d2,%d8,10
80001210:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80001214:	d9 23 40 20 	lea %a3,[%a2]1152
80001218:	19 23 40 20 	ld.w %d3,[%a2]1152
8000121c:	37 43 02 30 	insert %d3,%d3,%d4,0,2
80001220:	74 33       	st.w [%a3],%d3
    IfxVadc_setAnalogConvertControl(vadcG, convertMode);

    /*  Post Calibration */
    IfxVadc_disablePostCalibration(vadc, groupIndex, config->disablePostCalibration);
80001222:	39 c5 30 10 	ld.bu %d5,[%a12]112
80001226:	02 a4       	mov %d4,%d10
80001228:	40 d4       	mov.aa %a4,%a13
8000122a:	6d ff f3 fc 	call 80000c10 <IfxVadc_disablePostCalibration>

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
8000122e:	82 03       	mov %d3,0
80001230:	1d 00 77 01 	j 8000151e <IfxVadc_Adc_initGroup+0x426>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotQueueEnabled, config->queueRequest.requestSlotPrio, config->queueRequest.requestSlotStartMode, IfxVadc_RequestSource_queue);
80001234:	82 07       	mov %d7,0
80001236:	19 c6 10 10 	ld.w %d6,[%a12]80
8000123a:	19 c5 0c 10 	ld.w %d5,[%a12]76
8000123e:	60 94       	mov.a %a4,%d9
80001240:	6d ff d5 fd 	call 80000dea <IfxVadc_setArbiterPriority>
80001244:	1d ff 85 ff 	j 8000114e <IfxVadc_Adc_initGroup+0x56>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotScanEnabled, config->scanRequest.requestSlotPrio, config->scanRequest.requestSlotStartMode, IfxVadc_RequestSource_scan);
80001248:	82 17       	mov %d7,1
8000124a:	19 c6 34 00 	ld.w %d6,[%a12]52
8000124e:	19 c5 30 00 	ld.w %d5,[%a12]48
80001252:	60 94       	mov.a %a4,%d9
80001254:	6d ff cb fd 	call 80000dea <IfxVadc_setArbiterPriority>
80001258:	1d ff 86 ff 	j 80001164 <IfxVadc_Adc_initGroup+0x6c>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotBackgroundScanEnabled, config->backgroundScanRequest.requestSlotPrio, config->backgroundScanRequest.requestSlotStartMode, IfxVadc_RequestSource_background);
8000125c:	82 27       	mov %d7,2
8000125e:	19 c6 2c 10 	ld.w %d6,[%a12]108
80001262:	19 c5 28 10 	ld.w %d5,[%a12]104
80001266:	60 94       	mov.a %a4,%d9
80001268:	6d ff c1 fd 	call 80000dea <IfxVadc_setArbiterPriority>
8000126c:	1d ff 87 ff 	j 8000117a <IfxVadc_Adc_initGroup+0x82>
        if (queueSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80001270:	19 c2 08 10 	ld.w %d2,[%a12]72
80001274:	df 02 37 00 	jeq %d2,0,800012e2 <IfxVadc_Adc_initGroup+0x1ea>
    vadcG->QMR0.B.ENTR = 1;     /* enable external trigger */
80001278:	8f a8 00 20 	sh %d2,%d8,10
8000127c:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80001280:	d9 23 44 40 	lea %a3,[%a2]1284
80001284:	19 22 44 40 	ld.w %d2,[%a2]1284
80001288:	b7 12 01 21 	insert %d2,%d2,1,2,1
8000128c:	74 32       	st.w [%a3],%d2
            IfxVadc_setQueueSlotTriggerOperatingConfig(vadcG, queueSlot->triggerConfig.triggerMode, queueSlot->triggerConfig.triggerSource);
8000128e:	19 c5 08 10 	ld.w %d5,[%a12]72
80001292:	19 c4 00 10 	ld.w %d4,[%a12]64
    qctrl0.U        = vadcG->QCTRL0.U;
80001296:	d9 23 40 40 	lea %a3,[%a2]1280
8000129a:	19 22 40 40 	ld.w %d2,[%a2]1280
    qctrl0.B.XTWC   = 1;
8000129e:	b7 12 81 27 	insert %d2,%d2,1,15,1
    qctrl0.B.XTMODE = triggerMode;
800012a2:	37 52 82 26 	insert %d2,%d2,%d5,13,2
    qctrl0.B.XTSEL  = triggerSource;
800012a6:	37 42 04 24 	insert %d2,%d2,%d4,8,4
    vadcG->QCTRL0.U = qctrl0.U;
800012aa:	74 32       	st.w [%a3],%d2
            if (queueSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)
800012ac:	19 c2 00 10 	ld.w %d2,[%a12]64
800012b0:	8b f2 20 22 	ne %d2,%d2,15
800012b4:	df 02 22 80 	jne %d2,0,800012f8 <IfxVadc_Adc_initGroup+0x200>
                IfxVadc_setQueueSlotGatingConfig(vadcG, queueSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
800012b8:	19 c3 3c 00 	ld.w %d3,[%a12]60
    qctrl0.U           = vadcG->QCTRL0.U;
800012bc:	8f a8 00 20 	sh %d2,%d8,10
800012c0:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
800012c4:	54 32       	ld.w %d2,[%a3]
    qctrl0.B.GTWC      = 1;
800012c6:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    qctrl0.B.GTSEL     = gatingSource;
800012ca:	37 32 04 28 	insert %d2,%d2,%d3,16,4
    vadcG->QCTRL0.U    = qctrl0.U;
800012ce:	74 32       	st.w [%a3],%d2
    vadcG->QMR0.B.ENGT = gatingMode;
800012d0:	d9 23 44 40 	lea %a3,[%a2]1284
800012d4:	19 22 44 40 	ld.w %d2,[%a2]1284
800012d8:	b7 12 02 20 	insert %d2,%d2,1,0,2
800012dc:	74 32       	st.w [%a3],%d2
}
800012de:	1d 00 0d 00 	j 800012f8 <IfxVadc_Adc_initGroup+0x200>
    vadcG->QMR0.B.ENTR = 0; /* disable external trigger */
800012e2:	8f a8 00 20 	sh %d2,%d8,10
800012e6:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
800012ea:	d9 23 44 40 	lea %a3,[%a2]1284
800012ee:	19 22 44 40 	ld.w %d2,[%a2]1284
800012f2:	8f 42 c0 21 	andn %d2,%d2,4
800012f6:	74 32       	st.w [%a3],%d2
        if ((queueSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
800012f8:	19 c2 00 10 	ld.w %d2,[%a12]64
800012fc:	8b f2 00 22 	eq %d2,%d2,15
80001300:	df 02 1a 80 	jne %d2,0,80001334 <IfxVadc_Adc_initGroup+0x23c>
            IfxVadc_setQueueSlotGatingConfig(vadcG, queueSlot->triggerConfig.gatingSource, queueSlot->triggerConfig.gatingMode);
80001304:	19 c5 3c 00 	ld.w %d5,[%a12]60
80001308:	19 c4 04 10 	ld.w %d4,[%a12]68
    qctrl0.U           = vadcG->QCTRL0.U;
8000130c:	8f a8 00 20 	sh %d2,%d8,10
80001310:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80001314:	d9 23 40 40 	lea %a3,[%a2]1280
80001318:	19 22 40 40 	ld.w %d2,[%a2]1280
    qctrl0.B.GTWC      = 1;
8000131c:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    qctrl0.B.GTSEL     = gatingSource;
80001320:	37 52 04 28 	insert %d2,%d2,%d5,16,4
    vadcG->QCTRL0.U    = qctrl0.U;
80001324:	74 32       	st.w [%a3],%d2
    vadcG->QMR0.B.ENGT = gatingMode;
80001326:	d9 23 44 40 	lea %a3,[%a2]1284
8000132a:	19 22 44 40 	ld.w %d2,[%a2]1284
8000132e:	37 42 02 20 	insert %d2,%d2,%d4,0,2
80001332:	74 32       	st.w [%a3],%d2
        IfxVadc_clearQueue(vadcG, (queueSlot->flushQueueAfterInit) ? 1 : 0);
80001334:	39 c3 38 00 	ld.bu %d3,[%a12]56
80001338:	8b 03 20 32 	ne %d3,%d3,0
    vadcG->QMR0.B.FLUSH = flushQueue;
8000133c:	8f a8 00 20 	sh %d2,%d8,10
80001340:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80001344:	d9 23 44 40 	lea %a3,[%a2]1284
80001348:	19 22 44 40 	ld.w %d2,[%a2]1284
8000134c:	67 32 0a 20 	ins.t %d2,%d2,10,%d3,0
80001350:	74 32       	st.w [%a3],%d2
}
80001352:	1d ff 50 ff 	j 800011f2 <IfxVadc_Adc_initGroup+0xfa>
        if (scanSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80001356:	19 c2 2c 00 	ld.w %d2,[%a12]44
8000135a:	df 02 37 00 	jeq %d2,0,800013c8 <IfxVadc_Adc_initGroup+0x2d0>
    vadcG->ASMR.B.ENTR = 1; /* enable external trigger */
8000135e:	8f a8 00 20 	sh %d2,%d8,10
80001362:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80001366:	d9 23 64 40 	lea %a3,[%a2]1316
8000136a:	19 22 64 40 	ld.w %d2,[%a2]1316
8000136e:	b7 12 01 21 	insert %d2,%d2,1,2,1
80001372:	74 32       	st.w [%a3],%d2
            IfxVadc_setScanSlotTriggerConfig(vadcG, scanSlot->triggerConfig.triggerMode, scanSlot->triggerConfig.triggerSource);
80001374:	19 c5 2c 00 	ld.w %d5,[%a12]44
80001378:	19 c4 24 00 	ld.w %d4,[%a12]36
    asctrl.U        = vadcG->ASCTRL.U;
8000137c:	d9 23 60 40 	lea %a3,[%a2]1312
80001380:	19 22 60 40 	ld.w %d2,[%a2]1312
    asctrl.B.XTWC   = 1;
80001384:	b7 12 81 27 	insert %d2,%d2,1,15,1
    asctrl.B.XTMODE = triggerMode;
80001388:	37 52 82 26 	insert %d2,%d2,%d5,13,2
    asctrl.B.XTSEL  = triggerSource;
8000138c:	37 42 04 24 	insert %d2,%d2,%d4,8,4
    vadcG->ASCTRL.U = asctrl.U;
80001390:	74 32       	st.w [%a3],%d2
            if (scanSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)    /* if last input is used the trigger input selection is extend by Gating inputs */
80001392:	19 c2 24 00 	ld.w %d2,[%a12]36
80001396:	8b f2 20 22 	ne %d2,%d2,15
8000139a:	df 02 22 80 	jne %d2,0,800013de <IfxVadc_Adc_initGroup+0x2e6>
                IfxVadc_setScanSlotGatingConfig(vadcG, scanSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
8000139e:	19 c3 20 00 	ld.w %d3,[%a12]32
    asctrl.U           = vadcG->ASCTRL.U;
800013a2:	8f a8 00 20 	sh %d2,%d8,10
800013a6:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
800013aa:	54 32       	ld.w %d2,[%a3]
    asctrl.B.GTWC      = 1;
800013ac:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    asctrl.B.GTSEL     = gatingSource;
800013b0:	37 32 04 28 	insert %d2,%d2,%d3,16,4
    vadcG->ASCTRL.U    = asctrl.U;
800013b4:	74 32       	st.w [%a3],%d2
    vadcG->ASMR.B.ENGT = gatingMode;
800013b6:	d9 23 64 40 	lea %a3,[%a2]1316
800013ba:	19 22 64 40 	ld.w %d2,[%a2]1316
800013be:	b7 12 02 20 	insert %d2,%d2,1,0,2
800013c2:	74 32       	st.w [%a3],%d2
}
800013c4:	1d 00 0d 00 	j 800013de <IfxVadc_Adc_initGroup+0x2e6>
    vadcG->ASMR.B.ENTR = 0; /* disable external trigger */
800013c8:	8f a8 00 20 	sh %d2,%d8,10
800013cc:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
800013d0:	d9 23 64 40 	lea %a3,[%a2]1316
800013d4:	19 22 64 40 	ld.w %d2,[%a2]1316
800013d8:	8f 42 c0 21 	andn %d2,%d2,4
800013dc:	74 32       	st.w [%a3],%d2
        if ((scanSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
800013de:	19 c2 24 00 	ld.w %d2,[%a12]36
800013e2:	8b f2 00 22 	eq %d2,%d2,15
800013e6:	df 02 1a 80 	jne %d2,0,8000141a <IfxVadc_Adc_initGroup+0x322>
            IfxVadc_setScanSlotGatingConfig(vadcG, scanSlot->triggerConfig.gatingSource, scanSlot->triggerConfig.gatingMode);
800013ea:	19 c5 20 00 	ld.w %d5,[%a12]32
800013ee:	19 c4 28 00 	ld.w %d4,[%a12]40
    asctrl.U           = vadcG->ASCTRL.U;
800013f2:	8f a8 00 20 	sh %d2,%d8,10
800013f6:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
800013fa:	d9 23 60 40 	lea %a3,[%a2]1312
800013fe:	19 22 60 40 	ld.w %d2,[%a2]1312
    asctrl.B.GTWC      = 1;
80001402:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    asctrl.B.GTSEL     = gatingSource;
80001406:	37 52 04 28 	insert %d2,%d2,%d5,16,4
    vadcG->ASCTRL.U    = asctrl.U;
8000140a:	74 32       	st.w [%a3],%d2
    vadcG->ASMR.B.ENGT = gatingMode;
8000140c:	d9 23 64 40 	lea %a3,[%a2]1316
80001410:	19 22 64 40 	ld.w %d2,[%a2]1316
80001414:	37 42 02 20 	insert %d2,%d2,%d4,0,2
80001418:	74 32       	st.w [%a3],%d2
        IfxVadc_setAutoScan(vadcG, scanSlot->autoscanEnabled ? 1 : 0);
8000141a:	39 c3 1c 00 	ld.bu %d3,[%a12]28
8000141e:	8b 03 20 32 	ne %d3,%d3,0
    vadcG->ASMR.B.SCAN = autoscanEnable;
80001422:	8f a8 00 20 	sh %d2,%d8,10
80001426:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
8000142a:	d9 23 64 40 	lea %a3,[%a2]1316
8000142e:	19 22 64 40 	ld.w %d2,[%a2]1316
80001432:	67 32 04 20 	ins.t %d2,%d2,4,%d3,0
80001436:	74 32       	st.w [%a3],%d2
}
80001438:	1d ff e1 fe 	j 800011fa <IfxVadc_Adc_initGroup+0x102>
        if (backgroundScanSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
8000143c:	19 c2 24 10 	ld.w %d2,[%a12]100
80001440:	df 02 1e 00 	jeq %d2,0,8000147c <IfxVadc_Adc_initGroup+0x384>
    vadc->BRSMR.B.ENTR = 1; /* enable external trigger */
80001444:	d9 d2 04 80 	lea %a2,[%a13]516
80001448:	19 d2 04 80 	ld.w %d2,[%a13]516
8000144c:	b7 12 01 21 	insert %d2,%d2,1,2,1
80001450:	74 22       	st.w [%a2],%d2
            IfxVadc_setBackgroundScanSlotTriggerConfig(vadc, backgroundScanSlot->triggerConfig.triggerMode, backgroundScanSlot->triggerConfig.triggerSource);
80001452:	19 c5 24 10 	ld.w %d5,[%a12]100
80001456:	19 c4 1c 10 	ld.w %d4,[%a12]92
    brsctrl.U        = vadc->BRSCTRL.U;
8000145a:	d9 d2 00 80 	lea %a2,[%a13]512
8000145e:	19 d2 00 80 	ld.w %d2,[%a13]512
    brsctrl.B.XTWC   = 1;
80001462:	b7 12 81 27 	insert %d2,%d2,1,15,1
    brsctrl.B.XTMODE = triggerMode;
80001466:	37 52 82 26 	insert %d2,%d2,%d5,13,2
    brsctrl.B.XTSEL  = triggerSource;
8000146a:	37 42 04 24 	insert %d2,%d2,%d4,8,4
    vadc->BRSCTRL.U  = brsctrl.U;
8000146e:	74 22       	st.w [%a2],%d2
            if (backgroundScanSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)    /* if last input is used the trigger input selection is extend by Gating inputs */
80001470:	19 c2 1c 10 	ld.w %d2,[%a12]92
80001474:	8b f2 20 22 	ne %d2,%d2,15
80001478:	df 02 29 00 	jeq %d2,0,800014ca <IfxVadc_Adc_initGroup+0x3d2>
        if ((backgroundScanSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
8000147c:	19 c2 1c 10 	ld.w %d2,[%a12]92
80001480:	8b f2 00 22 	eq %d2,%d2,15
80001484:	df 02 16 80 	jne %d2,0,800014b0 <IfxVadc_Adc_initGroup+0x3b8>
            IfxVadc_setBackgroundScanSlotGatingConfig(vadc, backgroundScanSlot->triggerConfig.gatingSource, backgroundScanSlot->triggerConfig.gatingMode);
80001488:	19 c5 18 10 	ld.w %d5,[%a12]88
8000148c:	19 c4 20 10 	ld.w %d4,[%a12]96
    brsctrl.U          = vadc->BRSCTRL.U;
80001490:	d9 d2 00 80 	lea %a2,[%a13]512
80001494:	19 d2 00 80 	ld.w %d2,[%a13]512
    brsctrl.B.GTWC     = 1;
80001498:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    brsctrl.B.GTSEL    = gatingSource;
8000149c:	37 52 04 28 	insert %d2,%d2,%d5,16,4
    vadc->BRSCTRL.U    = brsctrl.U;
800014a0:	74 22       	st.w [%a2],%d2
    vadc->BRSMR.B.ENGT = gatingMode;
800014a2:	d9 d2 04 80 	lea %a2,[%a13]516
800014a6:	19 d2 04 80 	ld.w %d2,[%a13]516
800014aa:	37 42 02 20 	insert %d2,%d2,%d4,0,2
800014ae:	74 22       	st.w [%a2],%d2
        IfxVadc_setAutoBackgroundScan(vadc, backgroundScanSlot->autoBackgroundScanEnabled ? 1 : 0);
800014b0:	39 c3 14 10 	ld.bu %d3,[%a12]84
800014b4:	8b 03 20 32 	ne %d3,%d3,0
    vadc->BRSMR.B.SCAN = autoBackgroundScanEnable;
800014b8:	d9 d2 04 80 	lea %a2,[%a13]516
800014bc:	19 d2 04 80 	ld.w %d2,[%a13]516
800014c0:	67 32 04 20 	ins.t %d2,%d2,4,%d3,0
800014c4:	74 22       	st.w [%a2],%d2
}
800014c6:	1d ff 9e fe 	j 80001202 <IfxVadc_Adc_initGroup+0x10a>
                IfxVadc_setBackgroundScanSlotGatingConfig(vadc, backgroundScanSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
800014ca:	19 c3 18 10 	ld.w %d3,[%a12]88
    brsctrl.U          = vadc->BRSCTRL.U;
800014ce:	d9 d2 00 80 	lea %a2,[%a13]512
800014d2:	19 d2 00 80 	ld.w %d2,[%a13]512
    brsctrl.B.GTWC     = 1;
800014d6:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    brsctrl.B.GTSEL    = gatingSource;
800014da:	37 32 04 28 	insert %d2,%d2,%d3,16,4
    vadc->BRSCTRL.U    = brsctrl.U;
800014de:	74 22       	st.w [%a2],%d2
    vadc->BRSMR.B.ENGT = gatingMode;
800014e0:	d9 d2 04 80 	lea %a2,[%a13]516
800014e4:	19 d2 04 80 	ld.w %d2,[%a13]516
800014e8:	b7 12 02 20 	insert %d2,%d2,1,0,2
800014ec:	74 22       	st.w [%a2],%d2
}
800014ee:	1d ff c7 ff 	j 8000147c <IfxVadc_Adc_initGroup+0x384>
    IfxVadc_AnalogConverterMode convertMode = (config->master == groupIndex) ? IfxVadc_AnalogConverterMode_normalOperation : IfxVadc_AnalogConverterMode_off;
800014f2:	82 34       	mov %d4,3
800014f4:	1d ff 8c fe 	j 8000120c <IfxVadc_Adc_initGroup+0x114>
800014f8:	3b f0 0f 50 	mov %d5,255
800014fc:	0b 54 90 51 	min.u %d5,%d4,%d5
    vadcG->ICLASS[inputClassNum].B.STCS = IfxVadc_calculateSampleTime(analogFrequency, sampleTime);
80001500:	8f 88 00 20 	sh %d2,%d8,8
80001504:	42 62       	add %d2,%d6
80001506:	1b 82 12 40 	addi %d4,%d2,296
8000150a:	06 24       	sh %d4,2
8000150c:	01 d4 00 26 	addsc.a %a2,%a13,%d4,0
80001510:	54 24       	ld.w %d4,[%a2]
80001512:	37 54 05 40 	insert %d4,%d4,%d5,0,5
80001516:	74 24       	st.w [%a2],%d4
    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
80001518:	c2 13       	add %d3,1
8000151a:	8f f3 0f 31 	and %d3,%d3,255
8000151e:	ff 23 29 80 	jge.u %d3,2,80001570 <IfxVadc_Adc_initGroup+0x478>
    {
        /* configure Group input class registers */
        IfxVadc_setGroupResolution(vadcG, inputClassNum, config->inputClass[inputClassNum].resolution);
80001522:	02 36       	mov %d6,%d3
80001524:	1b 23 00 40 	addi %d4,%d3,2
80001528:	06 34       	sh %d4,3
8000152a:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
8000152e:	54 25       	ld.w %d5,[%a2]
    vadcG->ICLASS[inputClassNum].B.CMS = resolution;
80001530:	8f 88 00 20 	sh %d2,%d8,8
80001534:	42 32       	add %d2,%d3
80001536:	1b 82 12 40 	addi %d4,%d2,296
8000153a:	06 24       	sh %d4,2
8000153c:	01 d4 00 26 	addsc.a %a2,%a13,%d4,0
80001540:	54 24       	ld.w %d4,[%a2]
80001542:	37 54 03 44 	insert %d4,%d4,%d5,8,3
80001546:	74 24       	st.w [%a2],%d4
        /* Calculate Sample time ticks */
        IfxVadc_setGroupSampleTime(vadcG, inputClassNum, analogFrequency, config->inputClass[inputClassNum].sampleTime);
80001548:	8f 33 00 40 	sh %d4,%d3,3
8000154c:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
80001550:	19 24 0c 00 	ld.w %d4,[%a2]12
    ticks = (uint32)(sampleTime * analogFrequency) - 2;
80001554:	4b c4 41 40 	mul.f %d4,%d4,%d12
80001558:	4b 04 71 41 	ftouz %d4,%d4
8000155c:	c2 e4       	add %d4,-2
    if (ticks > 31)
8000155e:	8b 04 62 52 	lt.u %d5,%d4,32
80001562:	df 05 cb ff 	jne %d5,0,800014f8 <IfxVadc_Adc_initGroup+0x400>
        ticks = (ticks / 16) + 15;
80001566:	06 c4       	sh %d4,-4
80001568:	1b f4 00 40 	addi %d4,%d4,15
8000156c:	1d ff c6 ff 	j 800014f8 <IfxVadc_Adc_initGroup+0x400>
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80001570:	02 b4       	mov %d4,%d11
80001572:	40 d4       	mov.aa %a4,%a13
80001574:	6d ff 08 fb 	call 80000b84 <IfxVadc_disableAccess>

    return status;
}
80001578:	82 02       	mov %d2,0
8000157a:	00 90       	ret 

8000157c <IfxVadc_Adc_initGroupConfig>:


void IfxVadc_Adc_initGroupConfig(IfxVadc_Adc_GroupConfig *config, IfxVadc_Adc *vadc)
{
8000157c:	40 ae       	mov.aa %a14,%sp
8000157e:	40 4c       	mov.aa %a12,%a4
80001580:	80 58       	mov.d %d8,%a5
        .inputClass[0].sampleTime = 1.0e-6,                           /* Set sample time to 1us */
        .inputClass[1].resolution = IfxVadc_ChannelResolution_12bit,
        .inputClass[1].sampleTime = 1.0e-6,                           /* Set sample time to 1us */
    };

    *config                        = IfxVadc_Adc_defaultGroupConfig;
80001582:	3b c0 07 50 	mov %d5,124
80001586:	82 04       	mov %d4,0
80001588:	6d 00 32 1b 	call 80004bec <memset>
8000158c:	7b 60 58 23 	movh %d2,13702
80001590:	1b d2 7b 23 	addi %d2,%d2,14269
80001594:	59 c2 0c 00 	st.w [%a12]12,%d2
80001598:	59 c2 14 00 	st.w [%a12]20,%d2
8000159c:	82 12       	mov %d2,1
8000159e:	59 c2 30 00 	st.w [%a12]48,%d2
800015a2:	e9 c2 38 00 	st.b [%a12]56,%d2
800015a6:	59 c2 0c 10 	st.w [%a12]76,%d2
800015aa:	59 c2 28 10 	st.w [%a12]104,%d2
    config->groupId                = IfxVadc_GroupId_0;
    config->module                 = vadc;
800015ae:	74 c8       	st.w [%a12],%d8
    config->master                 = config->groupId;
    config->disablePostCalibration = FALSE;
}
800015b0:	00 90       	ret 

800015b2 <IfxVadc_Adc_initModule>:


IfxVadc_Status IfxVadc_Adc_initModule(IfxVadc_Adc *vadc, const IfxVadc_Adc_Config *config)
{
800015b2:	40 ae       	mov.aa %a14,%sp
800015b4:	40 5d       	mov.aa %a13,%a5
    IfxVadc_Status status  = IfxVadc_Status_noError;
    Ifx_VADC      *vadcSFR = config->vadc;
800015b6:	d4 5c       	ld.a %a12,[%a5]
    vadc->vadc = vadcSFR;
800015b8:	f4 4c       	st.a [%a4],%a12
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800015ba:	6d 00 0f 06 	call 800021d8 <IfxScuWdt_getCpuWatchdogPassword>
800015be:	02 28       	mov %d8,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
800015c0:	02 24       	mov %d4,%d2
800015c2:	6d 00 a2 04 	call 80001f06 <IfxScuWdt_clearCpuEndinit>
    vadc->CLC.U = 0x00000000;
800015c6:	82 02       	mov %d2,0
800015c8:	74 c2       	st.w [%a12],%d2
    IfxScuWdt_setCpuEndinit(passwd);
800015ca:	02 84       	mov %d4,%d8
800015cc:	6d 00 23 06 	call 80002212 <IfxScuWdt_setCpuEndinit>
    float32        analogFrequency;
    uint8          inputClassNum, groupNum;

    /* Enable VADC kernel clock */
    IfxVadc_enableModule(vadcSFR);
    IfxVadc_selectPowerSupplyVoltage(vadcSFR, config->supplyVoltage);
800015d0:	19 d4 24 00 	ld.w %d4,[%a13]36
800015d4:	40 c4       	mov.aa %a4,%a12
800015d6:	6d ff f5 fb 	call 80000dc0 <IfxVadc_selectPowerSupplyVoltage>

    /* Set Analog Frequency */
    if (IfxVadc_initializeFAdcI(vadcSFR, config->analogFrequency) == 0)
800015da:	19 d4 18 00 	ld.w %d4,[%a13]24
800015de:	4b 04 71 41 	ftouz %d4,%d4
800015e2:	40 c4       	mov.aa %a4,%a12
800015e4:	6d ff b4 fb 	call 80000d4c <IfxVadc_initializeFAdcI>
800015e8:	df 02 04 80 	jne %d2,0,800015f0 <IfxVadc_Adc_initModule+0x3e>
    {
        return IfxVadc_Status_notInitialised;
800015ec:	82 12       	mov %d2,1
        // execute calibration
        IfxVadc_startupCalibration(vadcSFR);
    }

    return status;
}
800015ee:	00 90       	ret 
    IfxVadc_initializeFAdcD(vadcSFR, config->digitalFrequency);
800015f0:	19 d4 14 00 	ld.w %d4,[%a13]20
800015f4:	4b 04 71 41 	ftouz %d4,%d4
800015f8:	40 c4       	mov.aa %a4,%a12
800015fa:	6d ff 92 fb 	call 80000d1e <IfxVadc_initializeFAdcD>
    analogFrequency = IfxVadc_getAdcAnalogFrequency(vadcSFR);
800015fe:	40 c4       	mov.aa %a4,%a12
80001600:	6d ff 31 fb 	call 80000c62 <IfxVadc_getAdcAnalogFrequency>
    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_GLOBAL_INPUTCLASSES; inputClassNum++)
80001604:	82 03       	mov %d3,0
80001606:	1d 00 12 00 	j 8000162a <IfxVadc_Adc_initModule+0x78>
8000160a:	3b f0 0f 50 	mov %d5,255
8000160e:	0b 54 90 51 	min.u %d5,%d4,%d5
    vadc->GLOBICLASS[inputClassNum].B.STCS = IfxVadc_calculateSampleTime(analogFrequency, sampleTime);
80001612:	1b 86 02 40 	addi %d4,%d6,40
80001616:	06 24       	sh %d4,2
80001618:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
8000161c:	54 24       	ld.w %d4,[%a2]
8000161e:	37 54 05 40 	insert %d4,%d4,%d5,0,5
80001622:	74 24       	st.w [%a2],%d4
80001624:	c2 13       	add %d3,1
80001626:	8f f3 0f 31 	and %d3,%d3,255
8000162a:	ff 23 26 80 	jge.u %d3,2,80001676 <IfxVadc_Adc_initModule+0xc4>
        IfxVadc_setGlobalResolution(vadcSFR, inputClassNum, config->globalInputClass[inputClassNum].resolution);
8000162e:	02 36       	mov %d6,%d3
80001630:	1b 13 00 40 	addi %d4,%d3,1
80001634:	06 34       	sh %d4,3
80001636:	01 d4 00 26 	addsc.a %a2,%a13,%d4,0
8000163a:	54 25       	ld.w %d5,[%a2]
    vadc->GLOBICLASS[inputClassNum].B.CMS = resolution;
8000163c:	1b 83 02 40 	addi %d4,%d3,40
80001640:	06 24       	sh %d4,2
80001642:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
80001646:	54 24       	ld.w %d4,[%a2]
80001648:	37 54 03 44 	insert %d4,%d4,%d5,8,3
8000164c:	74 24       	st.w [%a2],%d4
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
8000164e:	8f 33 00 40 	sh %d4,%d3,3
80001652:	01 d4 00 26 	addsc.a %a2,%a13,%d4,0
80001656:	19 24 04 00 	ld.w %d4,[%a2]4
    ticks = (uint32)(sampleTime * analogFrequency) - 2;
8000165a:	4b 24 41 40 	mul.f %d4,%d4,%d2
8000165e:	4b 04 71 41 	ftouz %d4,%d4
80001662:	c2 e4       	add %d4,-2
    if (ticks > 31)
80001664:	8b 04 62 52 	lt.u %d5,%d4,32
80001668:	df 05 d1 ff 	jne %d5,0,8000160a <IfxVadc_Adc_initModule+0x58>
        ticks = (ticks / 16) + 15;
8000166c:	06 c4       	sh %d4,-4
8000166e:	1b f4 00 40 	addi %d4,%d4,15
80001672:	1d ff cc ff 	j 8000160a <IfxVadc_Adc_initModule+0x58>
    if (config->startupCalibration == TRUE)
80001676:	39 d2 20 00 	ld.bu %d2,[%a13]32
8000167a:	df 12 23 00 	jeq %d2,1,800016c0 <IfxVadc_Adc_initModule+0x10e>
    return status;
8000167e:	82 02       	mov %d2,0
80001680:	00 90       	ret 
            IfxVadc_enableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80001682:	1b 08 01 90 	addi %d9,%d8,16
80001686:	02 94       	mov %d4,%d9
80001688:	40 c4       	mov.aa %a4,%a12
8000168a:	6d ff a0 fa 	call 80000bca <IfxVadc_enableAccess>
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
8000168e:	8f a8 00 20 	sh %d2,%d8,10
80001692:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
80001696:	d9 23 40 20 	lea %a3,[%a2]1152
8000169a:	19 22 40 20 	ld.w %d2,[%a2]1152
8000169e:	b7 32 02 20 	insert %d2,%d2,3,0,2
800016a2:	74 32       	st.w [%a3],%d2
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
800016a4:	02 94       	mov %d4,%d9
800016a6:	40 c4       	mov.aa %a4,%a12
800016a8:	6d ff 6e fa 	call 80000b84 <IfxVadc_disableAccess>
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
800016ac:	c2 18       	add %d8,1
800016ae:	8f f8 0f 81 	and %d8,%d8,255
800016b2:	bf 88 e8 ff 	jlt.u %d8,8,80001682 <IfxVadc_Adc_initModule+0xd0>
        IfxVadc_startupCalibration(vadcSFR);
800016b6:	40 c4       	mov.aa %a4,%a12
800016b8:	6d ff da fb 	call 80000e6c <IfxVadc_startupCalibration>
    return status;
800016bc:	82 02       	mov %d2,0
800016be:	00 90       	ret 
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
800016c0:	82 08       	mov %d8,0
800016c2:	1d ff f8 ff 	j 800016b2 <IfxVadc_Adc_initModule+0x100>

800016c6 <IfxVadc_Adc_initModuleConfig>:


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
800016c6:	40 ae       	mov.aa %a14,%sp
800016c8:	40 4c       	mov.aa %a12,%a4
800016ca:	40 54       	mov.aa %a4,%a5
    config->vadc                           = vadc;
800016cc:	f4 c5       	st.a [%a12],%a5
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
800016ce:	7b 90 b9 24 	movh %d2,19353
800016d2:	1b 02 68 29 	addi %d2,%d2,-27008
800016d6:	59 c2 18 00 	st.w [%a12]24,%d2

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
800016da:	6d ff d2 fa 	call 80000c7e <IfxVadc_getAdcDigitalFrequency>
800016de:	59 c2 14 00 	st.w [%a12]20,%d2
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
800016e2:	6d 00 29 02 	call 80001b34 <IfxScuCcu_getSpbFrequency>
800016e6:	59 c2 1c 00 	st.w [%a12]28,%d2
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
800016ea:	82 02       	mov %d2,0
800016ec:	59 c2 08 00 	st.w [%a12]8,%d2
    config->globalInputClass[0].sampleTime = 1.0e-6;
800016f0:	7b 60 58 33 	movh %d3,13702
800016f4:	1b d3 7b 33 	addi %d3,%d3,14269
800016f8:	59 c3 04 00 	st.w [%a12]4,%d3
    config->globalInputClass[1].resolution = IfxVadc_ChannelResolution_12bit;
800016fc:	59 c2 10 00 	st.w [%a12]16,%d2
    config->globalInputClass[1].sampleTime = 1.0e-6;
80001700:	59 c3 0c 00 	st.w [%a12]12,%d3
    config->startupCalibration             = FALSE;
80001704:	e9 c2 20 00 	st.b [%a12]32,%d2
    config->supplyVoltage                  = IfxVadc_LowSupplyVoltageSelect_5V;
80001708:	59 c2 24 00 	st.w [%a12]36,%d2
}
8000170c:	00 90       	ret 

8000170e <IfxStm_clearCompareFlag>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxStm_clearCompareFlag(Ifx_STM *stm, IfxStm_Comparator comparator)
{
8000170e:	40 ae       	mov.aa %a14,%sp
    if (comparator == IfxStm_Comparator_0)
80001710:	df 04 0a 80 	jne %d4,0,80001724 <IfxStm_clearCompareFlag+0x16>
    {
        stm->ISCR.B.CMP0IRR = 1U;
80001714:	d9 42 00 10 	lea %a2,[%a4]64
80001718:	19 42 00 10 	ld.w %d2,[%a4]64
8000171c:	b7 12 01 20 	insert %d2,%d2,1,0,1
80001720:	74 22       	st.w [%a2],%d2
80001722:	00 90       	ret 
    }
    else if (comparator == IfxStm_Comparator_1)
80001724:	df 14 03 00 	jeq %d4,1,8000172a <IfxStm_clearCompareFlag+0x1c>
    {
        stm->ISCR.B.CMP1IRR = 1U;
    }
}
80001728:	00 90       	ret 
        stm->ISCR.B.CMP1IRR = 1U;
8000172a:	d9 42 00 10 	lea %a2,[%a4]64
8000172e:	19 42 00 10 	ld.w %d2,[%a4]64
80001732:	b7 12 01 21 	insert %d2,%d2,1,2,1
80001736:	74 22       	st.w [%a2],%d2
}
80001738:	1d ff f8 ff 	j 80001728 <IfxStm_clearCompareFlag+0x1a>

8000173c <IfxStm_enableComparatorInterrupt>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxStm_enableComparatorInterrupt(Ifx_STM *stm, IfxStm_Comparator comparator)
{
8000173c:	40 ae       	mov.aa %a14,%sp
    if (comparator == IfxStm_Comparator_0)
8000173e:	df 04 0a 80 	jne %d4,0,80001752 <IfxStm_enableComparatorInterrupt+0x16>
    {
        stm->ICR.B.CMP0EN = 1U;
80001742:	d9 42 3c 00 	lea %a2,[%a4]60
80001746:	19 42 3c 00 	ld.w %d2,[%a4]60
8000174a:	b7 12 01 20 	insert %d2,%d2,1,0,1
8000174e:	74 22       	st.w [%a2],%d2
80001750:	00 90       	ret 
    }
    else if (comparator == IfxStm_Comparator_1)
80001752:	df 14 03 00 	jeq %d4,1,80001758 <IfxStm_enableComparatorInterrupt+0x1c>
    {
        stm->ICR.B.CMP1EN = 1U;
    }
}
80001756:	00 90       	ret 
        stm->ICR.B.CMP1EN = 1U;
80001758:	d9 42 3c 00 	lea %a2,[%a4]60
8000175c:	19 42 3c 00 	ld.w %d2,[%a4]60
80001760:	b7 12 01 22 	insert %d2,%d2,1,4,1
80001764:	74 22       	st.w [%a2],%d2
}
80001766:	1d ff f8 ff 	j 80001756 <IfxStm_enableComparatorInterrupt+0x1a>

8000176a <IfxStm_enableOcdsSuspend>:


void IfxStm_enableOcdsSuspend(Ifx_STM *stm)
{
8000176a:	40 ae       	mov.aa %a14,%sp
    Ifx_STM_OCS ocs = stm->OCS;
8000176c:	d9 42 28 30 	lea %a2,[%a4]232
80001770:	19 42 28 30 	ld.w %d2,[%a4]232

    /* Only if OCDS is enabled write into the OCS register */
    if (MODULE_CBS.OSTATE.B.OEN == 1U)
80001774:	85 f3 40 20 	ld.w %d3,f0000480 <_SMALL_DATA4_+0x5fff8480>
80001778:	6f 03 03 80 	jnz.t %d3,0,8000177e <IfxStm_enableOcdsSuspend+0x14>
        ocs.B.SUS_P      = 1;
        ocs.B.SUS        = 2;
        stm->OCS         = ocs;
        stm->OCS.B.SUS_P = 0;
    }
}
8000177c:	00 90       	ret 
        ocs.B.SUS_P      = 1;
8000177e:	b7 12 01 2e 	insert %d2,%d2,1,28,1
        ocs.B.SUS        = 2;
80001782:	b7 22 04 2c 	insert %d2,%d2,2,24,4
        stm->OCS         = ocs;
80001786:	74 22       	st.w [%a2],%d2
        stm->OCS.B.SUS_P = 0;
80001788:	54 22       	ld.w %d2,[%a2]
8000178a:	b7 02 01 2e 	insert %d2,%d2,0,28,1
8000178e:	74 22       	st.w [%a2],%d2
}
80001790:	1d ff f6 ff 	j 8000177c <IfxStm_enableOcdsSuspend+0x12>

80001794 <IfxStm_getIndex>:
    return module;
}


IfxStm_Index IfxStm_getIndex(Ifx_STM *stm)
{
80001794:	40 ae       	mov.aa %a14,%sp
    uint32       index;
    IfxStm_Index result;

    result = IfxStm_Index_none;

    for (index = 0; index < IFXSTM_NUM_MODULES; index++)
80001796:	82 02       	mov %d2,0
80001798:	1d 00 03 00 	j 8000179e <IfxStm_getIndex+0xa>
8000179c:	c2 12       	add %d2,1
8000179e:	ff 32 18 80 	jge.u %d2,3,800017ce <IfxStm_getIndex+0x3a>
    {
        if (IfxStm_cfg_indexMap[index].module == stm)
800017a2:	8f 32 00 30 	sh %d3,%d2,3
800017a6:	91 00 00 28 	movh.a %a2,32768
800017aa:	d9 22 38 a0 	lea %a2,[%a2]696 <800002b8 <IfxStm_cfg_indexMap>>
800017ae:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
800017b2:	54 23       	ld.w %d3,[%a2]
800017b4:	80 44       	mov.d %d4,%a4
800017b6:	5f 43 f3 ff 	jne %d3,%d4,8000179c <IfxStm_getIndex+0x8>
        {
            result = (IfxStm_Index)IfxStm_cfg_indexMap[index].index;
800017ba:	06 32       	sh %d2,3
800017bc:	91 00 00 28 	movh.a %a2,32768
800017c0:	d9 22 38 a0 	lea %a2,[%a2]696 <800002b8 <IfxStm_cfg_indexMap>>
800017c4:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800017c8:	19 22 04 00 	ld.w %d2,[%a2]4
            break;
800017cc:	00 90       	ret 
    result = IfxStm_Index_none;
800017ce:	82 f2       	mov %d2,-1
        }
    }

    return result;
}
800017d0:	00 90       	ret 

800017d2 <IfxStm_initCompare>:
    return comparator == IfxStm_Comparator_0 ? &MODULE_SRC.STM.STM[index].SR0 : &MODULE_SRC.STM.STM[index].SR1;
}


boolean IfxStm_initCompare(Ifx_STM *stm, const IfxStm_CompareConfig *config)
{
800017d2:	40 ae       	mov.aa %a14,%sp
800017d4:	40 4d       	mov.aa %a13,%a4
800017d6:	40 5c       	mov.aa %a12,%a5
    sint32        index;
    boolean       result;
    Ifx_STM_CMCON comcon = stm->CMCON;
800017d8:	19 42 38 00 	ld.w %d2,[%a4]56
    Ifx_STM_ICR   icr    = stm->ICR;
800017dc:	19 43 3c 00 	ld.w %d3,[%a4]60

    if (config->comparator == 0)
800017e0:	54 54       	ld.w %d4,[%a5]
800017e2:	df 04 82 80 	jne %d4,0,800018e6 <IfxStm_initCompare+0x114>
    {
        comcon.B.MSIZE0  = config->compareSize;
800017e6:	19 54 0c 00 	ld.w %d4,[%a5]12
800017ea:	37 42 05 20 	insert %d2,%d2,%d4,0,5
        comcon.B.MSTART0 = config->compareOffset;
800017ee:	19 54 08 00 	ld.w %d4,[%a5]8
800017f2:	37 42 05 24 	insert %d2,%d2,%d4,8,5
        icr.B.CMP0OS     = config->comparatorInterrupt;
800017f6:	19 54 04 00 	ld.w %d4,[%a5]4
800017fa:	67 43 02 30 	ins.t %d3,%d3,2,%d4,0
        result           = TRUE;
800017fe:	82 18       	mov %d8,1
    {
        /*Invalid value */
        result = FALSE;
    }

    stm->ICR.U   = icr.U;
80001800:	59 d3 3c 00 	st.w [%a13]60,%d3
    stm->CMCON.U = comcon.U;
80001804:	59 d2 38 00 	st.w [%a13]56,%d2

    /* configure interrupt */
    index = IfxStm_getIndex(stm);
80001808:	40 d4       	mov.aa %a4,%a13
8000180a:	6d ff c5 ff 	call 80001794 <IfxStm_getIndex>

    if (config->triggerPriority > 0)
8000180e:	b9 c3 14 00 	ld.hu %d3,[%a12]20
80001812:	df 03 20 00 	jeq %d3,0,80001852 <IfxStm_initCompare+0x80>
    {
        volatile Ifx_SRC_SRCR *srcr;

        if (config->comparatorInterrupt == IfxStm_ComparatorInterrupt_ir0)
80001816:	19 c4 04 00 	ld.w %d4,[%a12]4
8000181a:	df 04 7a 80 	jne %d4,0,8000190e <IfxStm_initCompare+0x13c>
        {
            srcr = &(MODULE_SRC.STM.STM[index].SR0);
8000181e:	06 32       	sh %d2,3
80001820:	7b 40 00 4f 	movh %d4,61444
80001824:	1b 04 49 48 	addi %d4,%d4,-31600
80001828:	60 42       	mov.a %a2,%d4
8000182a:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
        else
        {
            srcr = &(MODULE_SRC.STM.STM[index].SR1);
        }

        IfxSrc_init(srcr, config->typeOfService, config->triggerPriority);
8000182e:	19 c4 18 00 	ld.w %d4,[%a12]24
    src->B.SRPN = priority;
80001832:	54 22       	ld.w %d2,[%a2]
80001834:	37 32 08 20 	insert %d2,%d2,%d3,0,8
80001838:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
8000183a:	54 22       	ld.w %d2,[%a2]
8000183c:	37 42 82 25 	insert %d2,%d2,%d4,11,2
80001840:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
80001842:	54 22       	ld.w %d2,[%a2]
80001844:	b7 12 81 2c 	insert %d2,%d2,1,25,1
80001848:	74 22       	st.w [%a2],%d2
    src->B.SRE = 1;
8000184a:	54 22       	ld.w %d2,[%a2]
8000184c:	b7 12 01 25 	insert %d2,%d2,1,10,1
80001850:	74 22       	st.w [%a2],%d2
        IfxSrc_enable(srcr);
    }

    /*Configure the comparator ticks to current value to avoid any wrong triggering*/
    stm->CMP[config->comparator].U = IfxStm_getOffsetTimer(stm, (uint8)config->compareOffset);
80001852:	39 c5 08 00 	ld.bu %d5,[%a12]8

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80001856:	19 d6 10 00 	ld.w %d6,[%a13]16
    result |= ((uint64)stm->CAP.U) << 32;
8000185a:	19 d2 2c 00 	ld.w %d2,[%a13]44
8000185e:	8f 06 40 41 	or %d4,%d6,0
80001862:	02 23       	mov %d3,%d2
{
    uint64 now;

    now = IfxStm_get(stm);

    return (uint32)(now >> offset);
80001864:	8b 05 82 22 	ge %d2,%d5,32
80001868:	2b 34 50 42 	seln %d4,%d2,%d4,%d3
8000186c:	ab 03 a0 32 	seln %d3,%d2,%d3,0
80001870:	8f f5 01 21 	and %d2,%d5,31
80001874:	8b 02 02 51 	rsub %d5,%d2,32
80001878:	17 43 80 35 	dextr %d3,%d3,%d4,%d5
8000187c:	2b 43 40 32 	sel %d3,%d2,%d3,%d4
80001880:	54 c2       	ld.w %d2,[%a12]
80001882:	1b c2 00 20 	addi %d2,%d2,12
80001886:	06 22       	sh %d2,2
80001888:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
8000188c:	74 23       	st.w [%a2],%d3

    /* clear the interrupt flag of the selected comparator before enabling the interrupt */
    /* this is to avaoid the unneccesary interrupt for the compare match of reset values of the registers */
    IfxStm_clearCompareFlag(stm, config->comparator);
8000188e:	54 c4       	ld.w %d4,[%a12]
80001890:	40 d4       	mov.aa %a4,%a13
80001892:	6d ff 3e ff 	call 8000170e <IfxStm_clearCompareFlag>
    /* enable the interrupt for the selected comparator */
    IfxStm_enableComparatorInterrupt(stm, config->comparator);
80001896:	54 c4       	ld.w %d4,[%a12]
80001898:	40 d4       	mov.aa %a4,%a13
8000189a:	6d ff 51 ff 	call 8000173c <IfxStm_enableComparatorInterrupt>

    /*Configure the comparator ticks */
    stm->CMP[config->comparator].U = IfxStm_getOffsetTimer(stm, (uint8)config->compareOffset) + config->ticks;
8000189e:	39 c5 08 00 	ld.bu %d5,[%a12]8
    result  = stm->TIM0.U;
800018a2:	19 d6 10 00 	ld.w %d6,[%a13]16
    result |= ((uint64)stm->CAP.U) << 32;
800018a6:	19 d2 2c 00 	ld.w %d2,[%a13]44
800018aa:	8f 06 40 41 	or %d4,%d6,0
800018ae:	02 23       	mov %d3,%d2
    return (uint32)(now >> offset);
800018b0:	8b 05 82 22 	ge %d2,%d5,32
800018b4:	2b 34 50 42 	seln %d4,%d2,%d4,%d3
800018b8:	ab 03 a0 32 	seln %d3,%d2,%d3,0
800018bc:	8f f5 01 21 	and %d2,%d5,31
800018c0:	8b 02 02 51 	rsub %d5,%d2,32
800018c4:	17 43 80 35 	dextr %d3,%d3,%d4,%d5
800018c8:	2b 43 40 32 	sel %d3,%d2,%d3,%d4
800018cc:	02 34       	mov %d4,%d3
800018ce:	19 c3 10 00 	ld.w %d3,[%a12]16
800018d2:	54 c2       	ld.w %d2,[%a12]
800018d4:	42 43       	add %d3,%d4
800018d6:	1b c2 00 20 	addi %d2,%d2,12
800018da:	06 22       	sh %d2,2
800018dc:	01 d2 00 d6 	addsc.a %a13,%a13,%d2,0
800018e0:	74 d3       	st.w [%a13],%d3

    return result;
}
800018e2:	02 82       	mov %d2,%d8
800018e4:	00 90       	ret 
    else if (config->comparator == 1)
800018e6:	df 14 05 00 	jeq %d4,1,800018f0 <IfxStm_initCompare+0x11e>
        result = FALSE;
800018ea:	82 08       	mov %d8,0
800018ec:	1d ff 8a ff 	j 80001800 <IfxStm_initCompare+0x2e>
        comcon.B.MSIZE1  = config->compareSize;
800018f0:	19 54 0c 00 	ld.w %d4,[%a5]12
800018f4:	37 42 05 28 	insert %d2,%d2,%d4,16,5
        comcon.B.MSTART1 = config->compareOffset;
800018f8:	19 54 08 00 	ld.w %d4,[%a5]8
800018fc:	37 42 05 2c 	insert %d2,%d2,%d4,24,5
        icr.B.CMP1OS     = config->comparatorInterrupt;
80001900:	19 54 04 00 	ld.w %d4,[%a5]4
80001904:	67 43 06 30 	ins.t %d3,%d3,6,%d4,0
        result           = TRUE;
80001908:	82 18       	mov %d8,1
8000190a:	1d ff 7b ff 	j 80001800 <IfxStm_initCompare+0x2e>
            srcr = &(MODULE_SRC.STM.STM[index].SR1);
8000190e:	06 32       	sh %d2,3
80001910:	c2 42       	add %d2,4
80001912:	7b 40 00 4f 	movh %d4,61444
80001916:	1b 04 49 48 	addi %d4,%d4,-31600
8000191a:	60 42       	mov.a %a2,%d4
8000191c:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80001920:	1d ff 87 ff 	j 8000182e <IfxStm_initCompare+0x5c>

80001924 <IfxStm_initCompareConfig>:


void IfxStm_initCompareConfig(IfxStm_CompareConfig *config)
{
80001924:	40 ae       	mov.aa %a14,%sp
    config->comparator          = IfxStm_Comparator_0;
80001926:	82 02       	mov %d2,0
80001928:	74 42       	st.w [%a4],%d2
    config->compareOffset       = IfxStm_ComparatorOffset_0;
8000192a:	59 42 08 00 	st.w [%a4]8,%d2
    config->compareSize         = IfxStm_ComparatorSize_32Bits;
8000192e:	3b f0 01 30 	mov %d3,31
80001932:	59 43 0c 00 	st.w [%a4]12,%d3
    config->comparatorInterrupt = IfxStm_ComparatorInterrupt_ir0;     /*User must select the interrupt output */
80001936:	59 42 04 00 	st.w [%a4]4,%d2
    config->ticks               = 0xFFFFFFFF;
8000193a:	82 f3       	mov %d3,-1
8000193c:	59 43 10 00 	st.w [%a4]16,%d3
    config->triggerPriority     = 0;
80001940:	f9 42 14 00 	st.h [%a4]20,%d2
    config->typeOfService       = IfxSrc_Tos_cpu0;
80001944:	59 42 18 00 	st.w [%a4]24,%d2
}
80001948:	00 90       	ret 

8000194a <IfxScuCcu_isOscillatorStable>:
    *cfg = IfxScuCcu_defaultErayPllConfig;
}


IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
8000194a:	40 ae       	mov.aa %a14,%sp
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
8000194c:	6d 00 46 04 	call 800021d8 <IfxScuWdt_getCpuWatchdogPassword>
80001950:	02 28       	mov %d8,%d2

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
80001952:	91 30 00 2f 	movh.a %a2,61443
80001956:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <_SMALL_DATA4_+0x6002e010>>
8000195a:	54 23       	ld.w %d3,[%a2]
8000195c:	8f 03 c6 31 	andn %d3,%d3,96
80001960:	74 23       	st.w [%a2],%d3

    /* OSCVAL  defines the divider value that generates  the reference clock
     *  that is supervised by the oscillator watchdog.
     *  fOSC / (OSCVAL + 1) ~ 2.5Mhz  => OSCVAL = (fOSC / 2.5Mhz) - 1 */

    SCU_OSCCON.B.OSCVAL = ((uint32)IfxScuCcu_xtalFrequency / 2500000) - 1;
80001962:	91 00 00 36 	movh.a %a3,24576
80001966:	19 33 20 00 	ld.w %d3,[%a3]32 <60000020 <IfxScuCcu_xtalFrequency>>
8000196a:	7b 00 b6 26 	movh %d2,27488
8000196e:	1b b2 a6 2c 	addi %d2,%d2,-13717
80001972:	73 23 68 20 	mul.u %e2,%d3,%d2
80001976:	8f c3 1e 20 	sh %d2,%d3,-20
8000197a:	c2 f2       	add %d2,-1
8000197c:	54 23       	ld.w %d3,[%a2]
8000197e:	37 23 05 38 	insert %d3,%d3,%d2,16,5
80001982:	74 23       	st.w [%a2],%d3

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;
80001984:	54 23       	ld.w %d3,[%a2]
80001986:	b7 13 01 31 	insert %d3,%d3,1,2,1
8000198a:	74 23       	st.w [%a2],%d3
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
8000198c:	3b 00 28 30 	mov %d3,640

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
80001990:	1d 00 05 00 	j 8000199a <IfxScuCcu_isOscillatorStable+0x50>
    {
        TimeoutCtr--;
80001994:	c2 f3       	add %d3,-1

        if (TimeoutCtr == 0)
80001996:	df 03 25 00 	jeq %d3,0,800019e0 <IfxScuCcu_isOscillatorStable+0x96>
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
8000199a:	91 30 00 2f 	movh.a %a2,61443
8000199e:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <_SMALL_DATA4_+0x6002e010>>
800019a2:	54 25       	ld.w %d5,[%a2]
800019a4:	6f 15 f8 7f 	jz.t %d5,1,80001994 <IfxScuCcu_isOscillatorStable+0x4a>
800019a8:	54 25       	ld.w %d5,[%a2]
800019aa:	6f 85 f5 7f 	jz.t %d5,8,80001994 <IfxScuCcu_isOscillatorStable+0x4a>
    boolean status     = 0;
800019ae:	82 09       	mov %d9,0
        }
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
800019b0:	02 84       	mov %d4,%d8
800019b2:	6d 00 aa 02 	call 80001f06 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
800019b6:	91 30 00 2f 	movh.a %a2,61443
800019ba:	d9 22 2c 46 	lea %a2,[%a2]24876 <f003612c <_SMALL_DATA4_+0x6002e12c>>
800019be:	54 23       	ld.w %d3,[%a2]
800019c0:	b7 13 81 31 	insert %d3,%d3,1,3,1
800019c4:	74 23       	st.w [%a2],%d3
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
800019c6:	91 30 00 2f 	movh.a %a2,61443
800019ca:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x6002e130>>
800019ce:	54 23       	ld.w %d3,[%a2]
800019d0:	b7 13 81 31 	insert %d3,%d3,1,3,1
800019d4:	74 23       	st.w [%a2],%d3
        IfxScuWdt_setCpuEndinit(endinitPw);
800019d6:	02 84       	mov %d4,%d8
800019d8:	6d 00 1d 04 	call 80002212 <IfxScuWdt_setCpuEndinit>
    }

    return status;
}
800019dc:	02 92       	mov %d2,%d9
800019de:	00 90       	ret 
            status = 1;
800019e0:	82 19       	mov %d9,1
800019e2:	1d ff e7 ff 	j 800019b0 <IfxScuCcu_isOscillatorStable+0x66>

800019e6 <IfxScuCcu_getOscFrequency>:
{
800019e6:	40 ae       	mov.aa %a14,%sp
    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
800019e8:	91 30 00 2f 	movh.a %a2,61443
800019ec:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
800019f0:	54 22       	ld.w %d2,[%a2]
800019f2:	37 02 62 2e 	extr.u %d2,%d2,28,2
800019f6:	df 02 10 00 	jeq %d2,0,80001a16 <IfxScuCcu_getOscFrequency+0x30>
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800019fa:	54 22       	ld.w %d2,[%a2]
800019fc:	37 02 62 2e 	extr.u %d2,%d2,28,2
80001a00:	df 12 04 00 	jeq %d2,1,80001a08 <IfxScuCcu_getOscFrequency+0x22>
        freq = 0.0f;
80001a04:	82 02       	mov %d2,0
}
80001a06:	00 90       	ret 
        freq = (float32)IfxScuCcu_xtalFrequency;
80001a08:	91 00 00 26 	movh.a %a2,24576
80001a0c:	19 22 20 00 	ld.w %d2,[%a2]32 <60000020 <IfxScuCcu_xtalFrequency>>
80001a10:	4b 02 61 21 	utof %d2,%d2
80001a14:	00 90       	ret 
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80001a16:	7b f0 cb 24 	movh %d2,19647
80001a1a:	1b 02 c2 2b 	addi %d2,%d2,-17376
80001a1e:	00 90       	ret 

80001a20 <IfxScuCcu_getPllFrequency>:
{
80001a20:	40 ae       	mov.aa %a14,%sp
    oscFreq = IfxScuCcu_getOscFrequency();
80001a22:	6d ff e2 ff 	call 800019e6 <IfxScuCcu_getOscFrequency>
80001a26:	02 24       	mov %d4,%d2
    if (scu->PLLSTAT.B.VCOBYST == 1)
80001a28:	91 30 00 2f 	movh.a %a2,61443
80001a2c:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80001a30:	19 23 14 00 	ld.w %d3,[%a2]20 <f0030014 <_SMALL_DATA4_+0x60028014>>
80001a34:	6f 03 27 80 	jnz.t %d3,0,80001a82 <IfxScuCcu_getPllFrequency+0x62>
    else if (scu->PLLSTAT.B.FINDIS == 1)
80001a38:	91 30 00 2f 	movh.a %a2,61443
80001a3c:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80001a40:	19 22 14 00 	ld.w %d2,[%a2]20 <f0030014 <_SMALL_DATA4_+0x60028014>>
80001a44:	6f 32 2d 80 	jnz.t %d2,3,80001a9e <IfxScuCcu_getPllFrequency+0x7e>
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80001a48:	91 30 00 2f 	movh.a %a2,61443
80001a4c:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80001a50:	19 22 18 00 	ld.w %d2,[%a2]24 <f0030018 <_SMALL_DATA4_+0x60028018>>
80001a54:	37 02 e7 24 	extr.u %d2,%d2,9,7
80001a58:	c2 12       	add %d2,1
80001a5a:	4b 02 41 21 	itof %d2,%d2
80001a5e:	4b 42 41 30 	mul.f %d3,%d2,%d4
80001a62:	19 24 1c 00 	ld.w %d4,[%a2]28 <f003001c <_SMALL_DATA4_+0x6002801c>>
80001a66:	8f f4 07 41 	and %d4,%d4,127
80001a6a:	19 22 18 00 	ld.w %d2,[%a2]24 <f0030018 <_SMALL_DATA4_+0x60028018>>
80001a6e:	37 02 64 2c 	extr.u %d2,%d2,24,4
80001a72:	c2 12       	add %d2,1
80001a74:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
80001a78:	4b 02 41 21 	itof %d2,%d2
80001a7c:	4b 23 51 20 	div.f %d2,%d3,%d2
}
80001a80:	00 90       	ret 
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80001a82:	91 30 00 2f 	movh.a %a2,61443
80001a86:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80001a8a:	19 22 1c 00 	ld.w %d2,[%a2]28 <f003001c <_SMALL_DATA4_+0x6002801c>>
80001a8e:	37 02 67 28 	extr.u %d2,%d2,16,7
80001a92:	c2 12       	add %d2,1
80001a94:	4b 02 41 21 	itof %d2,%d2
80001a98:	4b 24 51 20 	div.f %d2,%d4,%d2
80001a9c:	00 90       	ret 
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80001a9e:	91 30 00 2f 	movh.a %a2,61443
80001aa2:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80001aa6:	19 24 1c 00 	ld.w %d4,[%a2]28 <f003001c <_SMALL_DATA4_+0x6002801c>>
80001aaa:	8f f4 07 41 	and %d4,%d4,127
80001aae:	c2 14       	add %d4,1
80001ab0:	6d 00 c3 1b 	call 80005236 <__floatsidf>
80001ab4:	0b 23 10 68 	mov %e6,%d3,%d2
80001ab8:	82 04       	mov %d4,0
80001aba:	7b 80 19 54 	movh %d5,16792
80001abe:	1b 45 78 5d 	addi %d5,%d5,-10364
80001ac2:	6d 00 12 1b 	call 800050e6 <__divdf3>
80001ac6:	0b 23 10 48 	mov %e4,%d3,%d2
80001aca:	6d 00 01 1c 	call 800052cc <__truncdfsf2>
80001ace:	00 90       	ret 

80001ad0 <IfxScuCcu_getSourceFrequency>:
{
80001ad0:	40 ae       	mov.aa %a14,%sp
    switch (SCU_CCUCON0.B.CLKSEL)
80001ad2:	91 30 00 2f 	movh.a %a2,61443
80001ad6:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001ada:	54 22       	ld.w %d2,[%a2]
80001adc:	37 02 62 2e 	extr.u %d2,%d2,28,2
80001ae0:	df 02 07 00 	jeq %d2,0,80001aee <IfxScuCcu_getSourceFrequency+0x1e>
80001ae4:	df 12 0a 80 	jne %d2,1,80001af8 <IfxScuCcu_getSourceFrequency+0x28>
        sourcefreq = IfxScuCcu_getPllFrequency();
80001ae8:	6d ff 9c ff 	call 80001a20 <IfxScuCcu_getPllFrequency>
        break;
80001aec:	00 90       	ret 
    switch (SCU_CCUCON0.B.CLKSEL)
80001aee:	7b f0 cb 24 	movh %d2,19647
80001af2:	1b 02 c2 2b 	addi %d2,%d2,-17376
80001af6:	00 90       	ret 
        sourcefreq = 0;
80001af8:	82 02       	mov %d2,0
}
80001afa:	00 90       	ret 

80001afc <IfxScuCcu_wait>:
    }
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
80001afc:	40 ae       	mov.aa %a14,%sp
80001afe:	02 48       	mov %d8,%d4
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
80001b00:	6d ff e8 ff 	call 80001ad0 <IfxScuCcu_getSourceFrequency>
80001b04:	91 30 00 2f 	movh.a %a2,61443
80001b08:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
80001b0c:	54 23       	ld.w %d3,[%a2]
80001b0e:	37 03 64 34 	extr.u %d3,%d3,8,4
80001b12:	4b 03 41 31 	itof %d3,%d3
80001b16:	4b 32 51 20 	div.f %d2,%d2,%d3
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
80001b1a:	4b 28 41 40 	mul.f %d4,%d8,%d2
80001b1e:	4b 04 71 41 	ftouz %d4,%d4
    uint32 stmCountBegin = STM0_TIM0.U;
80001b22:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x5fff8010>

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
80001b26:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x5fff8010>
80001b2a:	a2 32       	sub %d2,%d3
80001b2c:	3f 42 fd ff 	jlt.u %d2,%d4,80001b26 <IfxScuCcu_wait+0x2a>
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}
80001b30:	00 90       	ret 
	...

80001b34 <IfxScuCcu_getSpbFrequency>:
{
80001b34:	40 ae       	mov.aa %a14,%sp
    sourceFrequency = IfxScuCcu_getSourceFrequency();
80001b36:	6d ff cd ff 	call 80001ad0 <IfxScuCcu_getSourceFrequency>
    switch (SCU_CCUCON0.B.LPDIV)
80001b3a:	91 30 00 2f 	movh.a %a2,61443
80001b3e:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001b42:	54 23       	ld.w %d3,[%a2]
80001b44:	37 03 64 36 	extr.u %d3,%d3,12,4
80001b48:	ff 53 39 80 	jge.u %d3,5,80001bba <IfxScuCcu_getSpbFrequency+0x86>
80001b4c:	91 00 00 28 	movh.a %a2,32768
80001b50:	d9 22 9c d1 	lea %a2,[%a2]7004 <80001b5c <IfxScuCcu_getSpbFrequency+0x28>>
80001b54:	01 23 02 26 	addsc.a %a2,%a2,%d3,2
80001b58:	dc 02       	ji %a2
80001b5a:	00 00       	nop 
80001b5c:	1d 00 0a 00 	j 80001b70 <IfxScuCcu_getSpbFrequency+0x3c>
80001b60:	1d 00 19 00 	j 80001b92 <IfxScuCcu_getSpbFrequency+0x5e>
80001b64:	1d 00 1c 00 	j 80001b9c <IfxScuCcu_getSpbFrequency+0x68>
80001b68:	1d 00 1f 00 	j 80001ba6 <IfxScuCcu_getSpbFrequency+0x72>
80001b6c:	1d 00 22 00 	j 80001bb0 <IfxScuCcu_getSpbFrequency+0x7c>
        if (SCU_CCUCON0.B.SPBDIV == 0)
80001b70:	91 30 00 2f 	movh.a %a2,61443
80001b74:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001b78:	54 23       	ld.w %d3,[%a2]
80001b7a:	37 03 64 38 	extr.u %d3,%d3,16,4
80001b7e:	df 03 20 00 	jeq %d3,0,80001bbe <IfxScuCcu_getSpbFrequency+0x8a>
            spbFrequency = sourceFrequency / SCU_CCUCON0.B.SPBDIV;
80001b82:	54 23       	ld.w %d3,[%a2]
80001b84:	37 03 64 38 	extr.u %d3,%d3,16,4
80001b88:	4b 03 41 31 	itof %d3,%d3
80001b8c:	4b 32 51 20 	div.f %d2,%d2,%d3
80001b90:	00 90       	ret 
        spbFrequency = sourceFrequency / 30;
80001b92:	7b 00 1f 34 	movh %d3,16880
80001b96:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80001b9a:	00 90       	ret 
        spbFrequency = sourceFrequency / 60;
80001b9c:	7b 00 27 34 	movh %d3,17008
80001ba0:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80001ba4:	00 90       	ret 
        spbFrequency = sourceFrequency / 120;
80001ba6:	7b 00 2f 34 	movh %d3,17136
80001baa:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80001bae:	00 90       	ret 
        spbFrequency = sourceFrequency / 240;
80001bb0:	7b 00 37 34 	movh %d3,17264
80001bb4:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80001bb8:	00 90       	ret 
    switch (SCU_CCUCON0.B.LPDIV)
80001bba:	82 02       	mov %d2,0
80001bbc:	00 90       	ret 
            spbFrequency = 0.0f;
80001bbe:	82 02       	mov %d2,0
}
80001bc0:	00 90       	ret 

80001bc2 <IfxScuCcu_getSpbFrequency_end>:
	...

80001bc4 <IfxScuCcu_init>:
{
80001bc4:	40 ae       	mov.aa %a14,%sp
80001bc6:	40 4c       	mov.aa %a12,%a4
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
80001bc8:	19 42 10 10 	ld.w %d2,[%a4]80
80001bcc:	91 00 00 26 	movh.a %a2,24576
80001bd0:	59 22 20 00 	st.w [%a2]32 <60000020 <IfxScuCcu_xtalFrequency>>,%d2
    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
80001bd4:	6d 00 02 03 	call 800021d8 <IfxScuWdt_getCpuWatchdogPassword>
80001bd8:	02 2a       	mov %d10,%d2
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
80001bda:	6d 00 11 03 	call 800021fc <IfxScuWdt_getSafetyWatchdogPassword>
80001bde:	02 28       	mov %d8,%d2
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80001be0:	02 a4       	mov %d4,%d10
80001be2:	6d 00 92 01 	call 80001f06 <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80001be6:	91 30 00 2f 	movh.a %a2,61443
80001bea:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x6002e130>>
80001bee:	54 2d       	ld.w %d13,[%a2]
80001bf0:	37 0d e1 d1 	extr.u %d13,%d13,3,1
        SCU_TRAPDIS.B.SMUT = 1U;
80001bf4:	54 22       	ld.w %d2,[%a2]
80001bf6:	b7 12 81 21 	insert %d2,%d2,1,3,1
80001bfa:	74 22       	st.w [%a2],%d2
        IfxScuWdt_setCpuEndinit(endinit_pw);
80001bfc:	02 a4       	mov %d4,%d10
80001bfe:	6d 00 0a 03 	call 80002212 <IfxScuWdt_setCpuEndinit>
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80001c02:	02 84       	mov %d4,%d8
80001c04:	6d 00 a6 01 	call 80001f50 <IfxScuWdt_clearSafetyEndinit>
        while (SCU_CCUCON0.B.LCK != 0U)
80001c08:	91 30 00 2f 	movh.a %a2,61443
80001c0c:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001c10:	54 23       	ld.w %d3,[%a2]
80001c12:	bf 03 fb 7f 	jlt %d3,0,80001c08 <IfxScuCcu_init+0x44>
        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
80001c16:	54 22       	ld.w %d2,[%a2]
80001c18:	b7 02 02 2e 	insert %d2,%d2,0,28,2
80001c1c:	74 22       	st.w [%a2],%d2
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
80001c1e:	54 22       	ld.w %d2,[%a2]
80001c20:	b7 12 01 2f 	insert %d2,%d2,1,30,1
80001c24:	74 22       	st.w [%a2],%d2
        SCU_PLLCON0.B.SETFINDIS = 1;
80001c26:	91 30 00 2f 	movh.a %a2,61443
80001c2a:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x6002e018>>
80001c2e:	54 22       	ld.w %d2,[%a2]
80001c30:	b7 12 01 22 	insert %d2,%d2,1,4,1
80001c34:	74 22       	st.w [%a2],%d2
        while (SCU_CCUCON1.B.LCK != 0U)
80001c36:	91 30 00 2f 	movh.a %a2,61443
80001c3a:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
80001c3e:	54 23       	ld.w %d3,[%a2]
80001c40:	bf 03 fb 7f 	jlt %d3,0,80001c36 <IfxScuCcu_init+0x72>
        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
80001c44:	54 22       	ld.w %d2,[%a2]
80001c46:	b7 12 02 2e 	insert %d2,%d2,1,28,2
80001c4a:	74 22       	st.w [%a2],%d2
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */
80001c4c:	54 22       	ld.w %d2,[%a2]
80001c4e:	b7 12 01 2f 	insert %d2,%d2,1,30,1
80001c52:	74 22       	st.w [%a2],%d2
        status             |= IfxScuCcu_isOscillatorStable();
80001c54:	6d ff 7b fe 	call 8000194a <IfxScuCcu_isOscillatorStable>
80001c58:	02 2c       	mov %d12,%d2
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80001c5a:	02 84       	mov %d4,%d8
80001c5c:	6d 00 00 03 	call 8000225c <IfxScuWdt_setSafetyEndinit>
    if (status == 0)
80001c60:	df 0c 28 00 	jeq %d12,0,80001cb0 <IfxScuCcu_init+0xec>
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80001c64:	02 84       	mov %d4,%d8
80001c66:	6d 00 75 01 	call 80001f50 <IfxScuWdt_clearSafetyEndinit>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
80001c6a:	91 30 00 2f 	movh.a %a2,61443
80001c6e:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x6002e018>>
80001c72:	54 23       	ld.w %d3,[%a2]
80001c74:	8f 03 c4 31 	andn %d3,%d3,64
80001c78:	74 23       	st.w [%a2],%d3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80001c7a:	02 84       	mov %d4,%d8
80001c7c:	6d 00 f0 02 	call 8000225c <IfxScuWdt_setSafetyEndinit>
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80001c80:	02 a4       	mov %d4,%d10
80001c82:	6d 00 42 01 	call 80001f06 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
80001c86:	91 30 00 2f 	movh.a %a2,61443
80001c8a:	d9 22 2c 46 	lea %a2,[%a2]24876 <f003612c <_SMALL_DATA4_+0x6002e12c>>
80001c8e:	54 23       	ld.w %d3,[%a2]
80001c90:	b7 13 81 31 	insert %d3,%d3,1,3,1
80001c94:	74 23       	st.w [%a2],%d3
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80001c96:	91 30 00 2f 	movh.a %a2,61443
80001c9a:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x6002e130>>
80001c9e:	54 23       	ld.w %d3,[%a2]
80001ca0:	67 d3 03 30 	ins.t %d3,%d3,3,%d13,0
80001ca4:	74 23       	st.w [%a2],%d3
        IfxScuWdt_setCpuEndinit(endinit_pw);
80001ca6:	02 a4       	mov %d4,%d10
80001ca8:	6d 00 b5 02 	call 80002212 <IfxScuWdt_setCpuEndinit>
}
80001cac:	02 c2       	mov %d2,%d12
80001cae:	00 90       	ret 
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80001cb0:	02 84       	mov %d4,%d8
80001cb2:	6d 00 4f 01 	call 80001f50 <IfxScuWdt_clearSafetyEndinit>
                while (SCU_PLLSTAT.B.K2RDY == 0U)
80001cb6:	91 30 00 2f 	movh.a %a2,61443
80001cba:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x6002e014>>
80001cbe:	54 23       	ld.w %d3,[%a2]
80001cc0:	6f 53 fb 7f 	jz.t %d3,5,80001cb6 <IfxScuCcu_init+0xf2>
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
80001cc4:	39 c3 0a 00 	ld.bu %d3,[%a12]10
80001cc8:	91 30 00 2f 	movh.a %a2,61443
80001ccc:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <_SMALL_DATA4_+0x6002e01c>>
80001cd0:	54 22       	ld.w %d2,[%a2]
80001cd2:	37 32 07 20 	insert %d2,%d2,%d3,0,7
80001cd6:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.PDIV = cfg->sysPll.pllInitialStep.pDivider;
80001cd8:	39 c3 08 00 	ld.bu %d3,[%a12]8
80001cdc:	91 30 00 2f 	movh.a %a2,61443
80001ce0:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x6002e018>>
80001ce4:	54 22       	ld.w %d2,[%a2]
80001ce6:	37 32 04 2c 	insert %d2,%d2,%d3,24,4
80001cea:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.NDIV = cfg->sysPll.pllInitialStep.nDivider;
80001cec:	39 c3 09 00 	ld.bu %d3,[%a12]9
80001cf0:	54 22       	ld.w %d2,[%a2]
80001cf2:	37 32 87 24 	insert %d2,%d2,%d3,9,7
80001cf6:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.OSCDISCDIS = 1;
80001cf8:	54 22       	ld.w %d2,[%a2]
80001cfa:	b7 12 01 23 	insert %d2,%d2,1,6,1
80001cfe:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.PLLPWD     = 0; // set PLL to power down
80001d00:	54 22       	ld.w %d2,[%a2]
80001d02:	b7 02 01 28 	insert %d2,%d2,0,16,1
80001d06:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.CLRFINDIS  = 1;
80001d08:	54 22       	ld.w %d2,[%a2]
80001d0a:	b7 12 81 22 	insert %d2,%d2,1,5,1
80001d0e:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal
80001d10:	54 22       	ld.w %d2,[%a2]
80001d12:	b7 12 01 28 	insert %d2,%d2,1,16,1
80001d16:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.RESLD = 1;
80001d18:	54 22       	ld.w %d2,[%a2]
80001d1a:	b7 12 01 29 	insert %d2,%d2,1,18,1
80001d1e:	74 22       	st.w [%a2],%d2
                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
80001d20:	7b 20 85 43 	movh %d4,14418
80001d24:	1b 74 71 4b 	addi %d4,%d4,-18665
80001d28:	6d ff ea fe 	call 80001afc <IfxScuCcu_wait>
                    while (SCU_PLLSTAT.B.VCOLOCK == 0U)
80001d2c:	91 30 00 2f 	movh.a %a2,61443
80001d30:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x6002e014>>
80001d34:	54 23       	ld.w %d3,[%a2]
80001d36:	6f 23 fb 7f 	jz.t %d3,2,80001d2c <IfxScuCcu_init+0x168>
                    SCU_PLLCON0.B.VCOBYP = 0; /*VCO bypass disabled */
80001d3a:	91 30 00 2f 	movh.a %a2,61443
80001d3e:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x6002e018>>
80001d42:	54 22       	ld.w %d2,[%a2]
80001d44:	8f 12 c0 21 	andn %d2,%d2,1
80001d48:	74 22       	st.w [%a2],%d2
                    while (SCU_CCUCON0.B.LCK != 0U)
80001d4a:	91 30 00 2f 	movh.a %a2,61443
80001d4e:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001d52:	54 23       	ld.w %d3,[%a2]
80001d54:	bf 03 fb 7f 	jlt %d3,0,80001d4a <IfxScuCcu_init+0x186>
                    SCU_CCUCON0.B.CLKSEL = 0x01;
80001d58:	54 22       	ld.w %d2,[%a2]
80001d5a:	b7 12 02 2e 	insert %d2,%d2,1,28,2
80001d5e:	74 22       	st.w [%a2],%d2
                    while (SCU_CCUCON0.B.LCK != 0U)
80001d60:	91 30 00 2f 	movh.a %a2,61443
80001d64:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001d68:	54 23       	ld.w %d3,[%a2]
80001d6a:	bf 03 fb 7f 	jlt %d3,0,80001d60 <IfxScuCcu_init+0x19c>
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */
80001d6e:	19 c4 0c 00 	ld.w %d4,[%a12]12
80001d72:	6d ff c5 fe 	call 80001afc <IfxScuCcu_wait>
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
80001d76:	91 30 00 2f 	movh.a %a2,61443
80001d7a:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001d7e:	54 23       	ld.w %d3,[%a2]
80001d80:	19 c4 14 00 	ld.w %d4,[%a12]20 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001d84:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
80001d88:	19 c2 10 00 	ld.w %d2,[%a12]16
80001d8c:	26 42       	and %d2,%d4
80001d8e:	a6 23       	or %d3,%d2
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
80001d90:	b7 13 02 3e 	insert %d3,%d3,1,28,2
                        ccucon0.B.UP     = 1;
80001d94:	b7 13 01 3f 	insert %d3,%d3,1,30,1
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
80001d98:	74 23       	st.w [%a2],%d3
                    while (SCU_CCUCON1.B.LCK != 0U)
80001d9a:	91 30 00 2f 	movh.a %a2,61443
80001d9e:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
80001da2:	54 23       	ld.w %d3,[%a2]
80001da4:	bf 03 fb 7f 	jlt %d3,0,80001d9a <IfxScuCcu_init+0x1d6>
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
80001da8:	54 23       	ld.w %d3,[%a2]
80001daa:	19 c4 1c 00 	ld.w %d4,[%a12]28
80001dae:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
80001db2:	19 c2 18 00 	ld.w %d2,[%a12]24
80001db6:	26 42       	and %d2,%d4
80001db8:	a6 23       	or %d3,%d2
                        ccucon1.B.INSEL = 1;
80001dba:	b7 13 02 3e 	insert %d3,%d3,1,28,2
                        ccucon1.B.UP    = 1;
80001dbe:	b7 13 01 3f 	insert %d3,%d3,1,30,1
                        SCU_CCUCON1     = ccucon1;
80001dc2:	74 23       	st.w [%a2],%d3
                    while (SCU_CCUCON2.B.LCK != 0U)
80001dc4:	91 30 00 2f 	movh.a %a2,61443
80001dc8:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <_SMALL_DATA4_+0x6002e040>>
80001dcc:	54 23       	ld.w %d3,[%a2]
80001dce:	bf 03 fb 7f 	jlt %d3,0,80001dc4 <IfxScuCcu_init+0x200>
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
80001dd2:	54 23       	ld.w %d3,[%a2]
80001dd4:	19 c4 24 00 	ld.w %d4,[%a12]36
80001dd8:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
80001ddc:	19 c2 20 00 	ld.w %d2,[%a12]32
80001de0:	26 42       	and %d2,%d4
80001de2:	a6 32       	or %d2,%d3
                        ccucon2.B.UP = 1;
80001de4:	b7 12 01 2f 	insert %d2,%d2,1,30,1
                        SCU_CCUCON2  = ccucon2;
80001de8:	74 22       	st.w [%a2],%d2
                    while (SCU_CCUCON5.B.LCK != 0U)
80001dea:	91 30 00 2f 	movh.a %a2,61443
80001dee:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <_SMALL_DATA4_+0x6002e04c>>
80001df2:	54 23       	ld.w %d3,[%a2]
80001df4:	bf 03 fb 7f 	jlt %d3,0,80001dea <IfxScuCcu_init+0x226>
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
80001df8:	54 23       	ld.w %d3,[%a2]
80001dfa:	19 c4 2c 00 	ld.w %d4,[%a12]44
80001dfe:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
80001e02:	19 c2 28 00 	ld.w %d2,[%a12]40
80001e06:	26 42       	and %d2,%d4
80001e08:	a6 32       	or %d2,%d3
                        ccucon5.B.UP = 1;
80001e0a:	b7 12 01 2f 	insert %d2,%d2,1,30,1
                        SCU_CCUCON5  = ccucon5;
80001e0e:	74 22       	st.w [%a2],%d2
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
80001e10:	91 30 00 2f 	movh.a %a2,61443
80001e14:	d9 22 00 26 	lea %a2,[%a2]24704 <f0036080 <_SMALL_DATA4_+0x6002e080>>
80001e18:	54 23       	ld.w %d3,[%a2]
80001e1a:	19 c4 34 00 	ld.w %d4,[%a12]52 <f0036080 <_SMALL_DATA4_+0x6002e080>>
80001e1e:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
80001e22:	19 c2 30 00 	ld.w %d2,[%a12]48
80001e26:	26 42       	and %d2,%d4
80001e28:	a6 32       	or %d2,%d3
                        SCU_CCUCON6 = ccucon6;
80001e2a:	74 22       	st.w [%a2],%d2
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
80001e2c:	91 30 00 2f 	movh.a %a2,61443
80001e30:	d9 22 04 26 	lea %a2,[%a2]24708 <f0036084 <_SMALL_DATA4_+0x6002e084>>
80001e34:	54 23       	ld.w %d3,[%a2]
80001e36:	19 c4 3c 00 	ld.w %d4,[%a12]60 <f0036084 <_SMALL_DATA4_+0x6002e084>>
80001e3a:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
80001e3e:	19 c2 38 00 	ld.w %d2,[%a12]56
80001e42:	26 42       	and %d2,%d4
80001e44:	a6 32       	or %d2,%d3
                        SCU_CCUCON7 = ccucon7;
80001e46:	74 22       	st.w [%a2],%d2
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
80001e48:	91 30 00 2f 	movh.a %a2,61443
80001e4c:	d9 22 08 26 	lea %a2,[%a2]24712 <f0036088 <_SMALL_DATA4_+0x6002e088>>
80001e50:	54 23       	ld.w %d3,[%a2]
80001e52:	19 c4 04 10 	ld.w %d4,[%a12]68 <f0036088 <_SMALL_DATA4_+0x6002e088>>
80001e56:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
80001e5a:	19 c2 00 10 	ld.w %d2,[%a12]64
80001e5e:	26 42       	and %d2,%d4
80001e60:	a6 32       	or %d2,%d3
                        SCU_CCUCON8 = ccucon8;
80001e62:	74 22       	st.w [%a2],%d2
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80001e64:	02 84       	mov %d4,%d8
80001e66:	6d 00 fb 01 	call 8000225c <IfxScuWdt_setSafetyEndinit>
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;
80001e6a:	91 00 80 df 	movh.a %a13,63488
80001e6e:	d9 dd 14 02 	lea %a13,[%a13]8212 <f8002014 <_SMALL_DATA4_+0x67ffa014>>
80001e72:	54 d9       	ld.w %d9,[%a13]
80001e74:	19 c4 0c 10 	ld.w %d4,[%a12]76 <f8002014 <_SMALL_DATA4_+0x67ffa014>>
80001e78:	0f 49 e0 90 	andn %d9,%d9,%d4
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
80001e7c:	19 c2 08 10 	ld.w %d2,[%a12]72
80001e80:	26 42       	and %d2,%d4
80001e82:	a6 29       	or %d9,%d2
                IfxScuWdt_clearCpuEndinit(endinit_pw);
80001e84:	02 a4       	mov %d4,%d10
80001e86:	6d 00 40 00 	call 80001f06 <IfxScuWdt_clearCpuEndinit>
                FLASH0_FCON = fcon;
80001e8a:	74 d9       	st.w [%a13],%d9
                IfxScuWdt_setCpuEndinit(endinit_pw);
80001e8c:	02 a4       	mov %d4,%d10
80001e8e:	6d 00 c2 01 	call 80002212 <IfxScuWdt_setCpuEndinit>
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
80001e92:	02 c9       	mov %d9,%d12
80001e94:	1d 00 0d 00 	j 80001eae <IfxScuCcu_init+0x2ea>
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount].waitTime);
80001e98:	99 c2 04 00 	ld.a %a2,[%a12]4
80001e9c:	01 2b 00 26 	addsc.a %a2,%a2,%d11,0
80001ea0:	19 24 04 00 	ld.w %d4,[%a2]4
80001ea4:	6d ff 2c fe 	call 80001afc <IfxScuCcu_wait>
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
80001ea8:	c2 19       	add %d9,1
80001eaa:	8f f9 0f 91 	and %d9,%d9,255
80001eae:	14 c3       	ld.bu %d3,[%a12]
80001eb0:	7f 39 da fe 	jge.u %d9,%d3,80001c64 <IfxScuCcu_init+0xa0>
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80001eb4:	02 84       	mov %d4,%d8
80001eb6:	6d 00 4d 00 	call 80001f50 <IfxScuWdt_clearSafetyEndinit>
                while (SCU_PLLSTAT.B.K2RDY == 0U)
80001eba:	91 30 00 2f 	movh.a %a2,61443
80001ebe:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x6002e014>>
80001ec2:	54 23       	ld.w %d3,[%a2]
80001ec4:	6f 53 fb 7f 	jz.t %d3,5,80001eba <IfxScuCcu_init+0x2f6>
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
80001ec8:	53 c9 20 b0 	mul %d11,%d9,12
80001ecc:	99 c2 04 00 	ld.a %a2,[%a12]4
80001ed0:	01 2b 00 26 	addsc.a %a2,%a2,%d11,0
80001ed4:	14 24       	ld.bu %d4,[%a2]
80001ed6:	91 30 00 2f 	movh.a %a2,61443
80001eda:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <_SMALL_DATA4_+0x6002e01c>>
80001ede:	54 23       	ld.w %d3,[%a2]
80001ee0:	37 43 07 30 	insert %d3,%d3,%d4,0,7
80001ee4:	74 23       	st.w [%a2],%d3
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80001ee6:	02 84       	mov %d4,%d8
80001ee8:	6d 00 ba 01 	call 8000225c <IfxScuWdt_setSafetyEndinit>
            if (cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction != (IfxScuCcu_PllStepsFunctionHook)0)
80001eec:	99 c2 04 00 	ld.a %a2,[%a12]4
80001ef0:	01 2b 00 26 	addsc.a %a2,%a2,%d11,0
80001ef4:	d9 22 08 00 	lea %a2,[%a2]8
80001ef8:	d4 22       	ld.a %a2,[%a2]
80001efa:	bd 02 cf 7f 	jz.a %a2,80001e98 <IfxScuCcu_init+0x2d4>
                cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction();
80001efe:	2d 02 00 00 	calli %a2
80001f02:	1d ff cb ff 	j 80001e98 <IfxScuCcu_init+0x2d4>

80001f06 <IfxScuWdt_clearCpuEndinit>:
    {}
}


void IfxScuWdt_clearCpuEndinit(uint16 password)
{
80001f06:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
80001f08:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80001f0c:	8f 72 00 21 	and %d2,%d2,7
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
80001f10:	7b 30 00 3f 	movh %d3,61443
80001f14:	1b 03 10 36 	addi %d3,%d3,24832
80001f18:	13 c2 20 23 	madd %d2,%d3,%d2,12
80001f1c:	60 22       	mov.a %a2,%d2
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80001f1e:	54 22       	ld.w %d2,[%a2]
80001f20:	6f 12 0b 00 	jz.t %d2,1,80001f36 <IfxScuWdt_clearCpuEndinit+0x30>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001f24:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001f28:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001f2c:	54 22       	ld.w %d2,[%a2]
80001f2e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001f32:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001f34:	74 22       	st.w [%a2],%d2
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001f36:	8f 24 00 30 	sh %d3,%d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001f3a:	8f 23 40 31 	or %d3,%d3,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001f3e:	54 22       	ld.w %d2,[%a2]
80001f40:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001f44:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001f46:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
80001f48:	54 22       	ld.w %d2,[%a2]
80001f4a:	6f 02 ff ff 	jnz.t %d2,0,80001f48 <IfxScuWdt_clearCpuEndinit+0x42>
}
80001f4e:	00 90       	ret 

80001f50 <IfxScuWdt_clearSafetyEndinit>:


void IfxScuWdt_clearSafetyEndinit(uint16 password)
{
80001f50:	40 ae       	mov.aa %a14,%sp
80001f52:	37 04 70 40 	extr.u %d4,%d4,0,16
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80001f56:	91 30 00 2f 	movh.a %a2,61443
80001f5a:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001f5e:	54 22       	ld.w %d2,[%a2]
80001f60:	6f 12 0b 00 	jz.t %d2,1,80001f76 <IfxScuWdt_clearSafetyEndinit+0x26>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001f64:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001f68:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001f6c:	54 22       	ld.w %d2,[%a2]
80001f6e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001f72:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001f74:	74 22       	st.w [%a2],%d2
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001f76:	8f 24 00 30 	sh %d3,%d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001f7a:	8f 23 40 31 	or %d3,%d3,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001f7e:	91 30 00 2f 	movh.a %a2,61443
80001f82:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001f86:	54 22       	ld.w %d2,[%a2]
80001f88:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001f8c:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001f8e:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80001f90:	91 30 00 2f 	movh.a %a2,61443
80001f94:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001f98:	54 22       	ld.w %d2,[%a2]
80001f9a:	6f 02 fb ff 	jnz.t %d2,0,80001f90 <IfxScuWdt_clearSafetyEndinit+0x40>
    IfxScuWdt_clearSafetyEndinitInline(password);
}
80001f9e:	00 90       	ret 

80001fa0 <IfxScuWdt_disableCpuWatchdog>:


void IfxScuWdt_disableCpuWatchdog(uint16 password)
{
80001fa0:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
80001fa2:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80001fa6:	8f 72 00 21 	and %d2,%d2,7
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
80001faa:	7b 30 00 3f 	movh %d3,61443
80001fae:	1b 03 10 36 	addi %d3,%d3,24832
80001fb2:	13 c2 20 23 	madd %d2,%d3,%d2,12
80001fb6:	60 22       	mov.a %a2,%d2
    if (watchdog->CON0.B.LCK)
80001fb8:	54 22       	ld.w %d2,[%a2]
80001fba:	6f 12 0b 00 	jz.t %d2,1,80001fd0 <IfxScuWdt_disableCpuWatchdog+0x30>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001fbe:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001fc2:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001fc6:	54 22       	ld.w %d2,[%a2]
80001fc8:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001fcc:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001fce:	74 22       	st.w [%a2],%d2
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001fd0:	06 24       	sh %d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001fd2:	8f 24 40 31 	or %d3,%d4,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001fd6:	54 22       	ld.w %d2,[%a2]
80001fd8:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001fdc:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001fde:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80001fe0:	54 22       	ld.w %d2,[%a2]
80001fe2:	6f 02 ff ff 	jnz.t %d2,0,80001fe0 <IfxScuWdt_disableCpuWatchdog+0x40>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 1;         //Set DR bit in Config_1 register
80001fe6:	d9 23 04 00 	lea %a3,[%a2]4
80001fea:	19 22 04 00 	ld.w %d2,[%a2]4
80001fee:	b7 12 81 21 	insert %d2,%d2,1,3,1
80001ff2:	74 32       	st.w [%a3],%d2
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80001ff4:	54 22       	ld.w %d2,[%a2]
80001ff6:	6f 12 09 00 	jz.t %d2,1,80002008 <IfxScuWdt_disableCpuWatchdog+0x68>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001ffa:	8f 14 40 31 	or %d3,%d4,1
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001ffe:	54 22       	ld.w %d2,[%a2]
80002000:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002004:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002006:	74 22       	st.w [%a2],%d2
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80002008:	8f 34 40 41 	or %d4,%d4,3
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000200c:	54 22       	ld.w %d2,[%a2]
8000200e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002012:	a6 42       	or %d2,%d4
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002014:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80002016:	54 22       	ld.w %d2,[%a2]
80002018:	6f 02 ff 7f 	jz.t %d2,0,80002016 <IfxScuWdt_disableCpuWatchdog+0x76>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
8000201c:	00 90       	ret 

8000201e <IfxScuWdt_disableSafetyWatchdog>:


void IfxScuWdt_disableSafetyWatchdog(uint16 password)
{
8000201e:	40 ae       	mov.aa %a14,%sp
80002020:	37 04 70 40 	extr.u %d4,%d4,0,16
    if (SCU_WDTS_CON0.B.LCK)
80002024:	91 30 00 2f 	movh.a %a2,61443
80002028:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
8000202c:	54 22       	ld.w %d2,[%a2]
8000202e:	6f 12 0b 00 	jz.t %d2,1,80002044 <IfxScuWdt_disableSafetyWatchdog+0x26>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80002032:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80002036:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000203a:	54 22       	ld.w %d2,[%a2]
8000203c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80002040:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80002042:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80002044:	06 24       	sh %d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80002046:	8f 24 40 31 	or %d3,%d4,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000204a:	91 30 00 2f 	movh.a %a2,61443
8000204e:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80002052:	54 22       	ld.w %d2,[%a2]
80002054:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80002058:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000205a:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000205c:	91 30 00 2f 	movh.a %a2,61443
80002060:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80002064:	54 22       	ld.w %d2,[%a2]
80002066:	6f 02 fb ff 	jnz.t %d2,0,8000205c <IfxScuWdt_disableSafetyWatchdog+0x3e>
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 1;     //Set DR bit in Config_1 register
8000206a:	91 30 00 2f 	movh.a %a2,61443
8000206e:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x6002e0f4>>
80002072:	54 22       	ld.w %d2,[%a2]
80002074:	b7 12 81 21 	insert %d2,%d2,1,3,1
80002078:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000207a:	91 30 00 2f 	movh.a %a2,61443
8000207e:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80002082:	54 22       	ld.w %d2,[%a2]
80002084:	6f 12 09 00 	jz.t %d2,1,80002096 <IfxScuWdt_disableSafetyWatchdog+0x78>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80002088:	8f 14 40 31 	or %d3,%d4,1
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000208c:	54 22       	ld.w %d2,[%a2]
8000208e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80002092:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80002094:	74 22       	st.w [%a2],%d2
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80002096:	8f 34 40 41 	or %d4,%d4,3
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000209a:	91 30 00 2f 	movh.a %a2,61443
8000209e:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
800020a2:	54 22       	ld.w %d2,[%a2]
800020a4:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800020a8:	a6 42       	or %d2,%d4
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800020aa:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
800020ac:	91 30 00 2f 	movh.a %a2,61443
800020b0:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
800020b4:	54 22       	ld.w %d2,[%a2]
800020b6:	6f 02 fb 7f 	jz.t %d2,0,800020ac <IfxScuWdt_disableSafetyWatchdog+0x8e>
    IfxScuWdt_setSafetyEndinitInline(password);
}
800020ba:	00 90       	ret 

800020bc <IfxScuWdt_enableCpuWatchdog>:


void IfxScuWdt_enableCpuWatchdog(uint16 password)
{
800020bc:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
800020be:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800020c2:	8f 72 00 21 	and %d2,%d2,7
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
800020c6:	7b 30 00 3f 	movh %d3,61443
800020ca:	1b 03 10 36 	addi %d3,%d3,24832
800020ce:	13 c2 20 23 	madd %d2,%d3,%d2,12
800020d2:	60 22       	mov.a %a2,%d2
    if (watchdog->CON0.B.LCK)
800020d4:	54 22       	ld.w %d2,[%a2]
800020d6:	6f 12 0b 00 	jz.t %d2,1,800020ec <IfxScuWdt_enableCpuWatchdog+0x30>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800020da:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800020de:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800020e2:	54 22       	ld.w %d2,[%a2]
800020e4:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800020e8:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800020ea:	74 22       	st.w [%a2],%d2
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800020ec:	06 24       	sh %d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800020ee:	8f 24 40 31 	or %d3,%d4,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800020f2:	54 22       	ld.w %d2,[%a2]
800020f4:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800020f8:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800020fa:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800020fc:	54 22       	ld.w %d2,[%a2]
800020fe:	6f 02 ff ff 	jnz.t %d2,0,800020fc <IfxScuWdt_enableCpuWatchdog+0x40>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 0;         //Clear DR bit in Config_1 register
80002102:	d9 23 04 00 	lea %a3,[%a2]4
80002106:	19 22 04 00 	ld.w %d2,[%a2]4
8000210a:	8f 82 c0 21 	andn %d2,%d2,8
8000210e:	74 32       	st.w [%a3],%d2
    if (watchdog->CON0.B.LCK)
80002110:	54 22       	ld.w %d2,[%a2]
80002112:	6f 12 09 00 	jz.t %d2,1,80002124 <IfxScuWdt_enableCpuWatchdog+0x68>
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80002116:	8f 14 40 31 	or %d3,%d4,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000211a:	54 22       	ld.w %d2,[%a2]
8000211c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002120:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002122:	74 22       	st.w [%a2],%d2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80002124:	8f 34 40 41 	or %d4,%d4,3
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002128:	54 22       	ld.w %d2,[%a2]
8000212a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000212e:	a6 42       	or %d2,%d4
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002130:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80002132:	54 22       	ld.w %d2,[%a2]
80002134:	6f 02 ff 7f 	jz.t %d2,0,80002132 <IfxScuWdt_enableCpuWatchdog+0x76>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
80002138:	00 90       	ret 

8000213a <IfxScuWdt_enableSafetyWatchdog>:


void IfxScuWdt_enableSafetyWatchdog(uint16 password)
{
8000213a:	40 ae       	mov.aa %a14,%sp
8000213c:	37 04 70 40 	extr.u %d4,%d4,0,16
    if (SCU_WDTS_CON0.B.LCK)
80002140:	91 30 00 2f 	movh.a %a2,61443
80002144:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80002148:	54 22       	ld.w %d2,[%a2]
8000214a:	6f 12 0b 00 	jz.t %d2,1,80002160 <IfxScuWdt_enableSafetyWatchdog+0x26>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000214e:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80002152:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80002156:	54 22       	ld.w %d2,[%a2]
80002158:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000215c:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000215e:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80002160:	06 24       	sh %d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80002162:	8f 24 40 31 	or %d3,%d4,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80002166:	91 30 00 2f 	movh.a %a2,61443
8000216a:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
8000216e:	54 22       	ld.w %d2,[%a2]
80002170:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80002174:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80002176:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80002178:	91 30 00 2f 	movh.a %a2,61443
8000217c:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80002180:	54 22       	ld.w %d2,[%a2]
80002182:	6f 02 fb ff 	jnz.t %d2,0,80002178 <IfxScuWdt_enableSafetyWatchdog+0x3e>
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 0;     //Clear DR bit in Config_1 register
80002186:	91 30 00 2f 	movh.a %a2,61443
8000218a:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x6002e0f4>>
8000218e:	54 22       	ld.w %d2,[%a2]
80002190:	8f 82 c0 21 	andn %d2,%d2,8
80002194:	74 22       	st.w [%a2],%d2
    if (SCU_WDTS_CON0.B.LCK)
80002196:	91 30 00 2f 	movh.a %a2,61443
8000219a:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
8000219e:	54 22       	ld.w %d2,[%a2]
800021a0:	6f 12 09 00 	jz.t %d2,1,800021b2 <IfxScuWdt_enableSafetyWatchdog+0x78>
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
800021a4:	8f 14 40 31 	or %d3,%d4,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800021a8:	54 22       	ld.w %d2,[%a2]
800021aa:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800021ae:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800021b0:	74 22       	st.w [%a2],%d2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
800021b2:	8f 34 40 41 	or %d4,%d4,3
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800021b6:	91 30 00 2f 	movh.a %a2,61443
800021ba:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
800021be:	54 22       	ld.w %d2,[%a2]
800021c0:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800021c4:	a6 42       	or %d2,%d4
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800021c6:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
800021c8:	91 30 00 2f 	movh.a %a2,61443
800021cc:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
800021d0:	54 22       	ld.w %d2,[%a2]
800021d2:	6f 02 fb 7f 	jz.t %d2,0,800021c8 <IfxScuWdt_enableSafetyWatchdog+0x8e>
    IfxScuWdt_setSafetyEndinitInline(password);
}
800021d6:	00 90       	ret 

800021d8 <IfxScuWdt_getCpuWatchdogPassword>:


uint16 IfxScuWdt_getCpuWatchdogPassword(void)
{
800021d8:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
800021da:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800021de:	8f 72 00 21 	and %d2,%d2,7
    return IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
800021e2:	7b 30 00 3f 	movh %d3,61443
800021e6:	1b 03 10 36 	addi %d3,%d3,24832
800021ea:	13 c2 20 23 	madd %d2,%d3,%d2,12
    password  = watchdog->CON0.B.PW;
800021ee:	60 22       	mov.a %a2,%d2
800021f0:	54 22       	ld.w %d2,[%a2]
800021f2:	37 02 6e 21 	extr.u %d2,%d2,2,14
}
800021f6:	8f f2 83 21 	xor %d2,%d2,63
800021fa:	00 90       	ret 

800021fc <IfxScuWdt_getSafetyWatchdogPassword>:
    return (boolean)IfxScuWdt_getCpuWatchdogEndInitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
}


uint16 IfxScuWdt_getSafetyWatchdogPassword(void)
{
800021fc:	40 ae       	mov.aa %a14,%sp
    password  = watchdog->CON0.B.PW;
800021fe:	91 30 00 2f 	movh.a %a2,61443
80002202:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80002206:	54 22       	ld.w %d2,[%a2]
80002208:	37 02 6e 21 	extr.u %d2,%d2,2,14
    return IfxScuWdt_getSafetyWatchdogPasswordInline();
}
8000220c:	8f f2 83 21 	xor %d2,%d2,63
80002210:	00 90       	ret 

80002212 <IfxScuWdt_setCpuEndinit>:
    IfxScuWdt_setSafetyEndinit(password);
}


void IfxScuWdt_setCpuEndinit(uint16 password)
{
80002212:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
80002214:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80002218:	8f 72 00 21 	and %d2,%d2,7
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
8000221c:	7b 30 00 3f 	movh %d3,61443
80002220:	1b 03 10 36 	addi %d3,%d3,24832
80002224:	13 c2 20 23 	madd %d2,%d3,%d2,12
80002228:	60 22       	mov.a %a2,%d2
    if (watchdog->CON0.B.LCK)
8000222a:	54 22       	ld.w %d2,[%a2]
8000222c:	6f 12 0b 00 	jz.t %d2,1,80002242 <IfxScuWdt_setCpuEndinit+0x30>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002230:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80002234:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002238:	54 22       	ld.w %d2,[%a2]
8000223a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000223e:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002240:	74 22       	st.w [%a2],%d2
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002242:	8f 24 00 30 	sh %d3,%d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80002246:	8f 33 40 31 	or %d3,%d3,3
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000224a:	54 22       	ld.w %d2,[%a2]
8000224c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002250:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002252:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80002254:	54 22       	ld.w %d2,[%a2]
80002256:	6f 02 ff 7f 	jz.t %d2,0,80002254 <IfxScuWdt_setCpuEndinit+0x42>
}
8000225a:	00 90       	ret 

8000225c <IfxScuWdt_setSafetyEndinit>:


void IfxScuWdt_setSafetyEndinit(uint16 password)
{
8000225c:	40 ae       	mov.aa %a14,%sp
8000225e:	37 04 70 40 	extr.u %d4,%d4,0,16
    if (SCU_WDTS_CON0.B.LCK)
80002262:	91 30 00 2f 	movh.a %a2,61443
80002266:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
8000226a:	54 22       	ld.w %d2,[%a2]
8000226c:	6f 12 0b 00 	jz.t %d2,1,80002282 <IfxScuWdt_setSafetyEndinit+0x26>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80002270:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80002274:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80002278:	54 22       	ld.w %d2,[%a2]
8000227a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000227e:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80002280:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80002282:	8f 24 00 30 	sh %d3,%d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80002286:	8f 33 40 31 	or %d3,%d3,3
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000228a:	91 30 00 2f 	movh.a %a2,61443
8000228e:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80002292:	54 22       	ld.w %d2,[%a2]
80002294:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80002298:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000229a:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
8000229c:	91 30 00 2f 	movh.a %a2,61443
800022a0:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
800022a4:	54 22       	ld.w %d2,[%a2]
800022a6:	6f 02 fb 7f 	jz.t %d2,0,8000229c <IfxScuWdt_setSafetyEndinit+0x40>
    IfxScuWdt_setSafetyEndinitInline(password);
}
800022aa:	00 90       	ret 

800022ac <IfxPort_setPinMode>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
800022ac:	40 ae       	mov.aa %a14,%sp
800022ae:	40 4c       	mov.aa %a12,%a4
800022b0:	02 5a       	mov %d10,%d5
800022b2:	8f f4 0f c1 	and %d12,%d4,255
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
800022b6:	80 42       	mov.d %d2,%a4
800022b8:	1b 02 01 b0 	addi %d11,%d2,16
    uint8                 iocrIndex = (pinIndex / 4);
800022bc:	37 04 66 91 	extr.u %d9,%d4,2,6
    uint8                 shift     = (pinIndex & 0x3U) * 8;
800022c0:	8f 34 00 41 	and %d4,%d4,3
800022c4:	8f 34 00 80 	sh %d8,%d4,3

    if (port == &MODULE_P40)
800022c8:	7b 40 00 2f 	movh %d2,61444
800022cc:	1b 02 00 2e 	addi %d2,%d2,-8192
800022d0:	80 43       	mov.d %d3,%a4
800022d2:	5f 23 12 00 	jeq %d3,%d2,800022f6 <IfxPort_setPinMode+0x4a>
        IfxScuWdt_clearCpuEndinit(passwd);
        port->PDISC.U &= ~(1 << pinIndex);
        IfxScuWdt_setCpuEndinit(passwd);
    }

    __ldmst(&iocr[iocrIndex].U, (0xFFUL << shift), (mode << shift));
800022d6:	8f 29 00 20 	sh %d2,%d9,2
800022da:	60 b2       	mov.a %a2,%d11
800022dc:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800022e0:	3b f0 0f 40 	mov %d4,255
800022e4:	0f 84 00 40 	sh %d4,%d4,%d8
800022e8:	0f 8a 00 20 	sh %d2,%d10,%d8
                     ::"a"(address), "d"(mask), "d"((long long)value));
800022ec:	82 03       	mov %d3,0
    __asm__ volatile("mov %H2,%1 \n\
800022ee:	02 43       	mov %d3,%d4
800022f0:	49 22 40 08 	ldmst [%a2]0,%e2
}
800022f4:	00 90       	ret 
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800022f6:	6d ff 71 ff 	call 800021d8 <IfxScuWdt_getCpuWatchdogPassword>
800022fa:	02 2d       	mov %d13,%d2
        IfxScuWdt_clearCpuEndinit(passwd);
800022fc:	02 24       	mov %d4,%d2
800022fe:	6d ff 04 fe 	call 80001f06 <IfxScuWdt_clearCpuEndinit>
        port->PDISC.U &= ~(1 << pinIndex);
80002302:	d9 c2 20 10 	lea %a2,[%a12]96
80002306:	19 c2 20 10 	ld.w %d2,[%a12]96
8000230a:	d7 02 01 2c 	insert %d2,%d2,0,%d12,1
8000230e:	74 22       	st.w [%a2],%d2
        IfxScuWdt_setCpuEndinit(passwd);
80002310:	02 d4       	mov %d4,%d13
80002312:	6d ff 80 ff 	call 80002212 <IfxScuWdt_setCpuEndinit>
80002316:	1d ff e0 ff 	j 800022d6 <IfxPort_setPinMode+0x2a>

8000231a <IfxPort_setPinPadDriver>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
8000231a:	40 ae       	mov.aa %a14,%sp
8000231c:	80 4b       	mov.d %d11,%a4
8000231e:	02 5a       	mov %d10,%d5
80002320:	8f f4 0f 81 	and %d8,%d4,255
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80002324:	6d ff 5a ff 	call 800021d8 <IfxScuWdt_getCpuWatchdogPassword>
80002328:	02 29       	mov %d9,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
8000232a:	02 24       	mov %d4,%d2
8000232c:	6d ff ed fd 	call 80001f06 <IfxScuWdt_clearCpuEndinit>
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
80002330:	1b 0b 04 40 	addi %d4,%d11,64
        uint8            pdrIndex = (pinIndex / 8);
80002334:	8f d8 1f 20 	sh %d2,%d8,-3
        uint8            shift    = (pinIndex & 0x7U) * 4;
80002338:	8f 78 00 31 	and %d3,%d8,7
8000233c:	06 23       	sh %d3,2
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
8000233e:	06 22       	sh %d2,2
80002340:	60 42       	mov.a %a2,%d4
80002342:	01 22 00 46 	addsc.a %a4,%a2,%d2,0
80002346:	3b f0 00 20 	mov %d2,15
8000234a:	0f 32 00 20 	sh %d2,%d2,%d3
8000234e:	0f 3a 00 30 	sh %d3,%d10,%d3
                     ::"a"(address), "d"(mask), "d"((long long)value));
80002352:	53 13 40 60 	mul.u %e6,%d3,1
    __asm__ volatile("mov %H2,%1 \n\
80002356:	02 27       	mov %d7,%d2
80002358:	49 46 40 08 	ldmst [%a4]0,%e6
    }
    IfxScuWdt_setCpuEndinit(passwd);
8000235c:	02 94       	mov %d4,%d9
8000235e:	6d ff 5a ff 	call 80002212 <IfxScuWdt_setCpuEndinit>
}
80002362:	00 90       	ret 

80002364 <IfxGtm_Tom_Timer_acknowledgeTimerIrq>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

boolean IfxGtm_Tom_Timer_acknowledgeTimerIrq(IfxGtm_Tom_Timer *driver)
{
80002364:	40 ae       	mov.aa %a14,%sp
    boolean event;

    event = IfxGtm_Tom_Ch_isZeroNotification(driver->tom, driver->timerChannel);
80002366:	19 43 14 00 	ld.w %d3,[%a4]20
8000236a:	19 42 24 00 	ld.w %d2,[%a4]36
}


IFX_INLINE Ifx_GTM_TOM_CH *IfxGtm_Tom_Ch_getChannelPointer(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
8000236e:	06 62       	sh %d2,6
80002370:	60 32       	mov.a %a2,%d3
80002372:	01 22 00 26 	addsc.a %a2,%a2,%d2,0

IFX_INLINE boolean IfxGtm_Tom_Ch_isZeroNotification(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    boolean         notify;
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);
    notify = (tomCh->IRQ_NOTIFY.B.CCU0TC != 0u) ? TRUE : FALSE;
80002376:	d9 23 1c 00 	lea %a3,[%a2]28
8000237a:	19 22 1c 00 	ld.w %d2,[%a2]28
8000237e:	6f 02 08 00 	jz.t %d2,0,8000238e <IfxGtm_Tom_Timer_acknowledgeTimerIrq+0x2a>
    tomCh->IRQ_NOTIFY.B.CCU0TC = 1;
80002382:	54 32       	ld.w %d2,[%a3]
80002384:	b7 12 01 20 	insert %d2,%d2,1,0,1
80002388:	74 32       	st.w [%a3],%d2
    notify = (tomCh->IRQ_NOTIFY.B.CCU0TC != 0u) ? TRUE : FALSE;
8000238a:	82 12       	mov %d2,1
}
8000238c:	00 90       	ret 
    notify = (tomCh->IRQ_NOTIFY.B.CCU0TC != 0u) ? TRUE : FALSE;
8000238e:	82 02       	mov %d2,0
    }
    else
    {}

    return event;
}
80002390:	00 90       	ret 

80002392 <IfxGtm_Tom_Timer_applyUpdate>:
    }
}


void IfxGtm_Tom_Timer_applyUpdate(IfxGtm_Tom_Timer *driver)
{
80002392:	40 ae       	mov.aa %a14,%sp
    IfxGtm_Tom_Tgc_writeGlobalControl(driver->tgc[0], driver->tgcGlobalControlApplyUpdate[0]);
80002394:	99 42 18 00 	ld.a %a2,[%a4]24
}


IFX_INLINE void IfxGtm_Tom_Tgc_writeGlobalControl(Ifx_GTM_TOM_TGC *tgc, uint32 control)
{
    tgc->GLB_CTRL.U = control;
80002398:	19 42 3c 00 	ld.w %d2,[%a4]60
8000239c:	74 22       	st.w [%a2],%d2

    if (driver->tgc[1])
8000239e:	99 42 1c 00 	ld.a %a2,[%a4]28
800023a2:	bd 02 05 00 	jz.a %a2,800023ac <IfxGtm_Tom_Timer_applyUpdate+0x1a>
    {
        IfxGtm_Tom_Tgc_writeGlobalControl(driver->tgc[1], driver->tgcGlobalControlApplyUpdate[1]);  /* Note: Write of 0 value has no effect */
800023a6:	19 42 00 10 	ld.w %d2,[%a4]64
800023aa:	74 22       	st.w [%a2],%d2
    }
}
800023ac:	00 90       	ret 

800023ae <IfxGtm_Tom_Timer_disableUpdate>:


void IfxGtm_Tom_Timer_disableUpdate(IfxGtm_Tom_Timer *driver)
{
800023ae:	40 ae       	mov.aa %a14,%sp
    IfxGtm_Tom_Tgc_writeGlobalControl(driver->tgc[0], driver->tgcGlobalControlDisableUpdate[0]);
800023b0:	99 42 18 00 	ld.a %a2,[%a4]24
800023b4:	19 42 34 00 	ld.w %d2,[%a4]52
800023b8:	74 22       	st.w [%a2],%d2

    if (driver->tgc[1])
800023ba:	99 42 1c 00 	ld.a %a2,[%a4]28
800023be:	bd 02 05 00 	jz.a %a2,800023c8 <IfxGtm_Tom_Timer_disableUpdate+0x1a>
    {
        IfxGtm_Tom_Tgc_writeGlobalControl(driver->tgc[1], driver->tgcGlobalControlDisableUpdate[1]); /* Note: Write of 0 value has no effect */
800023c2:	19 42 38 00 	ld.w %d2,[%a4]56
800023c6:	74 22       	st.w [%a2],%d2
    }
}
800023c8:	00 90       	ret 

800023ca <IfxGtm_Tom_Timer_getPeriod>:
    return driver->offset;
}


Ifx_TimerValue IfxGtm_Tom_Timer_getPeriod(IfxGtm_Tom_Timer *driver)
{
800023ca:	40 ae       	mov.aa %a14,%sp
    return driver->base.period;
}
800023cc:	54 42       	ld.w %d2,[%a4]
800023ce:	00 90       	ret 

800023d0 <IfxGtm_Tom_Timer_setPeriod>:
    return status;
}


boolean IfxGtm_Tom_Timer_setPeriod(IfxGtm_Tom_Timer *driver, Ifx_TimerValue period)
{
800023d0:	40 ae       	mov.aa %a14,%sp
    driver->base.period = period;
800023d2:	74 44       	st.w [%a4],%d4
    IfxGtm_Tom_Ch_setCompareZeroShadow(driver->tom, driver->timerChannel, (uint16)period);
800023d4:	19 43 24 00 	ld.w %d3,[%a4]36
800023d8:	37 04 70 40 	extr.u %d4,%d4,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800023dc:	06 63       	sh %d3,6
800023de:	99 42 14 00 	ld.a %a2,[%a4]20
800023e2:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
    tomCh->SR0.U = shadowZero;
800023e6:	59 24 04 00 	st.w [%a2]4,%d4

    if (driver->triggerChannel != driver->timerChannel)
800023ea:	19 42 28 00 	ld.w %d2,[%a4]40
800023ee:	19 43 24 00 	ld.w %d3,[%a4]36
800023f2:	5f 32 0a 00 	jeq %d2,%d3,80002406 <IfxGtm_Tom_Timer_setPeriod+0x36>
    {
        IfxGtm_Tom_Ch_setCompareZeroShadow(driver->tom, driver->triggerChannel, (uint16)period);
800023f6:	19 43 14 00 	ld.w %d3,[%a4]20
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800023fa:	06 62       	sh %d2,6
800023fc:	60 32       	mov.a %a2,%d3
800023fe:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
    tomCh->SR0.U = shadowZero;
80002402:	59 24 04 00 	st.w [%a2]4,%d4
    }

    return TRUE;
}
80002406:	82 12       	mov %d2,1
80002408:	00 90       	ret 

8000240a <IfxGtm_Tom_Timer_setFrequency>:
{
8000240a:	40 ae       	mov.aa %a14,%sp
    Ifx_TimerValue period = IfxStdIf_Timer_sToTick(driver->base.clockFreq, 1.0f / frequency);
8000240c:	19 43 08 00 	ld.w %d3,[%a4]8
80002410:	7b 00 f8 23 	movh %d2,16256
80002414:	4b 42 51 20 	div.f %d2,%d2,%d4
 * \param  seconds time value in seconds to be converted
 * \return Return the converted time in timer ticks
 */
IFX_INLINE Ifx_TimerValue IfxStdIf_Timer_sToTick(float32 clockFreq, float32 seconds)
{
    return seconds * clockFreq;
80002418:	4b 23 41 20 	mul.f %d2,%d3,%d2
8000241c:	4b 02 71 41 	ftouz %d4,%d2
    if ((period & (0xFFFF << 16)) != 0)
80002420:	b7 04 10 20 	insert %d2,%d4,0,0,16
80002424:	df 02 04 00 	jeq %d2,0,8000242c <IfxGtm_Tom_Timer_setFrequency+0x22>
        status = FALSE;
80002428:	82 02       	mov %d2,0
}
8000242a:	00 90       	ret 
        IfxGtm_Tom_Timer_setPeriod(driver, period);
8000242c:	6d ff d2 ff 	call 800023d0 <IfxGtm_Tom_Timer_setPeriod>
    boolean        status = TRUE;
80002430:	82 12       	mov %d2,1
80002432:	00 90       	ret 

80002434 <IfxGtm_Tom_Timer_setTrigger>:
    IfxGtm_Tom_Ch_setOneShotMode(driver->tom, driver->timerChannel, enabled);
}


void IfxGtm_Tom_Timer_setTrigger(IfxGtm_Tom_Timer *driver, Ifx_TimerValue triggerPoint)
{
80002434:	40 ae       	mov.aa %a14,%sp
    IfxGtm_Tom_Ch_setCompareOneShadow(driver->tom, driver->triggerChannel, (uint16)triggerPoint + 1);
80002436:	19 43 14 00 	ld.w %d3,[%a4]20
8000243a:	19 42 28 00 	ld.w %d2,[%a4]40
8000243e:	37 04 70 40 	extr.u %d4,%d4,0,16
80002442:	c2 14       	add %d4,1
80002444:	37 04 70 40 	extr.u %d4,%d4,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002448:	06 62       	sh %d2,6
8000244a:	60 32       	mov.a %a2,%d3
8000244c:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
    tomCh->SR1.U = shadowOne;
80002450:	59 24 08 00 	st.w [%a2]8,%d4
}
80002454:	00 90       	ret 

80002456 <IfxGtm_Tom_Timer_run>:
{
80002456:	40 ae       	mov.aa %a14,%sp
80002458:	40 4c       	mov.aa %a12,%a4
    IfxGtm_Tom_Tgc_enableChannels(driver->tgc[0], driver->channelsMask[0], 0, TRUE);
8000245a:	99 4d 18 00 	ld.a %a13,[%a4]24
    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_ENDIS_CTRL_ENDIS_CTRL0_OFF);
8000245e:	82 06       	mov %d6,0
80002460:	82 05       	mov %d5,0
80002462:	b9 44 2c 00 	ld.hu %d4,[%a4]44
80002466:	6d 00 f3 0a 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
        tgc->ENDIS_CTRL.U = value;
8000246a:	59 d2 00 10 	st.w [%a13]64,%d2
        tgc->ENDIS_STAT.U = value;
8000246e:	59 d2 04 10 	st.w [%a13]68,%d2
    if (driver->tgc[1])
80002472:	99 cd 1c 00 	ld.a %a13,[%a12]28
80002476:	bd 0d 0c 00 	jz.a %a13,8000248e <IfxGtm_Tom_Timer_run+0x38>
    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_ENDIS_CTRL_ENDIS_CTRL0_OFF);
8000247a:	82 06       	mov %d6,0
8000247c:	82 05       	mov %d5,0
8000247e:	b9 c4 2e 00 	ld.hu %d4,[%a12]46
80002482:	6d 00 e5 0a 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
        tgc->ENDIS_CTRL.U = value;
80002486:	59 d2 00 10 	st.w [%a13]64,%d2
        tgc->ENDIS_STAT.U = value;
8000248a:	59 d2 04 10 	st.w [%a13]68,%d2
}
8000248e:	00 90       	ret 

80002490 <IfxGtm_Tom_Timer_updateInputFrequency>:
    }
}


void IfxGtm_Tom_Timer_updateInputFrequency(IfxGtm_Tom_Timer *driver)
{
80002490:	40 ae       	mov.aa %a14,%sp
80002492:	20 18       	sub.a %sp,24
80002494:	40 4c       	mov.aa %a12,%a4
    driver->base.clockFreq = IfxGtm_Tom_Ch_getClockFrequency(driver->gtm, driver->tom, driver->timerChannel);
80002496:	99 44 10 00 	ld.a %a4,[%a4]16
8000249a:	19 c2 24 00 	ld.w %d2,[%a12]36
    IfxGtm_Cmu_Fxclk     clkIndex[5] = {
8000249e:	91 00 00 26 	movh.a %a2,24576
800024a2:	d9 22 00 00 	lea %a2,[%a2]0 <60000000 <LCF_DSPR1_START>>
800024a6:	d9 e3 ec ff 	lea %a3,[%a14]-20 <60000000 <LCF_DSPR1_START>>
800024aa:	09 24 48 01 	ld.d %e4,[%a2+]8 <60000008 <LCF_DSPR1_START+0x8>>
800024ae:	89 34 48 01 	st.d [%a3+]8 <60000008 <LCF_DSPR1_START+0x8>>,%e4
800024b2:	09 24 48 01 	ld.d %e4,[%a2+]8 <60000008 <LCF_DSPR1_START+0x8>>
800024b6:	89 34 48 01 	st.d [%a3+]8 <60000008 <LCF_DSPR1_START+0x8>>,%e4
800024ba:	44 24       	ld.w %d4,[%a2+]
800024bc:	64 34       	st.w [%a3+],%d4
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800024be:	06 62       	sh %d2,6
800024c0:	99 c2 14 00 	ld.a %a2,[%a12]20
800024c4:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
    clk = (IfxGtm_Tom_Ch_ClkSrc)tomCh->CTRL.B.CLK_SRC_SR;
800024c8:	54 22       	ld.w %d2,[%a2]
800024ca:	37 02 63 26 	extr.u %d2,%d2,12,3
    if (clk == IfxGtm_Tom_Ch_ClkSrc_noClock)
800024ce:	df 52 06 80 	jne %d2,5,800024da <IfxGtm_Tom_Timer_updateInputFrequency+0x4a>
        return (float32)0.0f;
800024d2:	82 02       	mov %d2,0
800024d4:	59 c2 08 00 	st.w [%a12]8,%d2
}
800024d8:	00 90       	ret 
        return IfxGtm_Cmu_getFxClkFrequency(gtm, clkIndex[clk], TRUE);
800024da:	06 22       	sh %d2,2
800024dc:	01 e2 00 26 	addsc.a %a2,%a14,%d2,0
800024e0:	82 15       	mov %d5,1
800024e2:	19 24 ec ff 	ld.w %d4,[%a2]-20
800024e6:	6d 00 b1 09 	call 80003848 <IfxGtm_Cmu_getFxClkFrequency>
800024ea:	1d ff f5 ff 	j 800024d4 <IfxGtm_Tom_Timer_updateInputFrequency+0x44>

800024ee <IfxGtm_Tom_Timer_addToChannelMask>:
{
800024ee:	40 ae       	mov.aa %a14,%sp
800024f0:	40 4c       	mov.aa %a12,%a4
    if (driver->timerChannel <= IfxGtm_Tom_Ch_7)
800024f2:	19 42 24 00 	ld.w %d2,[%a4]36
800024f6:	8b 82 80 22 	ge %d2,%d2,8
800024fa:	df 02 39 80 	jne %d2,0,8000256c <IfxGtm_Tom_Timer_addToChannelMask+0x7e>
        if (channel <= IfxGtm_Tom_Ch_7)
800024fe:	8b 84 80 22 	ge %d2,%d4,8
80002502:	df 02 1b 80 	jne %d2,0,80002538 <IfxGtm_Tom_Timer_addToChannelMask+0x4a>
            driver->channelsMask[0]                 |= 1 << channel;
80002506:	c9 42 2c 00 	ld.h %d2,[%a4]44
8000250a:	d7 12 01 24 	insert %d2,%d2,1,%d4,1
8000250e:	37 02 70 50 	extr.u %d5,%d2,0,16
80002512:	f9 45 2c 00 	st.h [%a4]44,%d5
            driver->tgcGlobalControlDisableUpdate[0] = IfxGtm_Tom_Tgc_buildFeature(0, driver->channelsMask[0], IFX_GTM_TOM_TGC0_GLB_CTRL_UPEN_CTRL0_OFF);
80002516:	3b 00 01 60 	mov %d6,16
8000251a:	82 04       	mov %d4,0
8000251c:	6d 00 98 0a 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
80002520:	59 c2 34 00 	st.w [%a12]52,%d2
            driver->tgcGlobalControlApplyUpdate[0]   = IfxGtm_Tom_Tgc_buildFeature(driver->channelsMask[0], 0, IFX_GTM_TOM_TGC0_GLB_CTRL_UPEN_CTRL0_OFF);
80002524:	3b 00 01 60 	mov %d6,16
80002528:	82 05       	mov %d5,0
8000252a:	b9 c4 2c 00 	ld.hu %d4,[%a12]44
8000252e:	6d 00 8f 0a 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
80002532:	59 c2 3c 00 	st.w [%a12]60,%d2
80002536:	00 90       	ret 
            driver->channelsMask[1]                 |= 1 << (channel - IfxGtm_Tom_Ch_8);
80002538:	c2 84       	add %d4,-8
8000253a:	c9 42 2e 00 	ld.h %d2,[%a4]46
8000253e:	d7 12 01 24 	insert %d2,%d2,1,%d4,1
80002542:	37 02 70 50 	extr.u %d5,%d2,0,16
80002546:	f9 45 2e 00 	st.h [%a4]46,%d5
            driver->tgcGlobalControlDisableUpdate[1] = IfxGtm_Tom_Tgc_buildFeature(0, driver->channelsMask[1], IFX_GTM_TOM_TGC0_GLB_CTRL_UPEN_CTRL0_OFF);
8000254a:	3b 00 01 60 	mov %d6,16
8000254e:	82 04       	mov %d4,0
80002550:	6d 00 7e 0a 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
80002554:	59 c2 38 00 	st.w [%a12]56,%d2
            driver->tgcGlobalControlApplyUpdate[1]   = IfxGtm_Tom_Tgc_buildFeature(driver->channelsMask[1], 0, IFX_GTM_TOM_TGC0_GLB_CTRL_UPEN_CTRL0_OFF);
80002558:	3b 00 01 60 	mov %d6,16
8000255c:	82 05       	mov %d5,0
8000255e:	b9 c4 2e 00 	ld.hu %d4,[%a12]46
80002562:	6d 00 75 0a 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
80002566:	59 c2 00 10 	st.w [%a12]64,%d2
8000256a:	00 90       	ret 
        driver->channelsMask[0]                 |= 1 << (channel - IfxGtm_Tom_Ch_8);
8000256c:	c2 84       	add %d4,-8
8000256e:	c9 42 2c 00 	ld.h %d2,[%a4]44
80002572:	d7 12 01 24 	insert %d2,%d2,1,%d4,1
80002576:	37 02 70 50 	extr.u %d5,%d2,0,16
8000257a:	f9 45 2c 00 	st.h [%a4]44,%d5
        driver->tgcGlobalControlDisableUpdate[0] = IfxGtm_Tom_Tgc_buildFeature(0, driver->channelsMask[0], IFX_GTM_TOM_TGC0_GLB_CTRL_UPEN_CTRL0_OFF);
8000257e:	3b 00 01 60 	mov %d6,16
80002582:	82 04       	mov %d4,0
80002584:	6d 00 64 0a 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
80002588:	59 c2 34 00 	st.w [%a12]52,%d2
        driver->tgcGlobalControlApplyUpdate[0]   = IfxGtm_Tom_Tgc_buildFeature(driver->channelsMask[0], 0, IFX_GTM_TOM_TGC0_GLB_CTRL_UPEN_CTRL0_OFF);
8000258c:	3b 00 01 60 	mov %d6,16
80002590:	82 05       	mov %d5,0
80002592:	b9 c4 2c 00 	ld.hu %d4,[%a12]44
80002596:	6d 00 5b 0a 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
8000259a:	59 c2 3c 00 	st.w [%a12]60,%d2
}
8000259e:	00 90       	ret 

800025a0 <IfxGtm_Tom_Timer_getOffset>:
{
800025a0:	40 ae       	mov.aa %a14,%sp
}
800025a2:	19 42 30 00 	ld.w %d2,[%a4]48
800025a6:	00 90       	ret 

800025a8 <IfxGtm_Tom_Timer_init>:
{
800025a8:	40 ae       	mov.aa %a14,%sp
800025aa:	40 4c       	mov.aa %a12,%a4
800025ac:	40 5d       	mov.aa %a13,%a5
    driver->gtm          = config->gtm;
800025ae:	d9 53 34 00 	lea %a3,[%a5]52
800025b2:	19 52 34 00 	ld.w %d2,[%a5]52
800025b6:	59 42 10 00 	st.w [%a4]16,%d2
    driver->tomIndex     = config->tom;
800025ba:	19 52 38 00 	ld.w %d2,[%a5]56
800025be:	59 42 20 00 	st.w [%a4]32,%d2
    driver->tom          = &config->gtm->TOM[config->tom];
800025c2:	1b 02 01 20 	addi %d2,%d2,16
800025c6:	8f b2 00 20 	sh %d2,%d2,11
800025ca:	54 33       	ld.w %d3,[%a3]
800025cc:	0b 23 00 50 	add %d5,%d3,%d2
800025d0:	59 45 14 00 	st.w [%a4]20,%d5
    driver->timerChannel = config->timerChannel;
800025d4:	19 54 3c 00 	ld.w %d4,[%a5]60
800025d8:	59 44 24 00 	st.w [%a4]36,%d4
    base->triggerEnabled = config->base.trigger.enabled;
800025dc:	39 52 10 00 	ld.bu %d2,[%a5]16
800025e0:	e9 42 04 00 	st.b [%a4]4,%d2
    if (base->triggerEnabled)
800025e4:	df 02 0d 00 	jeq %d2,0,800025fe <IfxGtm_Tom_Timer_init+0x56>
        if (config->triggerOut != NULL_PTR)
800025e8:	99 52 00 10 	ld.a %a2,[%a5]64
800025ec:	bd 02 5b 00 	jz.a %a2,800026a2 <IfxGtm_Tom_Timer_init+0xfa>
            driver->triggerChannel = config->triggerOut->channel;
800025f0:	19 22 04 00 	ld.w %d2,[%a2]4
800025f4:	59 42 28 00 	st.w [%a4]40,%d2
    boolean                result = TRUE;
800025f8:	82 18       	mov %d8,1
800025fa:	1d 00 05 00 	j 80002604 <IfxGtm_Tom_Timer_init+0x5c>
        driver->triggerChannel = driver->timerChannel; // Set to timer channel to disable its use
800025fe:	59 44 28 00 	st.w [%a4]40,%d4
    boolean                result = TRUE;
80002602:	82 18       	mov %d8,1
    if (config->timerChannel <= 7)
80002604:	19 d2 3c 00 	ld.w %d2,[%a13]60
80002608:	8b 82 80 22 	ge %d2,%d2,8
8000260c:	df 02 4e 80 	jne %d2,0,800026a8 <IfxGtm_Tom_Timer_init+0x100>
        pointer = (Ifx_GTM_TOM_TGC *)&tom->TGC0_GLB_CTRL;
80002610:	1b 05 03 20 	addi %d2,%d5,48
        driver->tgc[0] = IfxGtm_Tom_Ch_getTgcPointer(driver->tom, 0);
80002614:	59 c2 18 00 	st.w [%a12]24,%d2
        pointer = (Ifx_GTM_TOM_TGC *)&tom->TGC1_GLB_CTRL;
80002618:	1b 05 23 20 	addi %d2,%d5,560
        driver->tgc[1] = IfxGtm_Tom_Ch_getTgcPointer(driver->tom, 1);
8000261c:	59 c2 1c 00 	st.w [%a12]28,%d2
    driver->channelsMask[0]                  = 0;
80002620:	82 02       	mov %d2,0
80002622:	f9 c2 2c 00 	st.h [%a12]44,%d2
    driver->tgcGlobalControlApplyUpdate[0]   = 0;
80002626:	82 03       	mov %d3,0
80002628:	59 c3 3c 00 	st.w [%a12]60,%d3
    driver->tgcGlobalControlDisableUpdate[0] = 0;
8000262c:	59 c3 34 00 	st.w [%a12]52,%d3
    driver->channelsMask[1]                  = 0;
80002630:	f9 c3 2e 00 	st.h [%a12]46,%d3
    driver->tgcGlobalControlApplyUpdate[1]   = 0;
80002634:	59 c3 00 10 	st.w [%a12]64,%d3
    driver->tgcGlobalControlDisableUpdate[1] = 0;
80002638:	59 c3 38 00 	st.w [%a12]56,%d3
    IfxGtm_Tom_Ch_setClockSource(driver->tom, driver->timerChannel, config->clock);
8000263c:	19 d6 04 10 	ld.w %d6,[%a13]68
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002640:	06 64       	sh %d4,6
80002642:	60 52       	mov.a %a2,%d5
80002644:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->CTRL.B.CLK_SRC_SR = (uint8)clock;
80002648:	54 23       	ld.w %d3,[%a2]
8000264a:	37 63 03 36 	insert %d3,%d3,%d6,12,3
8000264e:	74 23       	st.w [%a2],%d3
    IfxGtm_Tom_Ch_setTriggerOutput(driver->tom, driver->timerChannel, IfxGtm_Tom_Ch_OutputTrigger_generate);
80002650:	19 c2 24 00 	ld.w %d2,[%a12]36
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002654:	06 62       	sh %d2,6
80002656:	99 c2 14 00 	ld.a %a2,[%a12]20
8000265a:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
    tomCh->CTRL.B.TRIGOUT = (uint8)trigger;
8000265e:	54 23       	ld.w %d3,[%a2]
80002660:	b7 13 01 3c 	insert %d3,%d3,1,24,1
80002664:	74 23       	st.w [%a2],%d3
    IfxGtm_Tom_Timer_updateInputFrequency(driver);
80002666:	40 c4       	mov.aa %a4,%a12
80002668:	6d ff 14 ff 	call 80002490 <IfxGtm_Tom_Timer_updateInputFrequency>
    if ((config->base.minResolution > 0) && ((1.0f / base->clockFreq) > config->base.minResolution))
8000266c:	19 d2 0c 00 	ld.w %d2,[%a13]12
80002670:	82 03       	mov %d3,0
80002672:	4b 32 01 30 	cmp.f %d3,%d2,%d3
80002676:	6f 23 0d 00 	jz.t %d3,2,80002690 <IfxGtm_Tom_Timer_init+0xe8>
8000267a:	19 c4 08 00 	ld.w %d4,[%a12]8
8000267e:	7b 00 f8 33 	movh %d3,16256
80002682:	4b 43 51 30 	div.f %d3,%d3,%d4
80002686:	4b 32 01 20 	cmp.f %d2,%d2,%d3
8000268a:	6f 02 03 00 	jz.t %d2,0,80002690 <IfxGtm_Tom_Timer_init+0xe8>
        result = FALSE;
8000268e:	82 08       	mov %d8,0
    result &= IfxGtm_Tom_Timer_setFrequency(driver, config->base.frequency);
80002690:	54 d4       	ld.w %d4,[%a13]
80002692:	40 c4       	mov.aa %a4,%a12
80002694:	6d ff bb fe 	call 8000240a <IfxGtm_Tom_Timer_setFrequency>
80002698:	26 28       	and %d8,%d2
    if (result == TRUE)
8000269a:	df 08 10 80 	jne %d8,0,800026ba <IfxGtm_Tom_Timer_init+0x112>
}
8000269e:	02 82       	mov %d2,%d8
800026a0:	00 90       	ret 
            result = FALSE;
800026a2:	82 08       	mov %d8,0
800026a4:	1d ff b0 ff 	j 80002604 <IfxGtm_Tom_Timer_init+0x5c>
        pointer = (Ifx_GTM_TOM_TGC *)&tom->TGC1_GLB_CTRL;
800026a8:	1b 05 23 20 	addi %d2,%d5,560
        driver->tgc[0] = IfxGtm_Tom_Ch_getTgcPointer(driver->tom, 1);
800026ac:	59 c2 18 00 	st.w [%a12]24,%d2
        driver->tgc[1] = NULL_PTR; /* NOTE currently no concatenation between TOMs */
800026b0:	82 02       	mov %d2,0
800026b2:	59 c2 1c 00 	st.w [%a12]28,%d2
800026b6:	1d ff b5 ff 	j 80002620 <IfxGtm_Tom_Timer_init+0x78>
        driver->offset = IfxStdIf_Timer_sToTick(driver->base.clockFreq, 1.0f / config->base.frequency * config->base.startOffset);
800026ba:	19 c3 08 00 	ld.w %d3,[%a12]8
800026be:	54 d4       	ld.w %d4,[%a13]
800026c0:	7b 00 f8 23 	movh %d2,16256
800026c4:	4b 42 51 20 	div.f %d2,%d2,%d4
800026c8:	19 d4 30 00 	ld.w %d4,[%a13]48
800026cc:	4b 42 41 20 	mul.f %d2,%d2,%d4
800026d0:	4b 23 41 20 	mul.f %d2,%d3,%d2
800026d4:	4b 02 71 21 	ftouz %d2,%d2
800026d8:	59 c2 30 00 	st.w [%a12]48,%d2
        IfxGtm_Tom_Ch_setCounterValue(driver->tom, driver->timerChannel, driver->offset);
800026dc:	19 c3 24 00 	ld.w %d3,[%a12]36
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800026e0:	06 63       	sh %d3,6
800026e2:	99 c2 14 00 	ld.a %a2,[%a12]20
800026e6:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
    tomCh->CN0.U = value;
800026ea:	59 22 14 00 	st.w [%a2]20,%d2
        maskShift = (config->timerChannel <= 7) ? 0 : 8;
800026ee:	19 d2 3c 00 	ld.w %d2,[%a13]60
800026f2:	8b 82 80 22 	ge %d2,%d2,8
800026f6:	df 02 53 80 	jne %d2,0,8000279c <IfxGtm_Tom_Timer_init+0x1f4>
800026fa:	82 09       	mov %d9,0
        IfxGtm_Tom_Timer_addToChannelMask(driver, driver->timerChannel);
800026fc:	19 c4 24 00 	ld.w %d4,[%a12]36
80002700:	40 c4       	mov.aa %a4,%a12
80002702:	6d ff f6 fe 	call 800024ee <IfxGtm_Tom_Timer_addToChannelMask>
        if (base->triggerEnabled)
80002706:	39 c2 04 00 	ld.bu %d2,[%a12]4
8000270a:	df 02 3a 00 	jeq %d2,0,8000277e <IfxGtm_Tom_Timer_init+0x1d6>
            IfxGtm_Tom_Ch triggerChannel     = driver->triggerChannel;
8000270e:	19 c3 28 00 	ld.w %d3,[%a12]40
            uint16        triggerChannelMask = 1 << (triggerChannel - maskShift);
80002712:	0b 93 80 20 	sub %d2,%d3,%d9
80002716:	82 19       	mov %d9,1
80002718:	0f 29 00 90 	sh %d9,%d9,%d2
            IfxGtm_Tom_Ch_setSignalLevel(driver->tom, triggerChannel, config->base.trigger.risingEdgeAtPeriod ? Ifx_ActiveState_high : Ifx_ActiveState_low);
8000271c:	39 d2 28 00 	ld.bu %d2,[%a13]40
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002720:	8f 63 00 40 	sh %d4,%d3,6
80002724:	99 c2 14 00 	ld.a %a2,[%a12]20
80002728:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
8000272c:	df 02 3c 80 	jne %d2,0,800027a4 <IfxGtm_Tom_Timer_init+0x1fc>
80002730:	82 05       	mov %d5,0
80002732:	54 22       	ld.w %d2,[%a2]
80002734:	67 52 0b 20 	ins.t %d2,%d2,11,%d5,0
80002738:	74 22       	st.w [%a2],%d2
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
8000273a:	99 c2 14 00 	ld.a %a2,[%a12]20
8000273e:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->CN0.U = value;
80002742:	19 c2 30 00 	ld.w %d2,[%a12]48
80002746:	59 22 14 00 	st.w [%a2]20,%d2
            if (triggerChannel != driver->timerChannel)
8000274a:	19 c2 24 00 	ld.w %d2,[%a12]36
8000274e:	5f 32 2e 80 	jne %d2,%d3,800027aa <IfxGtm_Tom_Timer_init+0x202>
            IfxGtm_Tom_Tgc_enableChannelsOutput(driver->tgc[0], triggerChannelMask, 0, FALSE);
80002752:	cc c6       	ld.a %a15,[%a12]24
    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_OUTEN_CTRL_OUTEN_CTRL0_OFF);
80002754:	82 06       	mov %d6,0
80002756:	82 05       	mov %d5,0
80002758:	37 09 70 40 	extr.u %d4,%d9,0,16
8000275c:	6d 00 78 09 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
        tgc->OUTEN_CTRL.U = value;
80002760:	59 f2 08 10 	st.w [%a15]72,%d2
            if ((config->base.trigger.outputEnabled) && (config->initPins == TRUE))
80002764:	39 d2 29 00 	ld.bu %d2,[%a13]41
80002768:	df 02 06 00 	jeq %d2,0,80002774 <IfxGtm_Tom_Timer_init+0x1cc>
8000276c:	39 d2 10 10 	ld.bu %d2,[%a13]80
80002770:	df 12 47 00 	jeq %d2,1,800027fe <IfxGtm_Tom_Timer_init+0x256>
            IfxGtm_Tom_Timer_setTrigger(driver, config->base.trigger.triggerPoint);
80002774:	19 d4 14 00 	ld.w %d4,[%a13]20
80002778:	40 c4       	mov.aa %a4,%a12
8000277a:	6d ff 5d fe 	call 80002434 <IfxGtm_Tom_Timer_setTrigger>
            boolean                timerHasIrq   = config->base.isrPriority > 0;
8000277e:	b9 d2 04 00 	ld.hu %d2,[%a13]4
80002782:	8b 02 20 62 	ne %d6,%d2,0
            boolean                triggerHasIrq = (config->base.trigger.isrPriority > 0) && base->triggerEnabled;
80002786:	b9 d3 18 00 	ld.hu %d3,[%a13]24
8000278a:	df 03 44 00 	jeq %d3,0,80002812 <IfxGtm_Tom_Timer_init+0x26a>
8000278e:	39 c3 04 00 	ld.bu %d3,[%a12]4
80002792:	df 03 ce 80 	jne %d3,0,8000292e <IfxGtm_Tom_Timer_init+0x386>
80002796:	82 05       	mov %d5,0
80002798:	1d 00 3e 00 	j 80002814 <IfxGtm_Tom_Timer_init+0x26c>
        maskShift = (config->timerChannel <= 7) ? 0 : 8;
8000279c:	3b 80 00 90 	mov %d9,8
800027a0:	1d ff ae ff 	j 800026fc <IfxGtm_Tom_Timer_init+0x154>
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
800027a4:	82 15       	mov %d5,1
800027a6:	1d ff c6 ff 	j 80002732 <IfxGtm_Tom_Timer_init+0x18a>
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800027aa:	99 c2 14 00 	ld.a %a2,[%a12]20
800027ae:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->CTRL.B.RST_CCU0 = (uint8)event;
800027b2:	54 22       	ld.w %d2,[%a2]
800027b4:	b7 12 01 2a 	insert %d2,%d2,1,20,1
800027b8:	74 22       	st.w [%a2],%d2
                IfxGtm_Tom_Ch_setClockSource(driver->tom, triggerChannel, config->clock);
800027ba:	19 d3 04 10 	ld.w %d3,[%a13]68
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800027be:	99 c2 14 00 	ld.a %a2,[%a12]20
800027c2:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->CTRL.B.CLK_SRC_SR = (uint8)clock;
800027c6:	54 22       	ld.w %d2,[%a2]
800027c8:	37 32 03 26 	insert %d2,%d2,%d3,12,3
800027cc:	74 22       	st.w [%a2],%d2
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800027ce:	99 c2 14 00 	ld.a %a2,[%a12]20
800027d2:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->CTRL.B.TRIGOUT = (uint8)trigger;
800027d6:	54 22       	ld.w %d2,[%a2]
800027d8:	b7 02 01 2c 	insert %d2,%d2,0,24,1
800027dc:	74 22       	st.w [%a2],%d2
                IfxGtm_Tom_Tgc_enableChannels(driver->tgc[0], triggerChannelMask, 0, FALSE);
800027de:	cc c6       	ld.a %a15,[%a12]24
    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_ENDIS_CTRL_ENDIS_CTRL0_OFF);
800027e0:	82 06       	mov %d6,0
800027e2:	82 05       	mov %d5,0
800027e4:	37 09 70 40 	extr.u %d4,%d9,0,16
800027e8:	6d 00 32 09 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
        tgc->ENDIS_CTRL.U = value;
800027ec:	59 f2 00 10 	st.w [%a15]64,%d2
                IfxGtm_Tom_Timer_addToChannelMask(driver, driver->triggerChannel);
800027f0:	19 c4 28 00 	ld.w %d4,[%a12]40
800027f4:	40 c4       	mov.aa %a4,%a12
800027f6:	6d ff 7c fe 	call 800024ee <IfxGtm_Tom_Timer_addToChannelMask>
800027fa:	1d ff ac ff 	j 80002752 <IfxGtm_Tom_Timer_init+0x1aa>
                IfxGtm_PinMap_setTomTout(config->triggerOut, config->base.trigger.outputMode, config->base.trigger.outputDriver);
800027fe:	19 d5 24 00 	ld.w %d5,[%a13]36
80002802:	19 d4 20 00 	ld.w %d4,[%a13]32
80002806:	99 d4 00 10 	ld.a %a4,[%a13]64
8000280a:	6d ff 8d f1 	call 80000b24 <IfxGtm_PinMap_setTomTout>
8000280e:	1d ff b3 ff 	j 80002774 <IfxGtm_Tom_Timer_init+0x1cc>
            boolean                triggerHasIrq = (config->base.trigger.isrPriority > 0) && base->triggerEnabled;
80002812:	82 05       	mov %d5,0
80002814:	8f f5 0f 51 	and %d5,%d5,255
            if (driver->triggerChannel == driver->timerChannel)
80002818:	19 c4 28 00 	ld.w %d4,[%a12]40
8000281c:	19 c3 24 00 	ld.w %d3,[%a12]36
80002820:	5f 34 8a 00 	jeq %d4,%d3,80002934 <IfxGtm_Tom_Timer_init+0x38c>
                if (timerHasIrq)
80002824:	df 02 41 00 	jeq %d2,0,800028a6 <IfxGtm_Tom_Timer_init+0x2fe>
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002828:	06 63       	sh %d3,6
8000282a:	99 c2 14 00 	ld.a %a2,[%a12]20
8000282e:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
    en.U = tomCh->IRQ_EN.U;
80002832:	d9 23 20 00 	lea %a3,[%a2]32
80002836:	19 24 20 00 	ld.w %d4,[%a2]32
8000283a:	02 42       	mov %d2,%d4
    tomCh->IRQ_EN.U            = IFX_ZEROS;
8000283c:	82 03       	mov %d3,0
8000283e:	74 33       	st.w [%a3],%d3
    tomCh->IRQ_MODE.B.IRQ_MODE = mode;
80002840:	d9 23 28 00 	lea %a3,[%a2]40
80002844:	19 23 28 00 	ld.w %d3,[%a2]40
80002848:	b7 23 02 30 	insert %d3,%d3,2,0,2
8000284c:	74 33       	st.w [%a3],%d3
    tomCh->IRQ_EN.U            = en.U; /* Set the values back */
8000284e:	d9 23 20 00 	lea %a3,[%a2]32
80002852:	59 24 20 00 	st.w [%a2]32,%d4
    en.B.CCU0TC_IRQ_EN         = interruptOnCompareZero ? 1 : 0;
80002856:	b7 12 01 20 	insert %d2,%d2,1,0,1
    en.B.CCU1TC_IRQ_EN         = interruptOnCompareOne ? 1 : 0;
8000285a:	8f 22 c0 21 	andn %d2,%d2,2
    tomCh->IRQ_EN.U            = en.U;
8000285e:	74 32       	st.w [%a3],%d2
                    src = IfxGtm_Tom_Ch_getSrcPointer(driver->gtm, config->tom, driver->timerChannel);
80002860:	19 d3 38 00 	ld.w %d3,[%a13]56
80002864:	19 c2 24 00 	ld.w %d2,[%a12]36
    return &MODULE_SRC.GTM.GTM[0].TOM[tom][channel >> 1];
80002868:	86 f2       	sha %d2,-1
8000286a:	06 33       	sh %d3,3
8000286c:	42 32       	add %d2,%d3
8000286e:	06 22       	sh %d2,2
80002870:	7b 40 00 3f 	movh %d3,61444
80002874:	1b 03 b8 39 	addi %d3,%d3,-25728
80002878:	60 32       	mov.a %a2,%d3
8000287a:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
                    IfxSrc_init(src, config->base.isrProvider, config->base.isrPriority);
8000287e:	19 d4 08 00 	ld.w %d4,[%a13]8
    src->B.SRPN = priority;
80002882:	39 d3 04 00 	ld.bu %d3,[%a13]4
80002886:	54 22       	ld.w %d2,[%a2]
80002888:	37 32 08 20 	insert %d2,%d2,%d3,0,8
8000288c:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
8000288e:	54 22       	ld.w %d2,[%a2]
80002890:	37 42 82 25 	insert %d2,%d2,%d4,11,2
80002894:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
80002896:	54 22       	ld.w %d2,[%a2]
80002898:	b7 12 81 2c 	insert %d2,%d2,1,25,1
8000289c:	74 22       	st.w [%a2],%d2
    src->B.SRE = 1;
8000289e:	54 22       	ld.w %d2,[%a2]
800028a0:	b7 12 01 25 	insert %d2,%d2,1,10,1
800028a4:	74 22       	st.w [%a2],%d2
                if (triggerHasIrq)
800028a6:	df 05 8f 00 	jeq %d5,0,800029c4 <IfxGtm_Tom_Timer_init+0x41c>
                    IfxGtm_Tom_Ch_setNotification(driver->tom, driver->triggerChannel, irqMode, FALSE, TRUE);
800028aa:	19 c2 28 00 	ld.w %d2,[%a12]40
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800028ae:	06 62       	sh %d2,6
800028b0:	99 c2 14 00 	ld.a %a2,[%a12]20
800028b4:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
    en.U = tomCh->IRQ_EN.U;
800028b8:	d9 23 20 00 	lea %a3,[%a2]32
800028bc:	19 23 20 00 	ld.w %d3,[%a2]32
    tomCh->IRQ_EN.U            = IFX_ZEROS;
800028c0:	82 02       	mov %d2,0
800028c2:	74 32       	st.w [%a3],%d2
    tomCh->IRQ_MODE.B.IRQ_MODE = mode;
800028c4:	d9 23 28 00 	lea %a3,[%a2]40
800028c8:	19 22 28 00 	ld.w %d2,[%a2]40
800028cc:	b7 22 02 20 	insert %d2,%d2,2,0,2
800028d0:	74 32       	st.w [%a3],%d2
    tomCh->IRQ_EN.U            = en.U; /* Set the values back */
800028d2:	d9 23 20 00 	lea %a3,[%a2]32
800028d6:	59 23 20 00 	st.w [%a2]32,%d3
    en.B.CCU0TC_IRQ_EN         = interruptOnCompareZero ? 1 : 0;
800028da:	8f 13 c0 31 	andn %d3,%d3,1
    en.B.CCU1TC_IRQ_EN         = interruptOnCompareOne ? 1 : 0;
800028de:	b7 13 81 30 	insert %d3,%d3,1,1,1
    tomCh->IRQ_EN.U            = en.U;
800028e2:	74 33       	st.w [%a3],%d3
                    src = IfxGtm_Tom_Ch_getSrcPointer(driver->gtm, config->tom, driver->triggerChannel);
800028e4:	19 d3 38 00 	ld.w %d3,[%a13]56
800028e8:	19 c2 28 00 	ld.w %d2,[%a12]40
    return &MODULE_SRC.GTM.GTM[0].TOM[tom][channel >> 1];
800028ec:	86 f2       	sha %d2,-1
800028ee:	06 33       	sh %d3,3
800028f0:	42 32       	add %d2,%d3
800028f2:	06 22       	sh %d2,2
800028f4:	7b 40 00 3f 	movh %d3,61444
800028f8:	1b 03 b8 39 	addi %d3,%d3,-25728
800028fc:	60 32       	mov.a %a2,%d3
800028fe:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
                    IfxSrc_init(src, config->base.trigger.isrProvider, config->base.trigger.isrPriority);
80002902:	19 d4 1c 00 	ld.w %d4,[%a13]28
    src->B.SRPN = priority;
80002906:	39 d3 18 00 	ld.bu %d3,[%a13]24
8000290a:	54 22       	ld.w %d2,[%a2]
8000290c:	37 32 08 20 	insert %d2,%d2,%d3,0,8
80002910:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80002912:	54 22       	ld.w %d2,[%a2]
80002914:	37 42 82 25 	insert %d2,%d2,%d4,11,2
80002918:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
8000291a:	54 22       	ld.w %d2,[%a2]
8000291c:	b7 12 81 2c 	insert %d2,%d2,1,25,1
80002920:	74 22       	st.w [%a2],%d2
    src->B.SRE = 1;
80002922:	54 22       	ld.w %d2,[%a2]
80002924:	b7 12 01 25 	insert %d2,%d2,1,10,1
80002928:	74 22       	st.w [%a2],%d2
}
8000292a:	1d 00 4d 00 	j 800029c4 <IfxGtm_Tom_Timer_init+0x41c>
            boolean                triggerHasIrq = (config->base.trigger.isrPriority > 0) && base->triggerEnabled;
8000292e:	82 15       	mov %d5,1
80002930:	1d ff 72 ff 	j 80002814 <IfxGtm_Tom_Timer_init+0x26c>
                IfxGtm_Tom_Ch_setNotification(driver->tom, driver->timerChannel, timerHasIrq ? config->irqModeTimer : config->irqModeTrigger, timerHasIrq, triggerHasIrq);
80002934:	19 c4 14 00 	ld.w %d4,[%a12]20
80002938:	df 02 70 00 	jeq %d2,0,80002a18 <IfxGtm_Tom_Timer_init+0x470>
8000293c:	19 d7 08 10 	ld.w %d7,[%a13]72
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002940:	06 63       	sh %d3,6
80002942:	60 42       	mov.a %a2,%d4
80002944:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
    en.U = tomCh->IRQ_EN.U;
80002948:	d9 23 20 00 	lea %a3,[%a2]32
8000294c:	19 20 20 00 	ld.w %d0,[%a2]32
80002950:	02 03       	mov %d3,%d0
    tomCh->IRQ_EN.U            = IFX_ZEROS;
80002952:	82 04       	mov %d4,0
80002954:	74 34       	st.w [%a3],%d4
    tomCh->IRQ_MODE.B.IRQ_MODE = mode;
80002956:	d9 23 28 00 	lea %a3,[%a2]40
8000295a:	19 24 28 00 	ld.w %d4,[%a2]40
8000295e:	37 74 02 40 	insert %d4,%d4,%d7,0,2
80002962:	74 34       	st.w [%a3],%d4
    tomCh->IRQ_EN.U            = en.U; /* Set the values back */
80002964:	d9 23 20 00 	lea %a3,[%a2]32
80002968:	59 20 20 00 	st.w [%a2]32,%d0
    en.B.CCU0TC_IRQ_EN         = interruptOnCompareZero ? 1 : 0;
8000296c:	67 63 00 30 	ins.t %d3,%d3,0,%d6,0
    en.B.CCU1TC_IRQ_EN         = interruptOnCompareOne ? 1 : 0;
80002970:	67 53 01 30 	ins.t %d3,%d3,1,%d5,0
    tomCh->IRQ_EN.U            = en.U;
80002974:	74 33       	st.w [%a3],%d3
                src = IfxGtm_Tom_Ch_getSrcPointer(driver->gtm, config->tom, driver->timerChannel);
80002976:	19 d4 38 00 	ld.w %d4,[%a13]56
8000297a:	19 c3 24 00 	ld.w %d3,[%a12]36
    return &MODULE_SRC.GTM.GTM[0].TOM[tom][channel >> 1];
8000297e:	86 f3       	sha %d3,-1
80002980:	06 34       	sh %d4,3
80002982:	42 43       	add %d3,%d4
80002984:	06 23       	sh %d3,2
80002986:	7b 40 00 4f 	movh %d4,61444
8000298a:	1b 04 b8 49 	addi %d4,%d4,-25728
8000298e:	60 42       	mov.a %a2,%d4
80002990:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
                IfxSrc_init(src, timerHasIrq ? config->base.isrProvider : config->base.trigger.isrProvider, timerHasIrq ? config->base.isrPriority : config->base.trigger.isrPriority);
80002994:	df 02 46 00 	jeq %d2,0,80002a20 <IfxGtm_Tom_Timer_init+0x478>
80002998:	19 d4 08 00 	ld.w %d4,[%a13]8
8000299c:	df 02 46 00 	jeq %d2,0,80002a28 <IfxGtm_Tom_Timer_init+0x480>
800029a0:	b9 d3 04 00 	ld.hu %d3,[%a13]4
    src->B.SRPN = priority;
800029a4:	54 22       	ld.w %d2,[%a2]
800029a6:	37 32 08 20 	insert %d2,%d2,%d3,0,8
800029aa:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
800029ac:	54 22       	ld.w %d2,[%a2]
800029ae:	37 42 82 25 	insert %d2,%d2,%d4,11,2
800029b2:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
800029b4:	54 22       	ld.w %d2,[%a2]
800029b6:	b7 12 81 2c 	insert %d2,%d2,1,25,1
800029ba:	74 22       	st.w [%a2],%d2
    src->B.SRE = 1;
800029bc:	54 22       	ld.w %d2,[%a2]
800029be:	b7 12 01 25 	insert %d2,%d2,1,10,1
800029c2:	74 22       	st.w [%a2],%d2
        IfxGtm_Tom_Tgc_setChannelsForceUpdate(driver->tgc[0], driver->channelsMask[0], 0, 0, 0);
800029c4:	99 cd 18 00 	ld.a %a13,[%a12]24
    regEnable        = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_FUPD_CTRL0_OFF);
800029c8:	82 06       	mov %d6,0
800029ca:	82 05       	mov %d5,0
800029cc:	b9 c4 2c 00 	ld.hu %d4,[%a12]44
800029d0:	6d 00 3e 08 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
800029d4:	02 29       	mov %d9,%d2
    regReset         = IfxGtm_Tom_Tgc_buildFeature(resetEnableMask, resetDisableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_RSTCN0_CH0_OFF);
800029d6:	3b 00 01 60 	mov %d6,16
800029da:	82 05       	mov %d5,0
800029dc:	82 04       	mov %d4,0
800029de:	6d 00 37 08 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
    tgc->FUPD_CTRL.U = regEnable | regReset;
800029e2:	a6 92       	or %d2,%d9
800029e4:	59 d2 08 00 	st.w [%a13]8,%d2
        IfxGtm_Tom_Tgc_trigger(driver->tgc[0]);
800029e8:	99 c2 18 00 	ld.a %a2,[%a12]24
    tgc->GLB_CTRL.U = 1 << IFX_GTM_TOM_TGC0_GLB_CTRL_HOST_TRIG_OFF;
800029ec:	82 12       	mov %d2,1
800029ee:	74 22       	st.w [%a2],%d2
        IfxGtm_Tom_Tgc_setChannelsForceUpdate(driver->tgc[0], 0, driver->channelsMask[0], 0, 0);
800029f0:	99 cd 18 00 	ld.a %a13,[%a12]24
    regEnable        = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_FUPD_CTRL0_OFF);
800029f4:	82 06       	mov %d6,0
800029f6:	b9 c5 2c 00 	ld.hu %d5,[%a12]44
800029fa:	82 04       	mov %d4,0
800029fc:	6d 00 28 08 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
80002a00:	02 29       	mov %d9,%d2
    regReset         = IfxGtm_Tom_Tgc_buildFeature(resetEnableMask, resetDisableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_RSTCN0_CH0_OFF);
80002a02:	3b 00 01 60 	mov %d6,16
80002a06:	82 05       	mov %d5,0
80002a08:	82 04       	mov %d4,0
80002a0a:	6d 00 21 08 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
    tgc->FUPD_CTRL.U = regEnable | regReset;
80002a0e:	a6 92       	or %d2,%d9
80002a10:	59 d2 08 00 	st.w [%a13]8,%d2
}
80002a14:	1d ff 45 fe 	j 8000269e <IfxGtm_Tom_Timer_init+0xf6>
                IfxGtm_Tom_Ch_setNotification(driver->tom, driver->timerChannel, timerHasIrq ? config->irqModeTimer : config->irqModeTrigger, timerHasIrq, triggerHasIrq);
80002a18:	19 d7 0c 10 	ld.w %d7,[%a13]76
80002a1c:	1d ff 92 ff 	j 80002940 <IfxGtm_Tom_Timer_init+0x398>
                IfxSrc_init(src, timerHasIrq ? config->base.isrProvider : config->base.trigger.isrProvider, timerHasIrq ? config->base.isrPriority : config->base.trigger.isrPriority);
80002a20:	19 d4 1c 00 	ld.w %d4,[%a13]28
80002a24:	1d ff bc ff 	j 8000299c <IfxGtm_Tom_Timer_init+0x3f4>
80002a28:	b9 d3 18 00 	ld.hu %d3,[%a13]24
80002a2c:	1d ff bc ff 	j 800029a4 <IfxGtm_Tom_Timer_init+0x3fc>

80002a30 <IfxGtm_Tom_Timer_initConfig>:
{
80002a30:	40 ae       	mov.aa %a14,%sp
80002a32:	40 4c       	mov.aa %a12,%a4
80002a34:	80 58       	mov.d %d8,%a5
    IfxStdIf_Timer_initConfig(&config->base);
80002a36:	6d 00 7d 0e 	call 80004730 <IfxStdIf_Timer_initConfig>
    config->gtm            = gtm;
80002a3a:	59 c8 34 00 	st.w [%a12]52,%d8
    config->tom            = IfxGtm_Tom_0;
80002a3e:	82 02       	mov %d2,0
80002a40:	59 c2 38 00 	st.w [%a12]56,%d2
    config->timerChannel   = IfxGtm_Tom_Ch_0;
80002a44:	59 c2 3c 00 	st.w [%a12]60,%d2
    config->triggerOut     = NULL_PTR;
80002a48:	59 c2 00 10 	st.w [%a12]64,%d2
    config->clock          = IfxGtm_Tom_Ch_ClkSrc_cmuFxclk0;
80002a4c:	59 c2 04 10 	st.w [%a12]68,%d2
    config->base.countDir  = IfxStdIf_Timer_CountDir_up;
80002a50:	59 c2 2c 00 	st.w [%a12]44,%d2
    config->irqModeTimer   = IfxGtm_IrqMode_level;
80002a54:	59 c2 08 10 	st.w [%a12]72,%d2
    config->irqModeTrigger = IfxGtm_IrqMode_level;
80002a58:	59 c2 0c 10 	st.w [%a12]76,%d2
    config->initPins       = TRUE;
80002a5c:	82 12       	mov %d2,1
80002a5e:	e9 c2 10 10 	st.b [%a12]80,%d2
}
80002a62:	00 90       	ret 

80002a64 <IfxGtm_Tom_PwmHl_setDeadtime>:
    config->initPins = TRUE;
}


boolean IfxGtm_Tom_PwmHl_setDeadtime(IfxGtm_Tom_PwmHl *driver, float32 deadtime)
{
80002a64:	40 ae       	mov.aa %a14,%sp
    Ifx_TimerValue value = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, deadtime);
80002a66:	99 42 20 00 	ld.a %a2,[%a4]32
80002a6a:	19 22 08 00 	ld.w %d2,[%a2]8
80002a6e:	4b 42 41 20 	mul.f %d2,%d2,%d4
80002a72:	4b 02 71 21 	ftouz %d2,%d2
    driver->base.deadtime = value;
80002a76:	74 42       	st.w [%a4],%d2

    return TRUE;
}
80002a78:	82 12       	mov %d2,1
80002a7a:	00 90       	ret 

80002a7c <IfxGtm_Tom_PwmHl_setMinPulse>:


boolean IfxGtm_Tom_PwmHl_setMinPulse(IfxGtm_Tom_PwmHl *driver, float32 minPulse)
{
80002a7c:	40 ae       	mov.aa %a14,%sp
    Ifx_TimerValue value = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, minPulse);
80002a7e:	99 42 20 00 	ld.a %a2,[%a4]32
80002a82:	19 22 08 00 	ld.w %d2,[%a2]8
80002a86:	4b 42 41 20 	mul.f %d2,%d2,%d4
80002a8a:	4b 02 71 21 	ftouz %d2,%d2

    driver->base.minPulse = value + driver->base.deadtime;
80002a8e:	54 43       	ld.w %d3,[%a4]
80002a90:	42 32       	add %d2,%d3
80002a92:	59 42 04 00 	st.w [%a4]4,%d2
    driver->base.maxPulse = driver->timer->base.period - driver->base.minPulse;
80002a96:	54 23       	ld.w %d3,[%a2]
80002a98:	0b 23 80 20 	sub %d2,%d3,%d2
80002a9c:	59 42 08 00 	st.w [%a4]8,%d2

    return TRUE;
}
80002aa0:	82 12       	mov %d2,1
80002aa2:	00 90       	ret 

80002aa4 <IfxGtm_Tom_PwmHl_setMode>:


boolean IfxGtm_Tom_PwmHl_setMode(IfxGtm_Tom_PwmHl *driver, Ifx_Pwm_Mode mode)
{
80002aa4:	40 ae       	mov.aa %a14,%sp
    boolean                result = TRUE;
    IfxGtm_Tom_PwmHl_Base *base   = &driver->base;

    if (base->mode != mode)
80002aa6:	19 42 0c 00 	ld.w %d2,[%a4]12
80002aaa:	5f 42 a4 00 	jeq %d2,%d4,80002bf2 <IfxGtm_Tom_PwmHl_setMode+0x14e>
    {
        if ((mode > Ifx_Pwm_Mode_off) || (IfxGtm_Tom_PwmHl_modes[mode].update == NULL_PTR))
80002aae:	ff 54 11 80 	jge.u %d4,5,80002ad0 <IfxGtm_Tom_PwmHl_setMode+0x2c>
80002ab2:	91 00 00 28 	movh.a %a2,32768
80002ab6:	80 22       	mov.d %d2,%a2
80002ab8:	1b 82 42 20 	addi %d2,%d2,1064
80002abc:	13 44 21 22 	madd %d2,%d2,%d4,20
80002ac0:	60 22       	mov.a %a2,%d2
80002ac2:	19 22 08 00 	ld.w %d2,[%a2]8
80002ac6:	df 02 3c 00 	jeq %d2,0,80002b3e <IfxGtm_Tom_PwmHl_setMode+0x9a>
    boolean                result = TRUE;
80002aca:	82 12       	mov %d2,1
80002acc:	1d 00 04 00 	j 80002ad4 <IfxGtm_Tom_PwmHl_setMode+0x30>
        {
            mode   = Ifx_Pwm_Mode_off;
            result = FALSE;
80002ad0:	82 02       	mov %d2,0
            mode   = Ifx_Pwm_Mode_off;
80002ad2:	82 44       	mov %d4,4
        }

        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, mode == IfxGtm_Tom_PwmHl_modes[mode].mode);

        base->mode             = mode;
80002ad4:	59 44 0c 00 	st.w [%a4]12,%d4
        driver->update         = IfxGtm_Tom_PwmHl_modes[mode].update;
80002ad8:	91 00 00 28 	movh.a %a2,32768
80002adc:	80 23       	mov.d %d3,%a2
80002ade:	1b 83 42 30 	addi %d3,%d3,1064
80002ae2:	13 44 21 33 	madd %d3,%d3,%d4,20
80002ae6:	60 32       	mov.a %a2,%d3
80002ae8:	19 23 08 00 	ld.w %d3,[%a2]8
80002aec:	59 43 24 00 	st.w [%a4]36,%d3
        driver->updateAndShift = IfxGtm_Tom_PwmHl_modes[mode].updateAndShift;
80002af0:	19 23 0c 00 	ld.w %d3,[%a2]12
80002af4:	59 43 28 00 	st.w [%a4]40,%d3
        driver->updatePulse    = IfxGtm_Tom_PwmHl_modes[mode].updatePulse;
80002af8:	19 23 10 00 	ld.w %d3,[%a2]16
80002afc:	59 43 2c 00 	st.w [%a4]44,%d3

        if (base->mode != Ifx_Pwm_Mode_off)
80002b00:	df 44 0e 00 	jeq %d4,4,80002b1c <IfxGtm_Tom_PwmHl_setMode+0x78>
        {
            base->inverted = IfxGtm_Tom_PwmHl_modes[mode].inverted;
80002b04:	91 00 00 28 	movh.a %a2,32768
80002b08:	80 23       	mov.d %d3,%a2
80002b0a:	1b 83 42 30 	addi %d3,%d3,1064
80002b0e:	13 44 21 33 	madd %d3,%d3,%d4,20
80002b12:	60 32       	mov.a %a2,%d3
80002b14:	39 23 04 00 	ld.bu %d3,[%a2]4
80002b18:	e9 43 1c 00 	st.b [%a4]28,%d3
        }
        else
        {                       /* Keep previous inverted for off mode */
        }

        if (base->inverted)
80002b1c:	39 43 1c 00 	ld.bu %d3,[%a4]28
80002b20:	df 03 13 00 	jeq %d3,0,80002b46 <IfxGtm_Tom_PwmHl_setMode+0xa2>
        {
            driver->ccxTemp   = driver->coutx;
80002b24:	80 43       	mov.d %d3,%a4
80002b26:	1b 43 04 30 	addi %d3,%d3,68
80002b2a:	59 43 10 10 	st.w [%a4]80,%d3
            driver->coutxTemp = driver->ccx;
80002b2e:	80 43       	mov.d %d3,%a4
80002b30:	1b 83 03 30 	addi %d3,%d3,56
80002b34:	59 43 14 10 	st.w [%a4]84,%d3
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
80002b38:	82 04       	mov %d4,0
80002b3a:	1d 00 3d 00 	j 80002bb4 <IfxGtm_Tom_PwmHl_setMode+0x110>
            result = FALSE;
80002b3e:	82 02       	mov %d2,0
            mode   = Ifx_Pwm_Mode_off;
80002b40:	82 44       	mov %d4,4
80002b42:	1d ff c9 ff 	j 80002ad4 <IfxGtm_Tom_PwmHl_setMode+0x30>
        }
        else
        {
            driver->ccxTemp   = driver->ccx;
80002b46:	80 43       	mov.d %d3,%a4
80002b48:	1b 83 03 30 	addi %d3,%d3,56
80002b4c:	59 43 10 10 	st.w [%a4]80,%d3
            driver->coutxTemp = driver->coutx;
80002b50:	80 43       	mov.d %d3,%a4
80002b52:	1b 43 04 30 	addi %d3,%d3,68
80002b56:	59 43 14 10 	st.w [%a4]84,%d3
80002b5a:	1d ff ef ff 	j 80002b38 <IfxGtm_Tom_PwmHl_setMode+0x94>
                IfxGtm_Tom_Ch channel;

                channel = driver->ccx[channelIndex];
                IfxGtm_Tom_Ch_setSignalLevel(driver->tom, channel, base->inverted
                    ? base->ccxActiveState
                    : IfxGtm_Tom_PwmHl_invertActiveState(driver->base.ccxActiveState));
80002b5e:	19 43 14 00 	ld.w %d3,[%a4]20
    return activeState == Ifx_ActiveState_low ? Ifx_ActiveState_high : Ifx_ActiveState_low;
80002b62:	8b 03 00 32 	eq %d3,%d3,0
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002b66:	06 65       	sh %d5,6
80002b68:	60 62       	mov.a %a2,%d6
80002b6a:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
80002b6e:	df 13 37 00 	jeq %d3,1,80002bdc <IfxGtm_Tom_PwmHl_setMode+0x138>
80002b72:	82 05       	mov %d5,0
80002b74:	54 23       	ld.w %d3,[%a2]
80002b76:	67 53 0b 30 	ins.t %d3,%d3,11,%d5,0
80002b7a:	74 23       	st.w [%a2],%d3

                channel = driver->coutx[channelIndex];
80002b7c:	1b 14 01 30 	addi %d3,%d4,17
80002b80:	06 23       	sh %d3,2
80002b82:	01 43 00 26 	addsc.a %a2,%a4,%d3,0
80002b86:	54 25       	ld.w %d5,[%a2]
                IfxGtm_Tom_Ch_setSignalLevel(driver->tom, channel, base->inverted
80002b88:	19 46 30 00 	ld.w %d6,[%a4]48
80002b8c:	39 43 1c 00 	ld.bu %d3,[%a4]28
80002b90:	df 03 29 00 	jeq %d3,0,80002be2 <IfxGtm_Tom_PwmHl_setMode+0x13e>
                    ? IfxGtm_Tom_PwmHl_invertActiveState(driver->base.coutxActiveState)
80002b94:	19 43 18 00 	ld.w %d3,[%a4]24
    return activeState == Ifx_ActiveState_low ? Ifx_ActiveState_high : Ifx_ActiveState_low;
80002b98:	8b 03 00 32 	eq %d3,%d3,0
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002b9c:	06 65       	sh %d5,6
80002b9e:	60 62       	mov.a %a2,%d6
80002ba0:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
80002ba4:	df 13 23 00 	jeq %d3,1,80002bea <IfxGtm_Tom_PwmHl_setMode+0x146>
80002ba8:	82 05       	mov %d5,0
80002baa:	54 23       	ld.w %d3,[%a2]
80002bac:	67 53 0b 30 	ins.t %d3,%d3,11,%d5,0
80002bb0:	74 23       	st.w [%a2],%d3
            for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
80002bb2:	c2 14       	add %d4,1
80002bb4:	39 43 1d 00 	ld.bu %d3,[%a4]29
80002bb8:	7f 34 1c 80 	jge.u %d4,%d3,80002bf0 <IfxGtm_Tom_PwmHl_setMode+0x14c>
                channel = driver->ccx[channelIndex];
80002bbc:	1b e4 00 30 	addi %d3,%d4,14
80002bc0:	06 23       	sh %d3,2
80002bc2:	01 43 00 26 	addsc.a %a2,%a4,%d3,0
80002bc6:	54 25       	ld.w %d5,[%a2]
                IfxGtm_Tom_Ch_setSignalLevel(driver->tom, channel, base->inverted
80002bc8:	19 46 30 00 	ld.w %d6,[%a4]48
80002bcc:	39 43 1c 00 	ld.bu %d3,[%a4]28
80002bd0:	df 03 c7 7f 	jeq %d3,0,80002b5e <IfxGtm_Tom_PwmHl_setMode+0xba>
80002bd4:	19 43 14 00 	ld.w %d3,[%a4]20
80002bd8:	1d ff c7 ff 	j 80002b66 <IfxGtm_Tom_PwmHl_setMode+0xc2>
80002bdc:	82 15       	mov %d5,1
80002bde:	1d ff cb ff 	j 80002b74 <IfxGtm_Tom_PwmHl_setMode+0xd0>
                IfxGtm_Tom_Ch_setSignalLevel(driver->tom, channel, base->inverted
80002be2:	19 43 18 00 	ld.w %d3,[%a4]24
80002be6:	1d ff db ff 	j 80002b9c <IfxGtm_Tom_PwmHl_setMode+0xf8>
80002bea:	82 15       	mov %d5,1
80002bec:	1d ff df ff 	j 80002baa <IfxGtm_Tom_PwmHl_setMode+0x106>
80002bf0:	00 90       	ret 
    boolean                result = TRUE;
80002bf2:	82 12       	mov %d2,1
            }
        }
    }

    return result;
}
80002bf4:	00 90       	ret 

80002bf6 <IfxGtm_Tom_PwmHl_setOnTime>:


void IfxGtm_Tom_PwmHl_setOnTime(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn)
{
80002bf6:	40 ae       	mov.aa %a14,%sp
    driver->update(driver, tOn);
80002bf8:	99 42 24 00 	ld.a %a2,[%a4]36
80002bfc:	2d 02 00 00 	calli %a2
}
80002c00:	00 90       	ret 

80002c02 <IfxGtm_Tom_PwmHl_updateCenterAligned>:
    IfxGtm_Tom_PwmHl_updateOff(driver, NULL_PTR);
}


IFX_STATIC void IfxGtm_Tom_PwmHl_updateCenterAligned(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn)
{
80002c02:	40 ae       	mov.aa %a14,%sp
    uint8          channelIndex;
    Ifx_TimerValue period;
    Ifx_TimerValue deadtime = driver->base.deadtime;
80002c04:	54 47       	ld.w %d7,[%a4]

    period = driver->timer->base.period;
80002c06:	99 42 20 00 	ld.a %a2,[%a4]32
80002c0a:	54 25       	ld.w %d5,[%a2]

    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
80002c0c:	82 03       	mov %d3,0
80002c0e:	1d 00 5e 00 	j 80002cca <IfxGtm_Tom_PwmHl_updateCenterAligned+0xc8>
        else
        {}

        if ((x < driver->base.minPulse) || (x <= deadtime))
        {                       /* For deadtime condition: avoid leading edge of top channel to occur after the trailing edge */
            x = 0;
80002c12:	82 02       	mov %d2,0
        }
        else
        {}

        /* Special handling due to GTM issue */
        if (x == period)
80002c14:	5f 52 2e 00 	jeq %d2,%d5,80002c70 <IfxGtm_Tom_PwmHl_updateCenterAligned+0x6e>
                2 /* 1st compare event (issue: expected to be 1) */ + deadtime);
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex],
                period + 2 /* No compare event, issues has been seen with +1 */,
                2 /* 1st compare event (issue: expected to be 1) */);
        }
        else if (x == 0)
80002c18:	df 02 75 80 	jne %d2,0,80002d02 <IfxGtm_Tom_PwmHl_updateCenterAligned+0x100>
        {
            cm0 = 1;
            cm1 = period + 2;
80002c1c:	1b 25 00 20 	addi %d2,%d5,2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex], cm0, cm1);
80002c20:	99 42 10 10 	ld.a %a2,[%a4]80
80002c24:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80002c28:	54 26       	ld.w %d6,[%a2]
80002c2a:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002c2e:	06 66       	sh %d6,6
80002c30:	99 42 30 00 	ld.a %a2,[%a4]48
80002c34:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
80002c38:	82 16       	mov %d6,1
80002c3a:	59 26 04 00 	st.w [%a2]4,%d6
    tomCh->SR1.U = shadowOne;
80002c3e:	59 22 08 00 	st.w [%a2]8,%d2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], cm0 + deadtime, cm1);
80002c42:	99 42 14 10 	ld.a %a2,[%a4]84
80002c46:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80002c4a:	54 26       	ld.w %d6,[%a2]
80002c4c:	1b 17 00 40 	addi %d4,%d7,1
80002c50:	37 04 70 40 	extr.u %d4,%d4,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002c54:	06 66       	sh %d6,6
80002c56:	99 42 30 00 	ld.a %a2,[%a4]48
80002c5a:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
80002c5e:	59 24 04 00 	st.w [%a2]4,%d4
    tomCh->SR1.U = shadowOne;
80002c62:	59 22 08 00 	st.w [%a2]8,%d2
}
80002c66:	1d 00 2f 00 	j 80002cc4 <IfxGtm_Tom_PwmHl_updateCenterAligned+0xc2>
            x = 0;
80002c6a:	82 02       	mov %d2,0
80002c6c:	1d ff d4 ff 	j 80002c14 <IfxGtm_Tom_PwmHl_updateCenterAligned+0x12>
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex],
80002c70:	99 42 10 10 	ld.a %a2,[%a4]80
80002c74:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80002c78:	54 21       	ld.w %d1,[%a2]
                period + 1 /* No compare event */,
80002c7a:	37 05 70 20 	extr.u %d2,%d5,0,16
80002c7e:	1b 12 00 00 	addi %d0,%d2,1
80002c82:	37 00 70 00 	extr.u %d0,%d0,0,16
                2 /* 1st compare event (issue: expected to be 1) */ + deadtime);
80002c86:	1b 27 00 60 	addi %d6,%d7,2
80002c8a:	37 06 70 60 	extr.u %d6,%d6,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002c8e:	06 61       	sh %d1,6
80002c90:	99 42 30 00 	ld.a %a2,[%a4]48
80002c94:	01 21 00 26 	addsc.a %a2,%a2,%d1,0
    tomCh->SR0.U = shadowZero;
80002c98:	59 20 04 00 	st.w [%a2]4,%d0
    tomCh->SR1.U = shadowOne;
80002c9c:	59 26 08 00 	st.w [%a2]8,%d6
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex],
80002ca0:	99 42 14 10 	ld.a %a2,[%a4]84
80002ca4:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80002ca8:	54 24       	ld.w %d4,[%a2]
                period + 2 /* No compare event, issues has been seen with +1 */,
80002caa:	c2 22       	add %d2,2
80002cac:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002cb0:	06 64       	sh %d4,6
80002cb2:	99 42 30 00 	ld.a %a2,[%a4]48
80002cb6:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->SR0.U = shadowZero;
80002cba:	59 22 04 00 	st.w [%a2]4,%d2
    tomCh->SR1.U = shadowOne;
80002cbe:	82 22       	mov %d2,2
80002cc0:	59 22 08 00 	st.w [%a2]8,%d2
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
80002cc4:	c2 13       	add %d3,1
80002cc6:	8f f3 0f 31 	and %d3,%d3,255
80002cca:	39 42 1d 00 	ld.bu %d2,[%a4]29
80002cce:	7f 23 4e 80 	jge.u %d3,%d2,80002d6a <IfxGtm_Tom_PwmHl_updateCenterAligned+0x168>
        x = tOn[channelIndex];
80002cd2:	8f 23 00 40 	sh %d4,%d3,2
80002cd6:	01 54 00 26 	addsc.a %a2,%a5,%d4,0
80002cda:	54 22       	ld.w %d2,[%a2]
        if (driver->base.inverted != FALSE)
80002cdc:	39 46 1c 00 	ld.bu %d6,[%a4]28
80002ce0:	df 06 04 00 	jeq %d6,0,80002ce8 <IfxGtm_Tom_PwmHl_updateCenterAligned+0xe6>
            x = period - x;
80002ce4:	0b 25 80 20 	sub %d2,%d5,%d2
        if ((x < driver->base.minPulse) || (x <= deadtime))
80002ce8:	19 46 04 00 	ld.w %d6,[%a4]4
80002cec:	3f 62 93 ff 	jlt.u %d2,%d6,80002c12 <IfxGtm_Tom_PwmHl_updateCenterAligned+0x10>
80002cf0:	7f 27 bd ff 	jge.u %d7,%d2,80002c6a <IfxGtm_Tom_PwmHl_updateCenterAligned+0x68>
        else if (x > driver->base.maxPulse)
80002cf4:	19 46 08 00 	ld.w %d6,[%a4]8
80002cf8:	7f 26 8e ff 	jge.u %d6,%d2,80002c14 <IfxGtm_Tom_PwmHl_updateCenterAligned+0x12>
            x = period;
80002cfc:	02 52       	mov %d2,%d5
80002cfe:	1d ff 8b ff 	j 80002c14 <IfxGtm_Tom_PwmHl_updateCenterAligned+0x12>
        }
        else
        {                           /* x% duty cycle */
            cm1 = (period - x) / 2; // CM1
80002d02:	0b 25 80 60 	sub %d6,%d5,%d2
80002d06:	06 f6       	sh %d6,-1
            cm0 = (period + x) / 2; // CM0
80002d08:	42 52       	add %d2,%d5
80002d0a:	8f f2 1f 80 	sh %d8,%d2,-1
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex], cm0, cm1 + deadtime);
80002d0e:	99 42 10 10 	ld.a %a2,[%a4]80
80002d12:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80002d16:	54 2a       	ld.w %d10,[%a2]
80002d18:	37 02 f0 90 	extr.u %d9,%d2,1,16
80002d1c:	bb f0 ff 2f 	mov.u %d2,65535
80002d20:	26 28       	and %d8,%d2
80002d22:	37 07 70 00 	extr.u %d0,%d7,0,16
80002d26:	0b 60 00 10 	add %d1,%d0,%d6
80002d2a:	37 01 70 10 	extr.u %d1,%d1,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002d2e:	06 6a       	sh %d10,6
80002d30:	99 42 30 00 	ld.a %a2,[%a4]48
80002d34:	01 2a 00 26 	addsc.a %a2,%a2,%d10,0
    tomCh->SR0.U = shadowZero;
80002d38:	59 28 04 00 	st.w [%a2]4,%d8
    tomCh->SR1.U = shadowOne;
80002d3c:	59 21 08 00 	st.w [%a2]8,%d1
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], cm0 + deadtime, cm1);
80002d40:	99 42 14 10 	ld.a %a2,[%a4]84
80002d44:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80002d48:	54 21       	ld.w %d1,[%a2]
80002d4a:	0b 09 00 40 	add %d4,%d9,%d0
80002d4e:	37 04 70 40 	extr.u %d4,%d4,0,16
80002d52:	26 62       	and %d2,%d6
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002d54:	06 61       	sh %d1,6
80002d56:	99 42 30 00 	ld.a %a2,[%a4]48
80002d5a:	01 21 00 26 	addsc.a %a2,%a2,%d1,0
    tomCh->SR0.U = shadowZero;
80002d5e:	59 24 04 00 	st.w [%a2]4,%d4
    tomCh->SR1.U = shadowOne;
80002d62:	59 22 08 00 	st.w [%a2]8,%d2
}
80002d66:	1d ff af ff 	j 80002cc4 <IfxGtm_Tom_PwmHl_updateCenterAligned+0xc2>
        }
    }
}
80002d6a:	00 90       	ret 

80002d6c <IfxGtm_Tom_PwmHl_updateEdgeAligned>:


IFX_STATIC void IfxGtm_Tom_PwmHl_updateEdgeAligned(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn)
{
80002d6c:	40 ae       	mov.aa %a14,%sp
    uint8          channelIndex;
    Ifx_TimerValue period;
    Ifx_TimerValue deadtime = driver->base.deadtime;
80002d6e:	54 47       	ld.w %d7,[%a4]

    period = driver->timer->base.period;
80002d70:	99 42 20 00 	ld.a %a2,[%a4]32
80002d74:	54 25       	ld.w %d5,[%a2]

    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
80002d76:	82 03       	mov %d3,0
80002d78:	1d 00 5e 00 	j 80002e34 <IfxGtm_Tom_PwmHl_updateEdgeAligned+0xc8>
        else
        {}

        if ((x < driver->base.minPulse) || (x <= deadtime))
        {                       /* For deadtime condition: avoid leading edge of top channel to occur after the trailing edge */
            x = 0;
80002d7c:	82 00       	mov %d0,0
        }
        else
        {}

        /* Special handling due to GTM issue */
        if (x == period)
80002d7e:	5f 50 2e 00 	jeq %d0,%d5,80002dda <IfxGtm_Tom_PwmHl_updateEdgeAligned+0x6e>
                2 /* 1st compare event (issue: expected to be 1) */ + deadtime);
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex],
                period + 2 /* No compare event, issues has been seen with +1 */,
                2 /* 1st compare event (issue: expected to be 1) */);
        }
        else if (x == 0)
80002d82:	df 00 75 80 	jne %d0,0,80002e6c <IfxGtm_Tom_PwmHl_updateEdgeAligned+0x100>
        {
            cm0 = 1;
            cm1 = period + 2;
80002d86:	1b 25 00 20 	addi %d2,%d5,2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex], cm0, cm1);
80002d8a:	99 42 10 10 	ld.a %a2,[%a4]80
80002d8e:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80002d92:	54 26       	ld.w %d6,[%a2]
80002d94:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002d98:	06 66       	sh %d6,6
80002d9a:	99 42 30 00 	ld.a %a2,[%a4]48
80002d9e:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
80002da2:	82 16       	mov %d6,1
80002da4:	59 26 04 00 	st.w [%a2]4,%d6
    tomCh->SR1.U = shadowOne;
80002da8:	59 22 08 00 	st.w [%a2]8,%d2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], cm0 + deadtime, cm1);
80002dac:	99 42 14 10 	ld.a %a2,[%a4]84
80002db0:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80002db4:	54 26       	ld.w %d6,[%a2]
80002db6:	1b 17 00 40 	addi %d4,%d7,1
80002dba:	37 04 70 40 	extr.u %d4,%d4,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002dbe:	06 66       	sh %d6,6
80002dc0:	99 42 30 00 	ld.a %a2,[%a4]48
80002dc4:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
80002dc8:	59 24 04 00 	st.w [%a2]4,%d4
    tomCh->SR1.U = shadowOne;
80002dcc:	59 22 08 00 	st.w [%a2]8,%d2
}
80002dd0:	1d 00 2f 00 	j 80002e2e <IfxGtm_Tom_PwmHl_updateEdgeAligned+0xc2>
            x = 0;
80002dd4:	82 00       	mov %d0,0
80002dd6:	1d ff d4 ff 	j 80002d7e <IfxGtm_Tom_PwmHl_updateEdgeAligned+0x12>
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex],
80002dda:	99 42 10 10 	ld.a %a2,[%a4]80
80002dde:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80002de2:	54 21       	ld.w %d1,[%a2]
                period + 1 /* No compare event */,
80002de4:	37 05 70 20 	extr.u %d2,%d5,0,16
80002de8:	1b 12 00 00 	addi %d0,%d2,1
80002dec:	37 00 70 00 	extr.u %d0,%d0,0,16
                2 /* 1st compare event (issue: expected to be 1) */ + deadtime);
80002df0:	1b 27 00 60 	addi %d6,%d7,2
80002df4:	37 06 70 60 	extr.u %d6,%d6,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002df8:	06 61       	sh %d1,6
80002dfa:	99 42 30 00 	ld.a %a2,[%a4]48
80002dfe:	01 21 00 26 	addsc.a %a2,%a2,%d1,0
    tomCh->SR0.U = shadowZero;
80002e02:	59 20 04 00 	st.w [%a2]4,%d0
    tomCh->SR1.U = shadowOne;
80002e06:	59 26 08 00 	st.w [%a2]8,%d6
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex],
80002e0a:	99 42 14 10 	ld.a %a2,[%a4]84
80002e0e:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80002e12:	54 24       	ld.w %d4,[%a2]
                period + 2 /* No compare event, issues has been seen with +1 */,
80002e14:	c2 22       	add %d2,2
80002e16:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002e1a:	06 64       	sh %d4,6
80002e1c:	99 42 30 00 	ld.a %a2,[%a4]48
80002e20:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->SR0.U = shadowZero;
80002e24:	59 22 04 00 	st.w [%a2]4,%d2
    tomCh->SR1.U = shadowOne;
80002e28:	82 22       	mov %d2,2
80002e2a:	59 22 08 00 	st.w [%a2]8,%d2
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
80002e2e:	c2 13       	add %d3,1
80002e30:	8f f3 0f 31 	and %d3,%d3,255
80002e34:	39 42 1d 00 	ld.bu %d2,[%a4]29
80002e38:	7f 23 44 80 	jge.u %d3,%d2,80002ec0 <IfxGtm_Tom_PwmHl_updateEdgeAligned+0x154>
        x = tOn[channelIndex];
80002e3c:	8f 23 00 40 	sh %d4,%d3,2
80002e40:	01 54 00 26 	addsc.a %a2,%a5,%d4,0
80002e44:	54 20       	ld.w %d0,[%a2]
        if (driver->base.inverted != FALSE)
80002e46:	39 46 1c 00 	ld.bu %d6,[%a4]28
80002e4a:	df 06 04 00 	jeq %d6,0,80002e52 <IfxGtm_Tom_PwmHl_updateEdgeAligned+0xe6>
            x = period - x;
80002e4e:	0b 05 80 00 	sub %d0,%d5,%d0
        if ((x < driver->base.minPulse) || (x <= deadtime))
80002e52:	19 46 04 00 	ld.w %d6,[%a4]4
80002e56:	3f 60 93 ff 	jlt.u %d0,%d6,80002d7c <IfxGtm_Tom_PwmHl_updateEdgeAligned+0x10>
80002e5a:	7f 07 bd ff 	jge.u %d7,%d0,80002dd4 <IfxGtm_Tom_PwmHl_updateEdgeAligned+0x68>
        else if (x > driver->base.maxPulse)
80002e5e:	19 46 08 00 	ld.w %d6,[%a4]8
80002e62:	7f 06 8e ff 	jge.u %d6,%d0,80002d7e <IfxGtm_Tom_PwmHl_updateEdgeAligned+0x12>
            x = period;
80002e66:	02 50       	mov %d0,%d5
80002e68:	1d ff 8b ff 	j 80002d7e <IfxGtm_Tom_PwmHl_updateEdgeAligned+0x12>
        }
        else
        {                       /* x% duty cycle */
            cm1 = 2;            // CM1, set to 2 due to a GTM issue. should be 1 according to spec
            cm0 = x;            // CM0, set to x+2 due to a GTM issue. should be x+1 according to spec
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex], cm0, cm1 + deadtime);
80002e6c:	99 42 10 10 	ld.a %a2,[%a4]80
80002e70:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80002e74:	54 28       	ld.w %d8,[%a2]
80002e76:	37 00 70 10 	extr.u %d1,%d0,0,16
80002e7a:	37 07 70 20 	extr.u %d2,%d7,0,16
80002e7e:	1b 22 00 60 	addi %d6,%d2,2
80002e82:	37 06 70 60 	extr.u %d6,%d6,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002e86:	06 68       	sh %d8,6
80002e88:	99 42 30 00 	ld.a %a2,[%a4]48
80002e8c:	01 28 00 26 	addsc.a %a2,%a2,%d8,0
    tomCh->SR0.U = shadowZero;
80002e90:	59 21 04 00 	st.w [%a2]4,%d1
    tomCh->SR1.U = shadowOne;
80002e94:	59 26 08 00 	st.w [%a2]8,%d6
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], cm0 + deadtime, cm1);
80002e98:	99 42 14 10 	ld.a %a2,[%a4]84
80002e9c:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80002ea0:	54 24       	ld.w %d4,[%a2]
80002ea2:	42 12       	add %d2,%d1
80002ea4:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002ea8:	06 64       	sh %d4,6
80002eaa:	99 42 30 00 	ld.a %a2,[%a4]48
80002eae:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->SR0.U = shadowZero;
80002eb2:	59 22 04 00 	st.w [%a2]4,%d2
    tomCh->SR1.U = shadowOne;
80002eb6:	82 22       	mov %d2,2
80002eb8:	59 22 08 00 	st.w [%a2]8,%d2
}
80002ebc:	1d ff b9 ff 	j 80002e2e <IfxGtm_Tom_PwmHl_updateEdgeAligned+0xc2>
        }
    }
}
80002ec0:	00 90       	ret 

80002ec2 <IfxGtm_Tom_PwmHl_updateOff>:


IFX_STATIC void IfxGtm_Tom_PwmHl_updateOff(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn)
{
80002ec2:	40 ae       	mov.aa %a14,%sp
    IFX_UNUSED_PARAMETER(tOn)
    uint8 channelIndex;
    Ifx_TimerValue period;

    period = driver->timer->base.period;
80002ec4:	99 42 20 00 	ld.a %a2,[%a4]32
80002ec8:	54 27       	ld.w %d7,[%a2]

    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
80002eca:	82 02       	mov %d2,0
80002ecc:	1d 00 2d 00 	j 80002f26 <IfxGtm_Tom_PwmHl_updateOff+0x64>
    {
        IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex],
80002ed0:	8f 22 00 40 	sh %d4,%d2,2
80002ed4:	99 42 10 10 	ld.a %a2,[%a4]80
80002ed8:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80002edc:	54 26       	ld.w %d6,[%a2]
            2 /* 1 will keep the previous level */, period + 2);
80002ede:	37 07 70 30 	extr.u %d3,%d7,0,16
80002ee2:	1b 23 00 50 	addi %d5,%d3,2
80002ee6:	37 05 70 50 	extr.u %d5,%d5,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002eea:	06 66       	sh %d6,6
80002eec:	99 42 30 00 	ld.a %a2,[%a4]48
80002ef0:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
80002ef4:	82 26       	mov %d6,2
80002ef6:	59 26 04 00 	st.w [%a2]4,%d6
    tomCh->SR1.U = shadowOne;
80002efa:	59 25 08 00 	st.w [%a2]8,%d5
        IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], period + 1, 2);
80002efe:	99 42 14 10 	ld.a %a2,[%a4]84
80002f02:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80002f06:	54 24       	ld.w %d4,[%a2]
80002f08:	c2 13       	add %d3,1
80002f0a:	37 03 70 30 	extr.u %d3,%d3,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002f0e:	06 64       	sh %d4,6
80002f10:	99 42 30 00 	ld.a %a2,[%a4]48
80002f14:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->SR0.U = shadowZero;
80002f18:	59 23 04 00 	st.w [%a2]4,%d3
    tomCh->SR1.U = shadowOne;
80002f1c:	59 26 08 00 	st.w [%a2]8,%d6
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
80002f20:	c2 12       	add %d2,1
80002f22:	8f f2 0f 21 	and %d2,%d2,255
80002f26:	39 43 1d 00 	ld.bu %d3,[%a4]29
80002f2a:	3f 32 d3 ff 	jlt.u %d2,%d3,80002ed0 <IfxGtm_Tom_PwmHl_updateOff+0xe>
    }
}
80002f2e:	00 90       	ret 

80002f30 <IfxGtm_Tom_PwmHl_updateAndShiftOff>:
{
80002f30:	40 ae       	mov.aa %a14,%sp
    IfxGtm_Tom_PwmHl_updateOff(driver, NULL_PTR);
80002f32:	a0 05       	mov.a %a5,0
80002f34:	6d ff c7 ff 	call 80002ec2 <IfxGtm_Tom_PwmHl_updateOff>
}
80002f38:	00 90       	ret 

80002f3a <IfxGtm_Tom_PwmHl_updatePulse>:


IFX_STATIC void IfxGtm_Tom_PwmHl_updatePulse(IfxGtm_Tom_PwmHl *driver, float32 *tOn, float32 *offset)
{
80002f3a:	40 ae       	mov.aa %a14,%sp
    uint8          channelIndex;
    Ifx_TimerValue period;

    period = driver->timer->base.period;
80002f3c:	99 42 20 00 	ld.a %a2,[%a4]32
80002f40:	54 23       	ld.w %d3,[%a2]

    /* Top channels */
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
80002f42:	82 04       	mov %d4,0
80002f44:	1d 00 38 00 	j 80002fb4 <IfxGtm_Tom_PwmHl_updatePulse+0x7a>
        else
        {}

        if ((x < driver->base.minPulse) || (o > period))
        {
            x = 0;
80002f48:	82 02       	mov %d2,0
        }
        else
        {}

        /* Special handling due to GTM issue */
        if (x == period)
80002f4a:	5f 32 1f 00 	jeq %d2,%d3,80002f88 <IfxGtm_Tom_PwmHl_updatePulse+0x4e>
        {   /* 100% duty cycle */
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex],
                period + 1 /* No compare event */,
                2 /* 1st compare event (issue: expected to be 1)*/);
        }
        else if (x == 0)
80002f4e:	df 02 62 80 	jne %d2,0,80003012 <IfxGtm_Tom_PwmHl_updatePulse+0xd8>
        {
            cm0 = 1;
            cm1 = period + 2;
80002f52:	1b 23 00 20 	addi %d2,%d3,2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex], cm0, cm1);
80002f56:	99 42 10 10 	ld.a %a2,[%a4]80
80002f5a:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
80002f5e:	54 25       	ld.w %d5,[%a2]
80002f60:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002f64:	06 65       	sh %d5,6
80002f66:	99 42 30 00 	ld.a %a2,[%a4]48
80002f6a:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
    tomCh->SR0.U = shadowZero;
80002f6e:	82 15       	mov %d5,1
80002f70:	59 25 04 00 	st.w [%a2]4,%d5
    tomCh->SR1.U = shadowOne;
80002f74:	59 22 08 00 	st.w [%a2]8,%d2
}
80002f78:	1d 00 1b 00 	j 80002fae <IfxGtm_Tom_PwmHl_updatePulse+0x74>
            x = 0;
80002f7c:	82 02       	mov %d2,0
80002f7e:	1d ff e6 ff 	j 80002f4a <IfxGtm_Tom_PwmHl_updatePulse+0x10>
            x = period;
80002f82:	02 32       	mov %d2,%d3
80002f84:	1d ff e3 ff 	j 80002f4a <IfxGtm_Tom_PwmHl_updatePulse+0x10>
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex],
80002f88:	99 42 10 10 	ld.a %a2,[%a4]80
80002f8c:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
80002f90:	54 25       	ld.w %d5,[%a2]
                period + 1 /* No compare event */,
80002f92:	1b 13 00 20 	addi %d2,%d3,1
80002f96:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80002f9a:	06 65       	sh %d5,6
80002f9c:	99 42 30 00 	ld.a %a2,[%a4]48
80002fa0:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
    tomCh->SR0.U = shadowZero;
80002fa4:	59 22 04 00 	st.w [%a2]4,%d2
    tomCh->SR1.U = shadowOne;
80002fa8:	82 22       	mov %d2,2
80002faa:	59 22 08 00 	st.w [%a2]8,%d2
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
80002fae:	c2 14       	add %d4,1
80002fb0:	8f f4 0f 41 	and %d4,%d4,255
80002fb4:	39 42 1d 00 	ld.bu %d2,[%a4]29
80002fb8:	7f 24 44 80 	jge.u %d4,%d2,80003040 <IfxGtm_Tom_PwmHl_updatePulse+0x106>
        x = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, tOn[channelIndex]);
80002fbc:	99 42 20 00 	ld.a %a2,[%a4]32
80002fc0:	19 25 08 00 	ld.w %d5,[%a2]8
80002fc4:	8f 24 00 60 	sh %d6,%d4,2
80002fc8:	01 56 00 26 	addsc.a %a2,%a5,%d6,0
80002fcc:	54 22       	ld.w %d2,[%a2]
80002fce:	4b 25 41 20 	mul.f %d2,%d5,%d2
80002fd2:	4b 02 71 21 	ftouz %d2,%d2
        o = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, offset[channelIndex]);
80002fd6:	01 66 00 26 	addsc.a %a2,%a6,%d6,0
80002fda:	54 27       	ld.w %d7,[%a2]
80002fdc:	4b 75 41 50 	mul.f %d5,%d5,%d7
80002fe0:	4b 05 71 51 	ftouz %d5,%d5
        if (driver->base.inverted != FALSE)
80002fe4:	39 47 1c 00 	ld.bu %d7,[%a4]28
80002fe8:	df 07 04 00 	jeq %d7,0,80002ff0 <IfxGtm_Tom_PwmHl_updatePulse+0xb6>
            x = period - x;
80002fec:	0b 23 80 20 	sub %d2,%d3,%d2
        if ((x < driver->base.minPulse) || (o > period))
80002ff0:	19 47 04 00 	ld.w %d7,[%a4]4
80002ff4:	3f 72 aa ff 	jlt.u %d2,%d7,80002f48 <IfxGtm_Tom_PwmHl_updatePulse+0xe>
80002ff8:	3f 53 c2 ff 	jlt.u %d3,%d5,80002f7c <IfxGtm_Tom_PwmHl_updatePulse+0x42>
        else if ((x > driver->base.maxPulse) || (o + x > period))
80002ffc:	19 47 08 00 	ld.w %d7,[%a4]8
80003000:	3f 27 c1 ff 	jlt.u %d7,%d2,80002f82 <IfxGtm_Tom_PwmHl_updatePulse+0x48>
80003004:	0b 52 00 70 	add %d7,%d2,%d5
80003008:	7f 73 a1 ff 	jge.u %d3,%d7,80002f4a <IfxGtm_Tom_PwmHl_updatePulse+0x10>
            x = period;
8000300c:	02 32       	mov %d2,%d3
8000300e:	1d ff 9e ff 	j 80002f4a <IfxGtm_Tom_PwmHl_updatePulse+0x10>
        }
        else
        {                /* x% duty cycle */
            cm1 = 2 + o; // CM1, set to 2 due to a GTM issue. should be 1 according to spec
80003012:	1b 25 00 70 	addi %d7,%d5,2
            cm0 = o + x; // CM0, set to x+2 due to a GTM issue. should be x+1 according to spec
80003016:	42 25       	add %d5,%d2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex], cm0, cm1);
80003018:	99 42 10 10 	ld.a %a2,[%a4]80
8000301c:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
80003020:	54 26       	ld.w %d6,[%a2]
80003022:	bb f0 ff 2f 	mov.u %d2,65535
80003026:	26 25       	and %d5,%d2
80003028:	26 72       	and %d2,%d7
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
8000302a:	06 66       	sh %d6,6
8000302c:	99 42 30 00 	ld.a %a2,[%a4]48
80003030:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
80003034:	59 25 04 00 	st.w [%a2]4,%d5
    tomCh->SR1.U = shadowOne;
80003038:	59 22 08 00 	st.w [%a2]8,%d2
}
8000303c:	1d ff b9 ff 	j 80002fae <IfxGtm_Tom_PwmHl_updatePulse+0x74>
        }
    }

    /* Bottom channels */
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
80003040:	82 04       	mov %d4,0
80003042:	1d 00 36 00 	j 800030ae <IfxGtm_Tom_PwmHl_updatePulse+0x174>
        else
        {}

        if (x < driver->base.minPulse)
        {
            x = 0;
80003046:	82 02       	mov %d2,0
        }
        else
        {}

        /* Special handling due to GTM issue */
        if (x == period)
80003048:	5f 32 1b 00 	jeq %d2,%d3,8000307e <IfxGtm_Tom_PwmHl_updatePulse+0x144>
        {   /* 100% duty cycle */
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex],
                period + 2 /* No compare event, issues has been seen with +1 */,
                2 /* 1st compare event (issue: expected to be 1)*/);
        }
        else if (x == 0)
8000304c:	df 02 5b 80 	jne %d2,0,80003102 <IfxGtm_Tom_PwmHl_updatePulse+0x1c8>
        {
            cm0 = 1;
            cm1 = period + 2;
80003050:	1b 23 00 60 	addi %d6,%d3,2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], cm0, cm1);
80003054:	8f 24 00 20 	sh %d2,%d4,2
80003058:	99 42 14 10 	ld.a %a2,[%a4]84
8000305c:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80003060:	54 25       	ld.w %d5,[%a2]
80003062:	37 06 70 20 	extr.u %d2,%d6,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003066:	06 65       	sh %d5,6
80003068:	99 42 30 00 	ld.a %a2,[%a4]48
8000306c:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
    tomCh->SR0.U = shadowZero;
80003070:	82 15       	mov %d5,1
80003072:	59 25 04 00 	st.w [%a2]4,%d5
    tomCh->SR1.U = shadowOne;
80003076:	59 22 08 00 	st.w [%a2]8,%d2
}
8000307a:	1d 00 17 00 	j 800030a8 <IfxGtm_Tom_PwmHl_updatePulse+0x16e>
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex],
8000307e:	8f 24 00 20 	sh %d2,%d4,2
80003082:	99 42 14 10 	ld.a %a2,[%a4]84
80003086:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000308a:	54 25       	ld.w %d5,[%a2]
                period + 2 /* No compare event, issues has been seen with +1 */,
8000308c:	1b 23 00 20 	addi %d2,%d3,2
80003090:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003094:	06 65       	sh %d5,6
80003096:	99 42 30 00 	ld.a %a2,[%a4]48
8000309a:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
    tomCh->SR0.U = shadowZero;
8000309e:	59 22 04 00 	st.w [%a2]4,%d2
    tomCh->SR1.U = shadowOne;
800030a2:	82 22       	mov %d2,2
800030a4:	59 22 08 00 	st.w [%a2]8,%d2
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
800030a8:	c2 14       	add %d4,1
800030aa:	8f f4 0f 41 	and %d4,%d4,255
800030ae:	39 42 1d 00 	ld.bu %d2,[%a4]29
800030b2:	7f 24 42 80 	jge.u %d4,%d2,80003136 <IfxGtm_Tom_PwmHl_updatePulse+0x1fc>
        x = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, tOn[channelIndex + driver->base.channelCount]);
800030b6:	99 42 20 00 	ld.a %a2,[%a4]32
800030ba:	19 25 08 00 	ld.w %d5,[%a2]8
800030be:	42 42       	add %d2,%d4
800030c0:	8f 22 00 60 	sh %d6,%d2,2
800030c4:	01 56 00 26 	addsc.a %a2,%a5,%d6,0
800030c8:	54 22       	ld.w %d2,[%a2]
800030ca:	4b 25 41 20 	mul.f %d2,%d5,%d2
800030ce:	4b 02 71 21 	ftouz %d2,%d2
        o = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, offset[channelIndex + driver->base.channelCount]);
800030d2:	01 66 00 26 	addsc.a %a2,%a6,%d6,0
800030d6:	54 26       	ld.w %d6,[%a2]
800030d8:	4b 65 41 60 	mul.f %d6,%d5,%d6
800030dc:	4b 06 71 61 	ftouz %d6,%d6
        if (driver->base.inverted != FALSE)
800030e0:	39 45 1c 00 	ld.bu %d5,[%a4]28
800030e4:	df 05 04 00 	jeq %d5,0,800030ec <IfxGtm_Tom_PwmHl_updatePulse+0x1b2>
            x = period - x;
800030e8:	0b 23 80 20 	sub %d2,%d3,%d2
        if (x < driver->base.minPulse)
800030ec:	19 45 04 00 	ld.w %d5,[%a4]4
800030f0:	3f 52 ab ff 	jlt.u %d2,%d5,80003046 <IfxGtm_Tom_PwmHl_updatePulse+0x10c>
        else if (x > driver->base.maxPulse)
800030f4:	19 45 08 00 	ld.w %d5,[%a4]8
800030f8:	7f 25 a8 ff 	jge.u %d5,%d2,80003048 <IfxGtm_Tom_PwmHl_updatePulse+0x10e>
            x = period;
800030fc:	02 32       	mov %d2,%d3
800030fe:	1d ff a5 ff 	j 80003048 <IfxGtm_Tom_PwmHl_updatePulse+0x10e>
        }
        else
        {                /* x% duty cycle */
            cm1 = 2 + o; // CM1, set to 2 due to a GTM issue. should be 1 according to spec
80003102:	1b 26 00 70 	addi %d7,%d6,2
            cm0 = o + x; // CM0, set to x+2 due to a GTM issue. should be x+1 according to spec
80003106:	0b 62 00 50 	add %d5,%d2,%d6
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], cm0, cm1);
8000310a:	8f 24 00 20 	sh %d2,%d4,2
8000310e:	99 42 14 10 	ld.a %a2,[%a4]84
80003112:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80003116:	54 26       	ld.w %d6,[%a2]
80003118:	bb f0 ff 2f 	mov.u %d2,65535
8000311c:	26 25       	and %d5,%d2
8000311e:	26 72       	and %d2,%d7
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003120:	06 66       	sh %d6,6
80003122:	99 42 30 00 	ld.a %a2,[%a4]48
80003126:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
8000312a:	59 25 04 00 	st.w [%a2]4,%d5
    tomCh->SR1.U = shadowOne;
8000312e:	59 22 08 00 	st.w [%a2]8,%d2
}
80003132:	1d ff bb ff 	j 800030a8 <IfxGtm_Tom_PwmHl_updatePulse+0x16e>
        }
    }
}
80003136:	00 90       	ret 

80003138 <IfxGtm_Tom_PwmHl_updatePulseOff>:


IFX_STATIC void IfxGtm_Tom_PwmHl_updatePulseOff(IfxGtm_Tom_PwmHl *driver, float32 *tOn, float32 *offset)
{
80003138:	40 ae       	mov.aa %a14,%sp
    IFX_UNUSED_PARAMETER(tOn)
    IFX_UNUSED_PARAMETER(offset)
    IfxGtm_Tom_PwmHl_updateOff(driver, NULL_PTR);
8000313a:	a0 05       	mov.a %a5,0
8000313c:	6d ff c3 fe 	call 80002ec2 <IfxGtm_Tom_PwmHl_updateOff>
}
80003140:	00 90       	ret 

80003142 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned>:


IFX_STATIC void IfxGtm_Tom_PwmHl_updateShiftCenterAligned(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn, Ifx_TimerValue *shift)
{
80003142:	40 ae       	mov.aa %a14,%sp
80003144:	80 6b       	mov.d %d11,%a6
    uint8          channelIndex;
    Ifx_TimerValue period;
    Ifx_TimerValue deadtime = driver->base.deadtime;
80003146:	54 47       	ld.w %d7,[%a4]

    period = driver->timer->base.period;
80003148:	99 42 20 00 	ld.a %a2,[%a4]32
8000314c:	54 25       	ld.w %d5,[%a2]

    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
8000314e:	82 03       	mov %d3,0
80003150:	1d 00 5e 00 	j 8000320c <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0xca>
        else
        {}

        if ((x < driver->base.minPulse) || (x <= deadtime))
        {   /* For deadtime condition: avoid leading edge of top channel to occur after the trailing edge */
            x = 0;
80003154:	82 02       	mov %d2,0
        }
        else
        {}

        /* Special handling due to GTM issue */
        if (x == period)
80003156:	5f 52 2e 00 	jeq %d2,%d5,800031b2 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x70>
                2 /* 1st compare event (issue: expected to be 1)*/ + deadtime);
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex],
                period + 2 /* No compare event, issues has been seen with +1 */,
                2 /* 1st compare event (issue: expected to be 1)*/);
        }
        else if (x == 0)
8000315a:	df 02 75 80 	jne %d2,0,80003244 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x102>
        {
            cm0 = 1;
            cm1 = period + 2;
8000315e:	1b 25 00 20 	addi %d2,%d5,2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex], cm0, cm1);
80003162:	99 42 10 10 	ld.a %a2,[%a4]80
80003166:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
8000316a:	54 26       	ld.w %d6,[%a2]
8000316c:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003170:	06 66       	sh %d6,6
80003172:	99 42 30 00 	ld.a %a2,[%a4]48
80003176:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
8000317a:	82 16       	mov %d6,1
8000317c:	59 26 04 00 	st.w [%a2]4,%d6
    tomCh->SR1.U = shadowOne;
80003180:	59 22 08 00 	st.w [%a2]8,%d2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], cm0 + deadtime, cm1);
80003184:	99 42 14 10 	ld.a %a2,[%a4]84
80003188:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
8000318c:	54 26       	ld.w %d6,[%a2]
8000318e:	1b 17 00 40 	addi %d4,%d7,1
80003192:	37 04 70 40 	extr.u %d4,%d4,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003196:	06 66       	sh %d6,6
80003198:	99 42 30 00 	ld.a %a2,[%a4]48
8000319c:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
800031a0:	59 24 04 00 	st.w [%a2]4,%d4
    tomCh->SR1.U = shadowOne;
800031a4:	59 22 08 00 	st.w [%a2]8,%d2
}
800031a8:	1d 00 2f 00 	j 80003206 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0xc4>
            x = 0;
800031ac:	82 02       	mov %d2,0
800031ae:	1d ff d4 ff 	j 80003156 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x14>
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex],
800031b2:	99 42 10 10 	ld.a %a2,[%a4]80
800031b6:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
800031ba:	54 21       	ld.w %d1,[%a2]
                period + 1 /* No compare event */,
800031bc:	37 05 70 20 	extr.u %d2,%d5,0,16
800031c0:	1b 12 00 00 	addi %d0,%d2,1
800031c4:	37 00 70 00 	extr.u %d0,%d0,0,16
                2 /* 1st compare event (issue: expected to be 1)*/ + deadtime);
800031c8:	1b 27 00 60 	addi %d6,%d7,2
800031cc:	37 06 70 60 	extr.u %d6,%d6,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800031d0:	06 61       	sh %d1,6
800031d2:	99 42 30 00 	ld.a %a2,[%a4]48
800031d6:	01 21 00 26 	addsc.a %a2,%a2,%d1,0
    tomCh->SR0.U = shadowZero;
800031da:	59 20 04 00 	st.w [%a2]4,%d0
    tomCh->SR1.U = shadowOne;
800031de:	59 26 08 00 	st.w [%a2]8,%d6
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex],
800031e2:	99 42 14 10 	ld.a %a2,[%a4]84
800031e6:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
800031ea:	54 24       	ld.w %d4,[%a2]
                period + 2 /* No compare event, issues has been seen with +1 */,
800031ec:	c2 22       	add %d2,2
800031ee:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800031f2:	06 64       	sh %d4,6
800031f4:	99 42 30 00 	ld.a %a2,[%a4]48
800031f8:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->SR0.U = shadowZero;
800031fc:	59 22 04 00 	st.w [%a2]4,%d2
    tomCh->SR1.U = shadowOne;
80003200:	82 22       	mov %d2,2
80003202:	59 22 08 00 	st.w [%a2]8,%d2
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
80003206:	c2 13       	add %d3,1
80003208:	8f f3 0f 31 	and %d3,%d3,255
8000320c:	39 42 1d 00 	ld.bu %d2,[%a4]29
80003210:	7f 23 64 80 	jge.u %d3,%d2,800032d8 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x196>
        x = tOn[channelIndex];
80003214:	8f 23 00 40 	sh %d4,%d3,2
80003218:	01 54 00 26 	addsc.a %a2,%a5,%d4,0
8000321c:	54 22       	ld.w %d2,[%a2]
        if (driver->base.inverted != FALSE)
8000321e:	39 46 1c 00 	ld.bu %d6,[%a4]28
80003222:	df 06 04 00 	jeq %d6,0,8000322a <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0xe8>
            x = period - x;
80003226:	0b 25 80 20 	sub %d2,%d5,%d2
        if ((x < driver->base.minPulse) || (x <= deadtime))
8000322a:	19 46 04 00 	ld.w %d6,[%a4]4
8000322e:	3f 62 93 ff 	jlt.u %d2,%d6,80003154 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x12>
80003232:	7f 27 bd ff 	jge.u %d7,%d2,800031ac <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x6a>
        else if (x > driver->base.maxPulse)
80003236:	19 46 08 00 	ld.w %d6,[%a4]8
8000323a:	7f 26 8e ff 	jge.u %d6,%d2,80003156 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x14>
            x = period;
8000323e:	02 52       	mov %d2,%d5
80003240:	1d ff 8b ff 	j 80003156 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x14>
        }
        else
        {                           /* x% duty cycle */
            s = shift[channelIndex];
80003244:	60 b2       	mov.a %a2,%d11
80003246:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
8000324a:	54 26       	ld.w %d6,[%a2]

            if (s > 0)
8000324c:	df 06 3e 00 	jeq %d6,0,800032c8 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x186>
            {
                s = __minX(s, (period - x) / 2 - 1);
80003250:	0b 25 80 00 	sub %d0,%d5,%d2
80003254:	06 f0       	sh %d0,-1
80003256:	c2 f0       	add %d0,-1
80003258:	0b 60 90 61 	min.u %d6,%d0,%d6
            else
            {
                s = __maxX(s, (x - period) / 2 + 1);
            }

            cm1 = s + (period - x) / 2; // CM1
8000325c:	0b 25 80 00 	sub %d0,%d5,%d2
80003260:	06 f0       	sh %d0,-1
80003262:	42 60       	add %d0,%d6
            cm0 = s + (period + x) / 2; // CM0
80003264:	42 52       	add %d2,%d5
80003266:	06 f2       	sh %d2,-1
80003268:	42 26       	add %d6,%d2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex], cm0, cm1 + deadtime);
8000326a:	99 42 10 10 	ld.a %a2,[%a4]80
8000326e:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80003272:	54 2a       	ld.w %d10,[%a2]
80003274:	37 06 70 90 	extr.u %d9,%d6,0,16
80003278:	bb f0 ff 2f 	mov.u %d2,65535
8000327c:	0f 26 80 80 	and %d8,%d6,%d2
80003280:	37 07 70 60 	extr.u %d6,%d7,0,16
80003284:	0b 06 00 10 	add %d1,%d6,%d0
80003288:	37 01 70 10 	extr.u %d1,%d1,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
8000328c:	06 6a       	sh %d10,6
8000328e:	99 42 30 00 	ld.a %a2,[%a4]48
80003292:	01 2a 00 26 	addsc.a %a2,%a2,%d10,0
    tomCh->SR0.U = shadowZero;
80003296:	59 28 04 00 	st.w [%a2]4,%d8
    tomCh->SR1.U = shadowOne;
8000329a:	59 21 08 00 	st.w [%a2]8,%d1
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], cm0 + deadtime, cm1);
8000329e:	99 42 14 10 	ld.a %a2,[%a4]84
800032a2:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
800032a6:	54 21       	ld.w %d1,[%a2]
800032a8:	0b 69 00 40 	add %d4,%d9,%d6
800032ac:	37 04 70 40 	extr.u %d4,%d4,0,16
800032b0:	26 02       	and %d2,%d0
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800032b2:	06 61       	sh %d1,6
800032b4:	99 42 30 00 	ld.a %a2,[%a4]48
800032b8:	01 21 00 26 	addsc.a %a2,%a2,%d1,0
    tomCh->SR0.U = shadowZero;
800032bc:	59 24 04 00 	st.w [%a2]4,%d4
    tomCh->SR1.U = shadowOne;
800032c0:	59 22 08 00 	st.w [%a2]8,%d2
}
800032c4:	1d ff a1 ff 	j 80003206 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0xc4>
                s = __maxX(s, (x - period) / 2 + 1);
800032c8:	0b 52 80 00 	sub %d0,%d2,%d5
800032cc:	06 f0       	sh %d0,-1
800032ce:	c2 10       	add %d0,1
800032d0:	0b 60 b0 61 	max.u %d6,%d0,%d6
800032d4:	1d ff c4 ff 	j 8000325c <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x11a>
        }
    }
}
800032d8:	00 90       	ret 

800032da <IfxGtm_Tom_PwmHl_init>:
{
800032da:	40 ae       	mov.aa %a14,%sp
800032dc:	20 18       	sub.a %sp,24
800032de:	40 4c       	mov.aa %a12,%a4
800032e0:	40 5d       	mov.aa %a13,%a5
    IfxGtm_Tom_Timer *timer        = config->timer;
800032e2:	cc 59       	ld.a %a15,[%a5]36
    driver->base.mode             = Ifx_Pwm_Mode_init;
800032e4:	82 52       	mov %d2,5
800032e6:	59 42 0c 00 	st.w [%a4]12,%d2
    driver->timer                 = timer;
800032ea:	ec 48       	st.a [%a4]32,%a15
    driver->base.setMode          = 0;
800032ec:	82 02       	mov %d2,0
800032ee:	e9 42 10 00 	st.b [%a4]16,%d2
    driver->base.inverted         = FALSE;
800032f2:	e9 42 1c 00 	st.b [%a4]28,%d2
    driver->base.ccxActiveState   = config->base.ccxActiveState;
800032f6:	19 52 1c 00 	ld.w %d2,[%a5]28
800032fa:	59 42 14 00 	st.w [%a4]20,%d2
    driver->base.coutxActiveState = config->base.coutxActiveState;
800032fe:	19 52 20 00 	ld.w %d2,[%a5]32
80003302:	59 42 18 00 	st.w [%a4]24,%d2
    driver->base.channelCount     = config->base.channelCount;
80003306:	39 52 08 00 	ld.bu %d2,[%a5]8
8000330a:	e9 42 1d 00 	st.b [%a4]29,%d2
    IfxGtm_Tom_PwmHl_setDeadtime(driver, config->base.deadtime);
8000330e:	54 54       	ld.w %d4,[%a5]
80003310:	6d ff aa fb 	call 80002a64 <IfxGtm_Tom_PwmHl_setDeadtime>
    IfxGtm_Tom_PwmHl_setMinPulse(driver, config->base.minPulse);
80003314:	19 d4 04 00 	ld.w %d4,[%a13]4
80003318:	40 c4       	mov.aa %a4,%a12
8000331a:	6d ff b1 fb 	call 80002a7c <IfxGtm_Tom_PwmHl_setMinPulse>
    driver->tom = &(timer->gtm->TOM[config->tom]);
8000331e:	19 d2 28 00 	ld.w %d2,[%a13]40
80003322:	1b 02 01 20 	addi %d2,%d2,16
80003326:	8f b2 00 20 	sh %d2,%d2,11
8000332a:	48 43       	ld.w %d3,[%a15]16
8000332c:	42 23       	add %d3,%d2
8000332e:	59 c3 30 00 	st.w [%a12]48,%d3
    if (config->ccx[0]->channel <= 7)
80003332:	99 d2 2c 00 	ld.a %a2,[%a13]44
80003336:	d4 22       	ld.a %a2,[%a2]
80003338:	19 22 04 00 	ld.w %d2,[%a2]4
8000333c:	8b 82 80 22 	ge %d2,%d2,8
80003340:	df 02 1c 80 	jne %d2,0,80003378 <IfxGtm_Tom_PwmHl_init+0x9e>
        pointer = (Ifx_GTM_TOM_TGC *)&tom->TGC0_GLB_CTRL;
80003344:	1b 03 03 20 	addi %d2,%d3,48
        driver->tgc = IfxGtm_Tom_Ch_getTgcPointer(driver->tom, 0);
80003348:	59 c2 34 00 	st.w [%a12]52,%d2
    maskShift = (config->ccx[0]->channel <= 7) ? 0 : 8;
8000334c:	99 d2 2c 00 	ld.a %a2,[%a13]44
80003350:	d4 22       	ld.a %a2,[%a2]
80003352:	19 22 04 00 	ld.w %d2,[%a2]4
80003356:	8b 82 80 22 	ge %d2,%d2,8
8000335a:	df 02 15 80 	jne %d2,0,80003384 <IfxGtm_Tom_PwmHl_init+0xaa>
8000335e:	82 0f       	mov %d15,0
    IfxGtm_Tom_Ch_ClkSrc clock = IfxGtm_Tom_Ch_getClockSource(timer->tom, timer->timerChannel);
80003360:	48 92       	ld.w %d2,[%a15]36
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003362:	06 62       	sh %d2,6
80003364:	c8 52       	ld.a %a2,[%a15]20
80003366:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
    clk = (IfxGtm_Tom_Ch_ClkSrc)tomCh->CTRL.B.CLK_SRC_SR;
8000336a:	54 2e       	ld.w %d14,[%a2]
8000336c:	37 0e 63 e6 	extr.u %d14,%d14,12,3
    for (channelIndex = 0; channelIndex < config->base.channelCount; channelIndex++)
80003370:	82 08       	mov %d8,0
    uint16            channelsMask = 0;
80003372:	82 09       	mov %d9,0
    for (channelIndex = 0; channelIndex < config->base.channelCount; channelIndex++)
80003374:	1d 00 af 00 	j 800034d2 <IfxGtm_Tom_PwmHl_init+0x1f8>
        pointer = (Ifx_GTM_TOM_TGC *)&tom->TGC1_GLB_CTRL;
80003378:	1b 03 23 20 	addi %d2,%d3,560
        driver->tgc = IfxGtm_Tom_Ch_getTgcPointer(driver->tom, 1);
8000337c:	59 c2 34 00 	st.w [%a12]52,%d2
80003380:	1d ff e6 ff 	j 8000334c <IfxGtm_Tom_PwmHl_init+0x72>
    maskShift = (config->ccx[0]->channel <= 7) ? 0 : 8;
80003384:	da 08       	mov %d15,8
80003386:	1d ff ed ff 	j 80003360 <IfxGtm_Tom_PwmHl_init+0x86>
            : IfxGtm_Tom_PwmHl_invertActiveState(config->base.ccxActiveState));
8000338a:	19 d2 1c 00 	ld.w %d2,[%a13]28
    return activeState == Ifx_ActiveState_low ? Ifx_ActiveState_high : Ifx_ActiveState_low;
8000338e:	8b 02 00 22 	eq %d2,%d2,0
80003392:	1d 00 cf 00 	j 80003530 <IfxGtm_Tom_PwmHl_init+0x256>
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
80003396:	82 13       	mov %d3,1
80003398:	1d 00 d2 00 	j 8000353c <IfxGtm_Tom_PwmHl_init+0x262>
            : IfxGtm_Tom_PwmHl_invertActiveState(config->base.ccxActiveState));
8000339c:	19 d2 1c 00 	ld.w %d2,[%a13]28
    return activeState == Ifx_ActiveState_low ? Ifx_ActiveState_high : Ifx_ActiveState_low;
800033a0:	8b 02 00 22 	eq %d2,%d2,0
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800033a4:	60 92       	mov.a %a2,%d9
800033a6:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
800033aa:	df 12 f1 00 	jeq %d2,1,8000358c <IfxGtm_Tom_PwmHl_init+0x2b2>
800033ae:	82 03       	mov %d3,0
800033b0:	54 22       	ld.w %d2,[%a2]
800033b2:	67 32 0b 20 	ins.t %d2,%d2,11,%d3,0
800033b6:	74 22       	st.w [%a2],%d2
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800033b8:	99 c2 30 00 	ld.a %a2,[%a12]48
800033bc:	01 29 00 26 	addsc.a %a2,%a2,%d9,0
    tomCh->CTRL.B.RST_CCU0 = (uint8)event;
800033c0:	54 22       	ld.w %d2,[%a2]
800033c2:	b7 12 01 2a 	insert %d2,%d2,1,20,1
800033c6:	74 22       	st.w [%a2],%d2
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800033c8:	99 c2 30 00 	ld.a %a2,[%a12]48
800033cc:	01 29 00 26 	addsc.a %a2,%a2,%d9,0
    tomCh->CTRL.B.TRIGOUT = (uint8)trigger;
800033d0:	54 22       	ld.w %d2,[%a2]
800033d2:	b7 02 01 2c 	insert %d2,%d2,0,24,1
800033d6:	74 22       	st.w [%a2],%d2
        IfxGtm_Tom_Ch_setCounterValue(driver->tom, channel, IfxGtm_Tom_Timer_getOffset(driver->timer));
800033d8:	19 ca 30 00 	ld.w %d10,[%a12]48
800033dc:	99 c4 20 00 	ld.a %a4,[%a12]32
800033e0:	6d ff e0 f8 	call 800025a0 <IfxGtm_Tom_Timer_getOffset>
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800033e4:	60 92       	mov.a %a2,%d9
800033e6:	01 2a 00 26 	addsc.a %a2,%a2,%d10,0
    tomCh->CN0.U = value;
800033ea:	59 22 14 00 	st.w [%a2]20,%d2
        if (config->initPins == TRUE)
800033ee:	39 d2 34 00 	ld.bu %d2,[%a13]52
800033f2:	df 12 d0 00 	jeq %d2,1,80003592 <IfxGtm_Tom_PwmHl_init+0x2b8>
        channel                     = config->coutx[channelIndex]->channel;
800033f6:	99 d2 30 00 	ld.a %a2,[%a13]48
800033fa:	01 2c 00 26 	addsc.a %a2,%a2,%d12,0
800033fe:	d4 22       	ld.a %a2,[%a2]
80003400:	19 2a 04 00 	ld.w %d10,[%a2]4
        driver->coutx[channelIndex] = channel;
80003404:	1b 18 01 30 	addi %d3,%d8,17
80003408:	06 23       	sh %d3,2
8000340a:	01 c3 00 26 	addsc.a %a2,%a12,%d3,0
8000340e:	74 2a       	st.w [%a2],%d10
        channelMask                 = 1 << (channel - maskShift);
80003410:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80003414:	0b 2a 80 30 	sub %d3,%d10,%d2
80003418:	82 1b       	mov %d11,1
8000341a:	0f 3b 00 b0 	sh %d11,%d11,%d3
8000341e:	37 0b 70 90 	extr.u %d9,%d11,0,16
        channelsMask               |= channelMask;
80003422:	a6 d9       	or %d9,%d13
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003424:	06 6a       	sh %d10,6
80003426:	99 c2 30 00 	ld.a %a2,[%a12]48
8000342a:	01 2a 00 26 	addsc.a %a2,%a2,%d10,0
    tomCh->CTRL.B.CLK_SRC_SR = (uint8)clock;
8000342e:	54 22       	ld.w %d2,[%a2]
80003430:	37 e2 03 26 	insert %d2,%d2,%d14,12,3
80003434:	74 22       	st.w [%a2],%d2
        IfxGtm_Tom_Ch_setSignalLevel(driver->tom, channel, driver->base.inverted
80003436:	19 c3 30 00 	ld.w %d3,[%a12]48
8000343a:	39 c2 1c 00 	ld.bu %d2,[%a12]28
8000343e:	df 02 cd 00 	jeq %d2,0,800035d8 <IfxGtm_Tom_PwmHl_init+0x2fe>
            ? IfxGtm_Tom_PwmHl_invertActiveState(config->base.coutxActiveState)
80003442:	19 d2 20 00 	ld.w %d2,[%a13]32
    return activeState == Ifx_ActiveState_low ? Ifx_ActiveState_high : Ifx_ActiveState_low;
80003446:	8b 02 00 22 	eq %d2,%d2,0
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
8000344a:	60 a2       	mov.a %a2,%d10
8000344c:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
80003450:	df 12 c8 00 	jeq %d2,1,800035e0 <IfxGtm_Tom_PwmHl_init+0x306>
80003454:	82 03       	mov %d3,0
80003456:	54 22       	ld.w %d2,[%a2]
80003458:	67 32 0b 20 	ins.t %d2,%d2,11,%d3,0
8000345c:	74 22       	st.w [%a2],%d2
        IfxGtm_Tom_Tgc_enableChannels(driver->tgc, channelMask, 0, TRUE);
8000345e:	19 cd 34 00 	ld.w %d13,[%a12]52
80003462:	37 0b 70 b0 	extr.u %d11,%d11,0,16
    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_ENDIS_CTRL_ENDIS_CTRL0_OFF);
80003466:	82 06       	mov %d6,0
80003468:	82 05       	mov %d5,0
8000346a:	02 b4       	mov %d4,%d11
8000346c:	6d 00 f0 02 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
        tgc->ENDIS_CTRL.U = value;
80003470:	60 d2       	mov.a %a2,%d13
80003472:	59 22 00 10 	st.w [%a2]64,%d2
        tgc->ENDIS_STAT.U = value;
80003476:	59 22 04 10 	st.w [%a2]68,%d2
        IfxGtm_Tom_Tgc_enableChannelsOutput(driver->tgc, channelMask, 0, TRUE);
8000347a:	19 cd 34 00 	ld.w %d13,[%a12]52
    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_OUTEN_CTRL_OUTEN_CTRL0_OFF);
8000347e:	82 06       	mov %d6,0
80003480:	82 05       	mov %d5,0
80003482:	02 b4       	mov %d4,%d11
80003484:	6d 00 e4 02 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
        tgc->OUTEN_CTRL.U = value;
80003488:	60 d2       	mov.a %a2,%d13
8000348a:	59 22 08 10 	st.w [%a2]72,%d2
        tgc->OUTEN_STAT.U = value;
8000348e:	59 22 0c 10 	st.w [%a2]76,%d2
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003492:	99 c2 30 00 	ld.a %a2,[%a12]48
80003496:	01 2a 00 26 	addsc.a %a2,%a2,%d10,0
    tomCh->CTRL.B.RST_CCU0 = (uint8)event;
8000349a:	54 22       	ld.w %d2,[%a2]
8000349c:	b7 12 01 2a 	insert %d2,%d2,1,20,1
800034a0:	74 22       	st.w [%a2],%d2
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800034a2:	99 c2 30 00 	ld.a %a2,[%a12]48
800034a6:	01 2a 00 26 	addsc.a %a2,%a2,%d10,0
    tomCh->CTRL.B.TRIGOUT = (uint8)trigger;
800034aa:	54 22       	ld.w %d2,[%a2]
800034ac:	b7 02 01 2c 	insert %d2,%d2,0,24,1
800034b0:	74 22       	st.w [%a2],%d2
        IfxGtm_Tom_Ch_setCounterValue(driver->tom, channel, IfxGtm_Tom_Timer_getOffset(driver->timer));
800034b2:	19 cb 30 00 	ld.w %d11,[%a12]48
800034b6:	99 c4 20 00 	ld.a %a4,[%a12]32
800034ba:	6d ff 73 f8 	call 800025a0 <IfxGtm_Tom_Timer_getOffset>
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800034be:	60 a2       	mov.a %a2,%d10
800034c0:	01 2b 00 26 	addsc.a %a2,%a2,%d11,0
    tomCh->CN0.U = value;
800034c4:	59 22 14 00 	st.w [%a2]20,%d2
        if (config->initPins == TRUE)
800034c8:	39 d2 34 00 	ld.bu %d2,[%a13]52
800034cc:	df 12 8d 00 	jeq %d2,1,800035e6 <IfxGtm_Tom_PwmHl_init+0x30c>
    for (channelIndex = 0; channelIndex < config->base.channelCount; channelIndex++)
800034d0:	c2 18       	add %d8,1
800034d2:	39 d2 08 00 	ld.bu %d2,[%a13]8
800034d6:	7f 28 ab 80 	jge.u %d8,%d2,8000362c <IfxGtm_Tom_PwmHl_init+0x352>
        channel                   = config->ccx[channelIndex]->channel;
800034da:	8f 28 00 c0 	sh %d12,%d8,2
800034de:	99 d2 2c 00 	ld.a %a2,[%a13]44
800034e2:	01 2c 00 26 	addsc.a %a2,%a2,%d12,0
800034e6:	d4 22       	ld.a %a2,[%a2]
800034e8:	19 22 04 00 	ld.w %d2,[%a2]4
        driver->ccx[channelIndex] = channel;
800034ec:	1b e8 00 30 	addi %d3,%d8,14
800034f0:	06 23       	sh %d3,2
800034f2:	01 c3 00 26 	addsc.a %a2,%a12,%d3,0
800034f6:	74 22       	st.w [%a2],%d2
        channelMask               = 1 << (channel - maskShift);
800034f8:	59 ef ec ff 	st.w [%a14]-20,%d15
800034fc:	0b f2 80 30 	sub %d3,%d2,%d15
80003500:	82 1a       	mov %d10,1
80003502:	0f 3a 00 a0 	sh %d10,%d10,%d3
80003506:	37 0a 70 d0 	extr.u %d13,%d10,0,16
        channelsMask             |= channelMask;
8000350a:	a6 9d       	or %d13,%d9
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
8000350c:	8f 62 00 90 	sh %d9,%d2,6
80003510:	99 c2 30 00 	ld.a %a2,[%a12]48
80003514:	01 29 00 26 	addsc.a %a2,%a2,%d9,0
    tomCh->CTRL.B.CLK_SRC_SR = (uint8)clock;
80003518:	54 22       	ld.w %d2,[%a2]
8000351a:	37 e2 03 26 	insert %d2,%d2,%d14,12,3
8000351e:	74 22       	st.w [%a2],%d2
        IfxGtm_Tom_Ch_setSignalLevel(driver->tom, channel, !driver->base.inverted
80003520:	19 c3 30 00 	ld.w %d3,[%a12]48
80003524:	39 c2 1c 00 	ld.bu %d2,[%a12]28
80003528:	df 02 31 ff 	jne %d2,0,8000338a <IfxGtm_Tom_PwmHl_init+0xb0>
8000352c:	19 d2 1c 00 	ld.w %d2,[%a13]28
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003530:	60 92       	mov.a %a2,%d9
80003532:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
80003536:	df 12 30 7f 	jeq %d2,1,80003396 <IfxGtm_Tom_PwmHl_init+0xbc>
8000353a:	82 03       	mov %d3,0
8000353c:	54 22       	ld.w %d2,[%a2]
8000353e:	67 32 0b 20 	ins.t %d2,%d2,11,%d3,0
80003542:	74 22       	st.w [%a2],%d2
        IfxGtm_Tom_Tgc_enableChannels(driver->tgc, channelMask, 0, TRUE); /* Write the SOUR outout with !SL */
80003544:	19 cb 34 00 	ld.w %d11,[%a12]52
80003548:	37 0a 70 a0 	extr.u %d10,%d10,0,16
    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_ENDIS_CTRL_ENDIS_CTRL0_OFF);
8000354c:	82 06       	mov %d6,0
8000354e:	82 05       	mov %d5,0
80003550:	02 a4       	mov %d4,%d10
80003552:	6d 00 7d 02 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
        tgc->ENDIS_CTRL.U = value;
80003556:	60 b2       	mov.a %a2,%d11
80003558:	59 22 00 10 	st.w [%a2]64,%d2
        tgc->ENDIS_STAT.U = value;
8000355c:	59 22 04 10 	st.w [%a2]68,%d2
        IfxGtm_Tom_Tgc_enableChannelsOutput(driver->tgc, channelMask, 0, TRUE);
80003560:	19 cb 34 00 	ld.w %d11,[%a12]52
    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_OUTEN_CTRL_OUTEN_CTRL0_OFF);
80003564:	82 06       	mov %d6,0
80003566:	82 05       	mov %d5,0
80003568:	02 a4       	mov %d4,%d10
8000356a:	6d 00 71 02 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
        tgc->OUTEN_CTRL.U = value;
8000356e:	60 b2       	mov.a %a2,%d11
80003570:	59 22 08 10 	st.w [%a2]72,%d2
        tgc->OUTEN_STAT.U = value;
80003574:	59 22 0c 10 	st.w [%a2]76,%d2
        IfxGtm_Tom_Ch_setSignalLevel(driver->tom, channel, driver->base.inverted
80003578:	19 c3 30 00 	ld.w %d3,[%a12]48
8000357c:	39 c2 1c 00 	ld.bu %d2,[%a12]28
80003580:	df 02 0e 7f 	jeq %d2,0,8000339c <IfxGtm_Tom_PwmHl_init+0xc2>
80003584:	19 d2 1c 00 	ld.w %d2,[%a13]28
80003588:	1d ff 0e ff 	j 800033a4 <IfxGtm_Tom_PwmHl_init+0xca>
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
8000358c:	82 13       	mov %d3,1
8000358e:	1d ff 11 ff 	j 800033b0 <IfxGtm_Tom_PwmHl_init+0xd6>
            IfxGtm_PinMap_setTomTout(config->ccx[channelIndex],
80003592:	99 d2 2c 00 	ld.a %a2,[%a13]44
80003596:	01 2c 00 26 	addsc.a %a2,%a2,%d12,0
8000359a:	19 d5 10 00 	ld.w %d5,[%a13]16
8000359e:	19 d4 0c 00 	ld.w %d4,[%a13]12
800035a2:	d4 24       	ld.a %a4,[%a2]
800035a4:	6d ff c0 ea 	call 80000b24 <IfxGtm_PinMap_setTomTout>
            IfxPort_setPinState(config->ccx[channelIndex]->pin.port, config->ccx[channelIndex]->pin.pinIndex, config->base.ccxActiveState ? IfxPort_State_low : IfxPort_State_high);
800035a8:	99 d2 2c 00 	ld.a %a2,[%a13]44
800035ac:	01 2c 00 26 	addsc.a %a2,%a2,%d12,0
800035b0:	d4 22       	ld.a %a2,[%a2]
800035b2:	99 23 10 00 	ld.a %a3,[%a2]16
800035b6:	39 22 14 00 	ld.bu %d2,[%a2]20
800035ba:	19 d3 1c 00 	ld.w %d3,[%a13]28
800035be:	df 03 0a 00 	jeq %d3,0,800035d2 <IfxGtm_Tom_PwmHl_init+0x2f8>
800035c2:	7b 10 00 30 	movh %d3,1
}


IFX_INLINE void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
800035c6:	0f 23 00 20 	sh %d2,%d3,%d2
800035ca:	59 32 04 00 	st.w [%a3]4,%d2
}
800035ce:	1d ff 14 ff 	j 800033f6 <IfxGtm_Tom_PwmHl_init+0x11c>
800035d2:	82 13       	mov %d3,1
800035d4:	1d ff f9 ff 	j 800035c6 <IfxGtm_Tom_PwmHl_init+0x2ec>
        IfxGtm_Tom_Ch_setSignalLevel(driver->tom, channel, driver->base.inverted
800035d8:	19 d2 20 00 	ld.w %d2,[%a13]32
800035dc:	1d ff 37 ff 	j 8000344a <IfxGtm_Tom_PwmHl_init+0x170>
800035e0:	82 13       	mov %d3,1
800035e2:	1d ff 3a ff 	j 80003456 <IfxGtm_Tom_PwmHl_init+0x17c>
            IfxGtm_PinMap_setTomTout(config->coutx[channelIndex],
800035e6:	99 d2 30 00 	ld.a %a2,[%a13]48
800035ea:	01 2c 00 26 	addsc.a %a2,%a2,%d12,0
800035ee:	19 d5 10 00 	ld.w %d5,[%a13]16
800035f2:	19 d4 0c 00 	ld.w %d4,[%a13]12
800035f6:	d4 24       	ld.a %a4,[%a2]
800035f8:	6d ff 96 ea 	call 80000b24 <IfxGtm_PinMap_setTomTout>
            IfxPort_setPinState(config->coutx[channelIndex]->pin.port, config->coutx[channelIndex]->pin.pinIndex, config->base.coutxActiveState ? IfxPort_State_low : IfxPort_State_high);
800035fc:	99 d2 30 00 	ld.a %a2,[%a13]48
80003600:	01 2c 00 26 	addsc.a %a2,%a2,%d12,0
80003604:	d4 22       	ld.a %a2,[%a2]
80003606:	99 23 10 00 	ld.a %a3,[%a2]16
8000360a:	39 22 14 00 	ld.bu %d2,[%a2]20
8000360e:	19 d3 20 00 	ld.w %d3,[%a13]32
80003612:	df 03 0a 00 	jeq %d3,0,80003626 <IfxGtm_Tom_PwmHl_init+0x34c>
80003616:	7b 10 00 30 	movh %d3,1
    port->OMR.U = action << pinIndex;
8000361a:	0f 23 00 20 	sh %d2,%d3,%d2
8000361e:	59 32 04 00 	st.w [%a3]4,%d2
}
80003622:	1d ff 57 ff 	j 800034d0 <IfxGtm_Tom_PwmHl_init+0x1f6>
80003626:	82 13       	mov %d3,1
80003628:	1d ff f9 ff 	j 8000361a <IfxGtm_Tom_PwmHl_init+0x340>
    IfxGtm_Tom_PwmHl_setMode(driver, Ifx_Pwm_Mode_off);
8000362c:	82 44       	mov %d4,4
8000362e:	40 c4       	mov.aa %a4,%a12
80003630:	6d ff 3a fa 	call 80002aa4 <IfxGtm_Tom_PwmHl_setMode>
    Ifx_TimerValue tOn[IFXGTM_TOM_PWMHL_MAX_NUM_CHANNELS] = {0};
80003634:	82 02       	mov %d2,0
80003636:	59 e2 f4 ff 	st.w [%a14]-12,%d2
8000363a:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000363e:	59 e2 fc ff 	st.w [%a14]-4,%d2
    IfxGtm_Tom_PwmHl_updateOff(driver, tOn);     /* tOn do not need defined values */
80003642:	d9 e5 f4 ff 	lea %a5,[%a14]-12
80003646:	40 c4       	mov.aa %a4,%a12
80003648:	6d ff 3d fc 	call 80002ec2 <IfxGtm_Tom_PwmHl_updateOff>
    IfxGtm_Tom_Tgc_setChannelsForceUpdate(driver->tgc, channelsMask, 0, 0, 0);
8000364c:	99 cd 34 00 	ld.a %a13,[%a12]52
    regEnable        = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_FUPD_CTRL0_OFF);
80003650:	82 06       	mov %d6,0
80003652:	82 05       	mov %d5,0
80003654:	02 94       	mov %d4,%d9
80003656:	6d 00 fb 01 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
8000365a:	02 28       	mov %d8,%d2
    regReset         = IfxGtm_Tom_Tgc_buildFeature(resetEnableMask, resetDisableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_RSTCN0_CH0_OFF);
8000365c:	3b 00 01 60 	mov %d6,16
80003660:	82 05       	mov %d5,0
80003662:	82 04       	mov %d4,0
80003664:	6d 00 f4 01 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
    tgc->FUPD_CTRL.U = regEnable | regReset;
80003668:	a6 82       	or %d2,%d8
8000366a:	59 d2 08 00 	st.w [%a13]8,%d2
    IfxGtm_Tom_Tgc_trigger(driver->tgc);
8000366e:	99 c2 34 00 	ld.a %a2,[%a12]52
    tgc->GLB_CTRL.U = 1 << IFX_GTM_TOM_TGC0_GLB_CTRL_HOST_TRIG_OFF;
80003672:	82 12       	mov %d2,1
80003674:	74 22       	st.w [%a2],%d2
    IfxGtm_Tom_Tgc_setChannelsForceUpdate(driver->tgc, 0, channelsMask, 0, 0);
80003676:	99 cd 34 00 	ld.a %a13,[%a12]52
    regEnable        = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_FUPD_CTRL0_OFF);
8000367a:	82 06       	mov %d6,0
8000367c:	02 95       	mov %d5,%d9
8000367e:	82 04       	mov %d4,0
80003680:	6d 00 e6 01 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
80003684:	02 28       	mov %d8,%d2
    regReset         = IfxGtm_Tom_Tgc_buildFeature(resetEnableMask, resetDisableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_RSTCN0_CH0_OFF);
80003686:	3b 00 01 60 	mov %d6,16
8000368a:	82 05       	mov %d5,0
8000368c:	82 04       	mov %d4,0
8000368e:	6d 00 df 01 	call 80003a4c <IfxGtm_Tom_Tgc_buildFeature>
    tgc->FUPD_CTRL.U = regEnable | regReset;
80003692:	a6 82       	or %d2,%d8
80003694:	59 d2 08 00 	st.w [%a13]8,%d2
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
80003698:	82 08       	mov %d8,0
8000369a:	1d 00 15 00 	j 800036c4 <IfxGtm_Tom_PwmHl_init+0x3ea>
        IfxGtm_Tom_Timer_addToChannelMask(timer, driver->ccx[channelIndex]);
8000369e:	1b e8 00 20 	addi %d2,%d8,14
800036a2:	06 22       	sh %d2,2
800036a4:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
800036a8:	54 24       	ld.w %d4,[%a2]
800036aa:	40 f4       	mov.aa %a4,%a15
800036ac:	6d ff 21 f7 	call 800024ee <IfxGtm_Tom_Timer_addToChannelMask>
        IfxGtm_Tom_Timer_addToChannelMask(timer, driver->coutx[channelIndex]);
800036b0:	1b 18 01 20 	addi %d2,%d8,17
800036b4:	06 22       	sh %d2,2
800036b6:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
800036ba:	54 24       	ld.w %d4,[%a2]
800036bc:	40 f4       	mov.aa %a4,%a15
800036be:	6d ff 18 f7 	call 800024ee <IfxGtm_Tom_Timer_addToChannelMask>
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
800036c2:	c2 18       	add %d8,1
800036c4:	39 c2 1d 00 	ld.bu %d2,[%a12]29
800036c8:	3f 28 eb ff 	jlt.u %d8,%d2,8000369e <IfxGtm_Tom_PwmHl_init+0x3c4>
}
800036cc:	82 12       	mov %d2,1
800036ce:	00 90       	ret 

800036d0 <IfxGtm_Tom_PwmHl_initConfig>:
{
800036d0:	40 ae       	mov.aa %a14,%sp
800036d2:	40 4c       	mov.aa %a12,%a4
    IfxStdIf_PwmHl_initConfig(&config->base);
800036d4:	6d 00 17 08 	call 80004702 <IfxStdIf_PwmHl_initConfig>
    config->timer    = NULL_PTR;
800036d8:	82 02       	mov %d2,0
800036da:	59 c2 24 00 	st.w [%a12]36,%d2
    config->tom      = IfxGtm_Tom_0;
800036de:	59 c2 28 00 	st.w [%a12]40,%d2
    config->ccx      = NULL_PTR;
800036e2:	59 c2 2c 00 	st.w [%a12]44,%d2
    config->coutx    = NULL_PTR;
800036e6:	59 c2 30 00 	st.w [%a12]48,%d2
    config->initPins = TRUE;
800036ea:	82 12       	mov %d2,1
800036ec:	e9 c2 34 00 	st.b [%a12]52,%d2
}
800036f0:	00 90       	ret 

800036f2 <IfxGtm_enable>:
    IfxScuWdt_setCpuEndinit(psw);
}


void IfxGtm_enable(Ifx_GTM *gtm)
{
800036f2:	40 ae       	mov.aa %a14,%sp
800036f4:	80 49       	mov.d %d9,%a4
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
800036f6:	6d ff 71 f5 	call 800021d8 <IfxScuWdt_getCpuWatchdogPassword>
800036fa:	02 28       	mov %d8,%d2

    IfxScuWdt_clearCpuEndinit(psw);
800036fc:	02 24       	mov %d4,%d2
800036fe:	6d ff 04 f4 	call 80001f06 <IfxScuWdt_clearCpuEndinit>
    gtm->CLC.B.DISR = 0;
80003702:	7b a0 00 20 	movh %d2,10
80003706:	1b 02 d0 2f 	addi %d2,%d2,-768
8000370a:	60 92       	mov.a %a2,%d9
8000370c:	01 22 00 46 	addsc.a %a4,%a2,%d2,0
80003710:	54 43       	ld.w %d3,[%a4]
80003712:	8f 13 c0 31 	andn %d3,%d3,1
80003716:	74 43       	st.w [%a4],%d3
    IfxScuWdt_setCpuEndinit(psw);
80003718:	02 84       	mov %d4,%d8
8000371a:	6d ff 7c f5 	call 80002212 <IfxScuWdt_setCpuEndinit>
}
8000371e:	00 90       	ret 

80003720 <IfxGtm_getSysClkFrequency>:


float32 IfxGtm_getSysClkFrequency(void)
{
80003720:	40 ae       	mov.aa %a14,%sp
}


IFX_INLINE float32 IfxScuCcu_getGtmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.GTMDIV;
80003722:	6d ff d7 f1 	call 80001ad0 <IfxScuCcu_getSourceFrequency>
80003726:	91 30 00 2f 	movh.a %a2,61443
8000372a:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
8000372e:	54 23       	ld.w %d3,[%a2]
80003730:	37 03 64 36 	extr.u %d3,%d3,12,4
80003734:	4b 03 41 31 	itof %d3,%d3
    return IfxScuCcu_getGtmFrequency();
}
80003738:	4b 32 51 20 	div.f %d2,%d2,%d3
8000373c:	00 90       	ret 

8000373e <IfxGtm_Cmu_enableClocks>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxGtm_Cmu_enableClocks(Ifx_GTM *gtm, uint32 clkMask)
{
8000373e:	40 ae       	mov.aa %a14,%sp
    gtm->CMU.CLK_EN.U = clkMask;
80003740:	59 44 00 c0 	st.w [%a4]768,%d4
}
80003744:	00 90       	ret 

80003746 <IfxGtm_Cmu_getModuleFrequency>:
    return IfxGtm_Cmu_getModuleFrequency(gtm) * multiplier;
}


float32 IfxGtm_Cmu_getModuleFrequency(Ifx_GTM *gtm)
{
80003746:	40 ae       	mov.aa %a14,%sp
    return IfxGtm_getSysClkFrequency();
80003748:	6d ff ec ff 	call 80003720 <IfxGtm_getSysClkFrequency>
}
8000374c:	00 90       	ret 

8000374e <IfxGtm_Cmu_getGclkFrequency>:
{
8000374e:	40 ae       	mov.aa %a14,%sp
    float32 N          = gtm->CMU.GCLK_DEN.B.GCLK_DEN;
80003750:	19 42 08 c0 	ld.w %d2,[%a4]776
80003754:	37 02 78 20 	extr.u %d2,%d2,0,24
80003758:	4b 02 61 81 	utof %d8,%d2
    float32 Z          = gtm->CMU.GCLK_NUM.B.GCLK_NUM;
8000375c:	19 42 04 c0 	ld.w %d2,[%a4]772
80003760:	37 02 78 20 	extr.u %d2,%d2,0,24
80003764:	4b 02 61 21 	utof %d2,%d2
    float32 multiplier = N / Z;
80003768:	4b 28 51 80 	div.f %d8,%d8,%d2
    return IfxGtm_Cmu_getModuleFrequency(gtm) * multiplier;
8000376c:	6d ff ed ff 	call 80003746 <IfxGtm_Cmu_getModuleFrequency>
}
80003770:	4b 82 41 20 	mul.f %d2,%d2,%d8
80003774:	00 90       	ret 

80003776 <IfxGtm_Cmu_isClkClockEnabled>:


boolean IfxGtm_Cmu_isClkClockEnabled(Ifx_GTM *gtm, IfxGtm_Cmu_Clk clkIndex)
{
80003776:	40 ae       	mov.aa %a14,%sp
    return ((gtm->CMU.CLK_EN.U >> (2 * clkIndex)) & IFX_GTM_CMU_CLK_EN_EN_CLK0_MSK) == 0x3;
80003778:	19 43 00 c0 	ld.w %d3,[%a4]768
8000377c:	8f 14 00 20 	sh %d2,%d4,1
80003780:	57 03 62 22 	extr.u %d2,%d3,%d2,2
}
80003784:	8b 32 00 22 	eq %d2,%d2,3
80003788:	00 90       	ret 

8000378a <IfxGtm_Cmu_getClkFrequency>:
{
8000378a:	40 ae       	mov.aa %a14,%sp
8000378c:	40 4c       	mov.aa %a12,%a4
8000378e:	02 48       	mov %d8,%d4
80003790:	8f f5 0f 91 	and %d9,%d5,255
    if ((IfxGtm_Cmu_isClkClockEnabled(gtm, clkIndex) != FALSE) || (assumeEnabled != FALSE))
80003794:	6d ff f1 ff 	call 80003776 <IfxGtm_Cmu_isClkClockEnabled>
80003798:	df 02 04 80 	jne %d2,0,800037a0 <IfxGtm_Cmu_getClkFrequency+0x16>
8000379c:	df 09 49 00 	jeq %d9,0,8000382e <IfxGtm_Cmu_getClkFrequency+0xa4>
        switch (clkIndex)
800037a0:	df 68 2c 00 	jeq %d8,6,800037f8 <IfxGtm_Cmu_getClkFrequency+0x6e>
800037a4:	ff 78 15 80 	jge.u %d8,7,800037ce <IfxGtm_Cmu_getClkFrequency+0x44>
800037a8:	ff 68 45 80 	jge.u %d8,6,80003832 <IfxGtm_Cmu_getClkFrequency+0xa8>
            frequency = IfxGtm_Cmu_getGclkFrequency(gtm) / (gtm->CMU.CLK0_5[clkIndex].CTRL.B.CLK_CNT + 1);
800037ac:	40 c4       	mov.aa %a4,%a12
800037ae:	6d ff d0 ff 	call 8000374e <IfxGtm_Cmu_getGclkFrequency>
800037b2:	1b 38 0c 30 	addi %d3,%d8,195
800037b6:	06 23       	sh %d3,2
800037b8:	01 c3 00 c6 	addsc.a %a12,%a12,%d3,0
800037bc:	54 c3       	ld.w %d3,[%a12]
800037be:	37 03 78 30 	extr.u %d3,%d3,0,24
800037c2:	c2 13       	add %d3,1
800037c4:	4b 03 41 31 	itof %d3,%d3
800037c8:	4b 32 51 20 	div.f %d2,%d2,%d3
            break;
800037cc:	00 90       	ret 
        switch (clkIndex)
800037ce:	df 78 13 80 	jne %d8,7,800037f4 <IfxGtm_Cmu_getClkFrequency+0x6a>
            if (gtm->CMU.CLK_7.CTRL.B.CLK7_SEL == 0)
800037d2:	19 c2 28 c0 	ld.w %d2,[%a12]808
800037d6:	ef 82 27 80 	jnz.t %d2,24,80003824 <IfxGtm_Cmu_getClkFrequency+0x9a>
                frequency = IfxGtm_Cmu_getGclkFrequency(gtm) / (gtm->CMU.CLK_7.CTRL.B.CLK_CNT + 1);
800037da:	40 c4       	mov.aa %a4,%a12
800037dc:	6d ff b9 ff 	call 8000374e <IfxGtm_Cmu_getGclkFrequency>
800037e0:	19 c3 28 c0 	ld.w %d3,[%a12]808
800037e4:	37 03 78 30 	extr.u %d3,%d3,0,24
800037e8:	c2 13       	add %d3,1
800037ea:	4b 03 41 31 	itof %d3,%d3
800037ee:	4b 32 51 20 	div.f %d2,%d2,%d3
800037f2:	00 90       	ret 
        switch (clkIndex)
800037f4:	82 02       	mov %d2,0
800037f6:	00 90       	ret 
            if (gtm->CMU.CLK_6.CTRL.B.CLK6_SEL == 0)
800037f8:	19 c2 24 c0 	ld.w %d2,[%a12]804
800037fc:	ef 82 0f 80 	jnz.t %d2,24,8000381a <IfxGtm_Cmu_getClkFrequency+0x90>
                frequency = IfxGtm_Cmu_getGclkFrequency(gtm) / (gtm->CMU.CLK_6.CTRL.B.CLK_CNT + 1);
80003800:	40 c4       	mov.aa %a4,%a12
80003802:	6d ff a6 ff 	call 8000374e <IfxGtm_Cmu_getGclkFrequency>
80003806:	19 c3 24 c0 	ld.w %d3,[%a12]804
8000380a:	37 03 78 30 	extr.u %d3,%d3,0,24
8000380e:	c2 13       	add %d3,1
80003810:	4b 03 41 31 	itof %d3,%d3
80003814:	4b 32 51 20 	div.f %d2,%d2,%d3
80003818:	00 90       	ret 
                frequency = IfxGtm_Dpll_getSubIncFrequency(gtm, IfxGtm_Dpll_SubInc_2);
8000381a:	82 14       	mov %d4,1
8000381c:	40 c4       	mov.aa %a4,%a12
8000381e:	6d 00 14 01 	call 80003a46 <IfxGtm_Dpll_getSubIncFrequency>
80003822:	00 90       	ret 
                frequency = IfxGtm_Dpll_getSubIncFrequency(gtm, IfxGtm_Dpll_SubInc_1);
80003824:	82 04       	mov %d4,0
80003826:	40 c4       	mov.aa %a4,%a12
80003828:	6d 00 0f 01 	call 80003a46 <IfxGtm_Dpll_getSubIncFrequency>
8000382c:	00 90       	ret 
        frequency = 0.0f;
8000382e:	82 02       	mov %d2,0
80003830:	00 90       	ret 
        switch (clkIndex)
80003832:	82 02       	mov %d2,0
}
80003834:	00 90       	ret 

80003836 <IfxGtm_Cmu_isFxClockEnabled>:
    return ((gtm->CMU.CLK_EN.U >> (2 * clkIndex + 16)) & IFX_GTM_CMU_CLK_EN_EN_CLK0_MSK) == 0x3;
}


boolean IfxGtm_Cmu_isFxClockEnabled(Ifx_GTM *gtm)
{
80003836:	40 ae       	mov.aa %a14,%sp
    return gtm->CMU.CLK_EN.B.EN_FXCLK == 0x3;
80003838:	19 42 00 c0 	ld.w %d2,[%a4]768
8000383c:	37 02 62 2b 	extr.u %d2,%d2,22,2
}
80003840:	8b 32 00 22 	eq %d2,%d2,3
80003844:	00 90       	ret 

80003846 <IfxGtm_Cmu_isFxClockEnabled_end>:
	...

80003848 <IfxGtm_Cmu_getFxClkFrequency>:
{
80003848:	40 ae       	mov.aa %a14,%sp
8000384a:	40 4c       	mov.aa %a12,%a4
8000384c:	02 49       	mov %d9,%d4
8000384e:	8f f5 0f 81 	and %d8,%d5,255
    if (IfxGtm_Cmu_isFxClockEnabled(gtm) || (assumeEnabled != FALSE))
80003852:	6d ff f2 ff 	call 80003836 <IfxGtm_Cmu_isFxClockEnabled>
80003856:	df 02 04 80 	jne %d2,0,8000385e <IfxGtm_Cmu_getFxClkFrequency+0x16>
8000385a:	df 08 57 00 	jeq %d8,0,80003908 <IfxGtm_Cmu_getFxClkFrequency+0xc0>
        fxSelect = gtm->CMU.FXCLK.CTRL.B.FXCLK_SEL;
8000385e:	19 c2 04 d0 	ld.w %d2,[%a12]836
80003862:	8f f2 00 21 	and %d2,%d2,15
80003866:	02 23       	mov %d3,%d2
        if (fxSelect == 0)
80003868:	df 02 0f 00 	jeq %d2,0,80003886 <IfxGtm_Cmu_getFxClkFrequency+0x3e>
        else if (fxSelect <= 6)
8000386c:	bf 72 24 80 	jlt.u %d2,7,800038b4 <IfxGtm_Cmu_getFxClkFrequency+0x6c>
        else if (fxSelect == 7)
80003870:	df 72 2a 00 	jeq %d2,7,800038c4 <IfxGtm_Cmu_getFxClkFrequency+0x7c>
        else if (fxSelect == 8)
80003874:	3b 80 00 20 	mov %d2,8
80003878:	5f 23 2d 00 	jeq %d3,%d2,800038d2 <IfxGtm_Cmu_getFxClkFrequency+0x8a>
            frequency = IfxGtm_Cmu_getGclkFrequency(gtm);
8000387c:	40 c4       	mov.aa %a4,%a12
8000387e:	6d ff 68 ff 	call 8000374e <IfxGtm_Cmu_getGclkFrequency>
80003882:	1d 00 05 00 	j 8000388c <IfxGtm_Cmu_getFxClkFrequency+0x44>
            frequency = IfxGtm_Cmu_getGclkFrequency(gtm);
80003886:	40 c4       	mov.aa %a4,%a12
80003888:	6d ff 63 ff 	call 8000374e <IfxGtm_Cmu_getGclkFrequency>
        switch (clkIndex)
8000388c:	ff 59 40 80 	jge.u %d9,5,8000390c <IfxGtm_Cmu_getFxClkFrequency+0xc4>
80003890:	91 00 00 28 	movh.a %a2,32768
80003894:	d9 22 a0 23 	lea %a2,[%a2]14496 <800038a0 <IfxGtm_Cmu_getFxClkFrequency+0x58>>
80003898:	01 29 02 26 	addsc.a %a2,%a2,%d9,2
8000389c:	dc 02       	ji %a2
8000389e:	00 00       	nop 
800038a0:	1d 00 37 00 	j 8000390e <IfxGtm_Cmu_getFxClkFrequency+0xc6>
800038a4:	1d 00 1e 00 	j 800038e0 <IfxGtm_Cmu_getFxClkFrequency+0x98>
800038a8:	1d 00 21 00 	j 800038ea <IfxGtm_Cmu_getFxClkFrequency+0xa2>
800038ac:	1d 00 24 00 	j 800038f4 <IfxGtm_Cmu_getFxClkFrequency+0xac>
800038b0:	1d 00 27 00 	j 800038fe <IfxGtm_Cmu_getFxClkFrequency+0xb6>
            frequency = IfxGtm_Cmu_getClkFrequency(gtm, (IfxGtm_Cmu_Clk)(fxSelect - 1), assumeEnabled);
800038b4:	02 85       	mov %d5,%d8
800038b6:	1b f2 ff 4f 	addi %d4,%d2,-1
800038ba:	40 c4       	mov.aa %a4,%a12
800038bc:	6d ff 67 ff 	call 8000378a <IfxGtm_Cmu_getClkFrequency>
800038c0:	1d ff e6 ff 	j 8000388c <IfxGtm_Cmu_getFxClkFrequency+0x44>
            frequency = IfxGtm_Cmu_getClkFrequency(gtm, IfxGtm_Cmu_Clk_6, assumeEnabled);
800038c4:	02 85       	mov %d5,%d8
800038c6:	82 64       	mov %d4,6
800038c8:	40 c4       	mov.aa %a4,%a12
800038ca:	6d ff 60 ff 	call 8000378a <IfxGtm_Cmu_getClkFrequency>
800038ce:	1d ff df ff 	j 8000388c <IfxGtm_Cmu_getFxClkFrequency+0x44>
            frequency = IfxGtm_Cmu_getClkFrequency(gtm, IfxGtm_Cmu_Clk_7, assumeEnabled);
800038d2:	02 85       	mov %d5,%d8
800038d4:	82 74       	mov %d4,7
800038d6:	40 c4       	mov.aa %a4,%a12
800038d8:	6d ff 59 ff 	call 8000378a <IfxGtm_Cmu_getClkFrequency>
800038dc:	1d ff d8 ff 	j 8000388c <IfxGtm_Cmu_getFxClkFrequency+0x44>
            frequency = frequency / 16;
800038e0:	7b 00 d8 33 	movh %d3,15744
800038e4:	4b 32 41 20 	mul.f %d2,%d2,%d3
            break;
800038e8:	00 90       	ret 
            frequency = frequency / 256;
800038ea:	7b 00 b8 33 	movh %d3,15232
800038ee:	4b 32 41 20 	mul.f %d2,%d2,%d3
            break;
800038f2:	00 90       	ret 
            frequency = frequency / 4096;
800038f4:	7b 00 98 33 	movh %d3,14720
800038f8:	4b 32 41 20 	mul.f %d2,%d2,%d3
            break;
800038fc:	00 90       	ret 
            frequency = frequency / 65536;
800038fe:	7b 00 78 33 	movh %d3,14208
80003902:	4b 32 41 20 	mul.f %d2,%d2,%d3
            break;
80003906:	00 90       	ret 
        frequency = 0.0f;
80003908:	82 02       	mov %d2,0
8000390a:	00 90       	ret 
            frequency = 0.0f;
8000390c:	82 02       	mov %d2,0
}
8000390e:	00 90       	ret 

80003910 <IfxGtm_Cmu_setClkFrequency>:
    }
}


void IfxGtm_Cmu_setClkFrequency(Ifx_GTM *gtm, IfxGtm_Cmu_Clk clkIndex, float32 frequency)
{
80003910:	40 ae       	mov.aa %a14,%sp
80003912:	40 4c       	mov.aa %a12,%a4
80003914:	02 48       	mov %d8,%d4
80003916:	02 59       	mov %d9,%d5
    float32 t   = (IfxGtm_Cmu_getGclkFrequency(gtm) / frequency) - 1;
80003918:	6d ff 1b ff 	call 8000374e <IfxGtm_Cmu_getGclkFrequency>
8000391c:	4b 92 51 50 	div.f %d5,%d2,%d9
80003920:	7b 00 f8 23 	movh %d2,16256
80003924:	6b 02 31 55 	sub.f %d5,%d5,%d2
    uint32  cnt = (uint32)t;
80003928:	4b 05 71 91 	ftouz %d9,%d5

    if ((t - (float32)cnt) > 0.5f)
8000392c:	4b 09 61 21 	utof %d2,%d9
80003930:	6b 02 31 25 	sub.f %d2,%d5,%d2
80003934:	7b 00 f0 33 	movh %d3,16128
80003938:	4b 32 01 20 	cmp.f %d2,%d2,%d3
8000393c:	6f 22 03 00 	jz.t %d2,2,80003942 <IfxGtm_Cmu_setClkFrequency+0x32>
    {                           /* Round to nearest */
        cnt++;
80003940:	c2 19       	add %d9,1
    }

    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80003942:	6d ff 4b f4 	call 800021d8 <IfxScuWdt_getCpuWatchdogPassword>
80003946:	02 2a       	mov %d10,%d2
    IfxScuWdt_clearCpuEndinit(psw);
80003948:	02 24       	mov %d4,%d2
8000394a:	6d ff de f2 	call 80001f06 <IfxScuWdt_clearCpuEndinit>

    switch (clkIndex)
8000394e:	df 68 1e 00 	jeq %d8,6,8000398a <IfxGtm_Cmu_setClkFrequency+0x7a>
80003952:	ff 78 11 80 	jge.u %d8,7,80003974 <IfxGtm_Cmu_setClkFrequency+0x64>
80003956:	ff 68 0b 80 	jge.u %d8,6,8000396c <IfxGtm_Cmu_setClkFrequency+0x5c>
    case IfxGtm_Cmu_Clk_1:
    case IfxGtm_Cmu_Clk_2:
    case IfxGtm_Cmu_Clk_3:
    case IfxGtm_Cmu_Clk_4:
    case IfxGtm_Cmu_Clk_5:
        gtm->CMU.CLK0_5[clkIndex].CTRL.B.CLK_CNT = cnt;
8000395a:	1b 38 0c 20 	addi %d2,%d8,195
8000395e:	06 22       	sh %d2,2
80003960:	01 c2 00 c6 	addsc.a %a12,%a12,%d2,0
80003964:	54 c2       	ld.w %d2,[%a12]
80003966:	37 92 18 20 	insert %d2,%d2,%d9,0,24
8000396a:	74 c2       	st.w [%a12],%d2
        break;
    default:
        break;
    }

    IfxScuWdt_setCpuEndinit(psw);
8000396c:	02 a4       	mov %d4,%d10
8000396e:	6d ff 52 f4 	call 80002212 <IfxScuWdt_setCpuEndinit>
}
80003972:	00 90       	ret 
    switch (clkIndex)
80003974:	df 78 fc ff 	jne %d8,7,8000396c <IfxGtm_Cmu_setClkFrequency+0x5c>
        gtm->CMU.CLK_7.CTRL.B.CLK_CNT = cnt;
80003978:	d9 c2 28 c0 	lea %a2,[%a12]808
8000397c:	19 c2 28 c0 	ld.w %d2,[%a12]808
80003980:	37 92 18 20 	insert %d2,%d2,%d9,0,24
80003984:	74 22       	st.w [%a2],%d2
        break;
80003986:	1d ff f3 ff 	j 8000396c <IfxGtm_Cmu_setClkFrequency+0x5c>
        gtm->CMU.CLK_6.CTRL.B.CLK_CNT = cnt;
8000398a:	d9 c2 24 c0 	lea %a2,[%a12]804
8000398e:	19 c2 24 c0 	ld.w %d2,[%a12]804
80003992:	37 92 18 20 	insert %d2,%d2,%d9,0,24
80003996:	74 22       	st.w [%a2],%d2
        break;
80003998:	1d ff ea ff 	j 8000396c <IfxGtm_Cmu_setClkFrequency+0x5c>

8000399c <IfxGtm_Cmu_setGclkFrequency>:
    IfxScuWdt_setCpuEndinit(psw);
}


void IfxGtm_Cmu_setGclkFrequency(Ifx_GTM *gtm, float32 frequency)
{
8000399c:	40 ae       	mov.aa %a14,%sp
8000399e:	40 4c       	mov.aa %a12,%a4
800039a0:	02 48       	mov %d8,%d4
    float32 f;
    float32 bestDistance = frequency;

    float32 fIn          = IfxGtm_Cmu_getModuleFrequency(gtm);
800039a2:	6d ff d2 fe 	call 80003746 <IfxGtm_Cmu_getModuleFrequency>
    float32 bestDistance = frequency;
800039a6:	02 85       	mov %d5,%d8
    uint32  z, n, nBest = 1, zBest = 1;
800039a8:	82 19       	mov %d9,1
800039aa:	02 9a       	mov %d10,%d9
    float32 t;

#if 1

    for (z = 1; z < 0xFFFFFF; z++)
800039ac:	02 94       	mov %d4,%d9
800039ae:	1d 00 22 00 	j 800039f2 <IfxGtm_Cmu_setGclkFrequency+0x56>
                bestDistance = distance;
                nBest        = n;
                zBest        = z;
            }

            if (bestDistance < 0.1f)
800039b2:	7b d0 dc 63 	movh %d6,15821
800039b6:	1b d6 cc 6c 	addi %d6,%d6,-13107
800039ba:	4b 65 01 60 	cmp.f %d6,%d5,%d6
800039be:	6f 06 16 80 	jnz.t %d6,0,800039ea <IfxGtm_Cmu_setGclkFrequency+0x4e>
        for (n = z; n > 0; n--)
800039c2:	c2 f3       	add %d3,-1
800039c4:	df 03 14 00 	jeq %d3,0,800039ec <IfxGtm_Cmu_setGclkFrequency+0x50>
            f        = t * n;
800039c8:	4b 03 61 61 	utof %d6,%d3
800039cc:	4b 06 41 60 	mul.f %d6,%d6,%d0
            distance = fabsf(frequency - f);
800039d0:	6b 06 31 68 	sub.f %d6,%d8,%d6
800039d4:	b7 06 81 6f 	insert %d6,%d6,0,31,1
            if (distance < bestDistance)
800039d8:	4b 65 01 70 	cmp.f %d7,%d5,%d6
800039dc:	6f 27 eb 7f 	jz.t %d7,2,800039b2 <IfxGtm_Cmu_setGclkFrequency+0x16>
                zBest        = z;
800039e0:	02 49       	mov %d9,%d4
                nBest        = n;
800039e2:	02 3a       	mov %d10,%d3
                bestDistance = distance;
800039e4:	02 65       	mov %d5,%d6
800039e6:	1d ff e6 ff 	j 800039b2 <IfxGtm_Cmu_setGclkFrequency+0x16>
            {
                endLoop = TRUE;
800039ea:	82 13       	mov %d3,1
                break;
            }
        }

        if (endLoop)
800039ec:	df 03 0f 80 	jne %d3,0,80003a0a <IfxGtm_Cmu_setGclkFrequency+0x6e>
    for (z = 1; z < 0xFFFFFF; z++)
800039f0:	c2 14       	add %d4,1
800039f2:	7b 00 10 30 	movh %d3,256
800039f6:	c2 e3       	add %d3,-2
800039f8:	3f 43 09 80 	jlt.u %d3,%d4,80003a0a <IfxGtm_Cmu_setGclkFrequency+0x6e>
        t = fIn / z;
800039fc:	4b 04 61 01 	utof %d0,%d4
80003a00:	4b 02 51 00 	div.f %d0,%d2,%d0
        for (n = z; n > 0; n--)
80003a04:	02 43       	mov %d3,%d4
80003a06:	1d ff df ff 	j 800039c4 <IfxGtm_Cmu_setGclkFrequency+0x28>
        }
    }

#endif

    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80003a0a:	6d ff e7 f3 	call 800021d8 <IfxScuWdt_getCpuWatchdogPassword>
80003a0e:	02 28       	mov %d8,%d2
    IfxScuWdt_clearCpuEndinit(psw);
80003a10:	02 24       	mov %d4,%d2
80003a12:	6d ff 7a f2 	call 80001f06 <IfxScuWdt_clearCpuEndinit>
    gtm->CMU.GCLK_NUM.B.GCLK_NUM = zBest;
80003a16:	b7 09 08 9c 	insert %d9,%d9,0,24,8
80003a1a:	d9 c2 04 c0 	lea %a2,[%a12]772
80003a1e:	19 c3 04 c0 	ld.w %d3,[%a12]772
80003a22:	37 93 18 30 	insert %d3,%d3,%d9,0,24
80003a26:	74 23       	st.w [%a2],%d3
    gtm->CMU.GCLK_NUM.B.GCLK_NUM = zBest;   /* write twice to be sure */
80003a28:	54 23       	ld.w %d3,[%a2]
80003a2a:	37 93 18 30 	insert %d3,%d3,%d9,0,24
80003a2e:	74 23       	st.w [%a2],%d3
    gtm->CMU.GCLK_DEN.B.GCLK_DEN = nBest;
80003a30:	d9 c2 08 c0 	lea %a2,[%a12]776
80003a34:	19 c3 08 c0 	ld.w %d3,[%a12]776
80003a38:	37 a3 18 30 	insert %d3,%d3,%d10,0,24
80003a3c:	74 23       	st.w [%a2],%d3
    IfxScuWdt_setCpuEndinit(psw);
80003a3e:	02 84       	mov %d4,%d8
80003a40:	6d ff e9 f3 	call 80002212 <IfxScuWdt_setCpuEndinit>
}
80003a44:	00 90       	ret 

80003a46 <IfxGtm_Dpll_getSubIncFrequency>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

float32 IfxGtm_Dpll_getSubIncFrequency(Ifx_GTM *gtm, IfxGtm_Dpll_SubInc index)
{
80003a46:	40 ae       	mov.aa %a14,%sp
    IFX_UNUSED_PARAMETER(gtm)
    IFX_UNUSED_PARAMETER(index)
    return 0.0F;
}
80003a48:	82 02       	mov %d2,0
80003a4a:	00 90       	ret 

80003a4c <IfxGtm_Tom_Tgc_buildFeature>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

uint32 IfxGtm_Tom_Tgc_buildFeature(uint16 enableMask, uint16 disableMask, uint8 bitfieldOffset)
{
80003a4c:	40 ae       	mov.aa %a14,%sp
    uint8  i;
    uint32 reg  = 0;
    uint32 mask = enableMask | (disableMask << 16);
80003a4e:	8f 05 01 50 	sh %d5,%d5,16
80003a52:	a6 54       	or %d4,%d5
    uint32 reg  = 0;
80003a54:	82 02       	mov %d2,0

    for (i = 0; i < IFXGTM_TOM_NUM_TGC_CHANNELS; i++)
80003a56:	82 03       	mov %d3,0
80003a58:	1d 00 06 00 	j 80003a64 <IfxGtm_Tom_Tgc_buildFeature+0x18>
        if (mask & 0x10000)
        {
            reg |= IfxGtm_FeatureControl_disable << shift;
        }

        mask = mask >> 1;
80003a5c:	06 f4       	sh %d4,-1
    for (i = 0; i < IFXGTM_TOM_NUM_TGC_CHANNELS; i++)
80003a5e:	c2 13       	add %d3,1
80003a60:	8f f3 0f 31 	and %d3,%d3,255
80003a64:	ff 83 17 80 	jge.u %d3,8,80003a92 <IfxGtm_Tom_Tgc_buildFeature+0x46>
        uint8 shift = (i * 2) + bitfieldOffset;
80003a68:	8f 13 00 50 	sh %d5,%d3,1
80003a6c:	8f f5 0f 51 	and %d5,%d5,255
80003a70:	42 65       	add %d5,%d6
80003a72:	8f f5 0f 51 	and %d5,%d5,255
        if (mask & 0x1)
80003a76:	6f 04 06 00 	jz.t %d4,0,80003a82 <IfxGtm_Tom_Tgc_buildFeature+0x36>
            reg |= IfxGtm_FeatureControl_enable << shift;
80003a7a:	82 27       	mov %d7,2
80003a7c:	0f 57 00 70 	sh %d7,%d7,%d5
80003a80:	a6 72       	or %d2,%d7
        if (mask & 0x10000)
80003a82:	ef 04 ed 7f 	jz.t %d4,16,80003a5c <IfxGtm_Tom_Tgc_buildFeature+0x10>
            reg |= IfxGtm_FeatureControl_disable << shift;
80003a86:	82 17       	mov %d7,1
80003a88:	0f 57 00 70 	sh %d7,%d7,%d5
80003a8c:	a6 72       	or %d2,%d7
80003a8e:	1d ff e7 ff 	j 80003a5c <IfxGtm_Tom_Tgc_buildFeature+0x10>
    }

    return reg;
}
80003a92:	00 90       	ret 

80003a94 <IfxCpu_Trap_memoryManagementError>:
{
80003a94:	40 ae       	mov.aa %a14,%sp
80003a96:	20 08       	sub.a %sp,8
}

IFX_INLINE void* Ifx__getA11(void)
{
    uint32 *res;
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80003a98:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80003a9a:	8f f4 0f 41 	and %d4,%d4,255
    reg.U = __mfcr(CPU_CORE_ID);
80003a9e:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80003aa2:	8f 72 00 21 	and %d2,%d2,7
80003aa6:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80003aaa:	80 22       	mov.d %d2,%a2
80003aac:	0f 54 a0 30 	or %d3,%d4,%d5
80003ab0:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_MME_HOOK(trapWatch);
80003ab4:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80003ab8:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80003aba:	0d 00 40 02 	rslcx 
    __asm("rfe");
80003abe:	00 80       	rfe 
}
80003ac0:	00 90       	ret 

80003ac2 <IfxCpu_Trap_internalProtectionError>:
{
80003ac2:	40 ae       	mov.aa %a14,%sp
80003ac4:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80003ac6:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80003ac8:	b7 14 18 44 	insert %d4,%d4,1,8,24
80003acc:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80003ad0:	8f 72 00 21 	and %d2,%d2,7
80003ad4:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80003ad8:	80 22       	mov.d %d2,%a2
80003ada:	0f 54 a0 30 	or %d3,%d4,%d5
80003ade:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_IPE_HOOK(trapWatch);
80003ae2:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80003ae6:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80003ae8:	0d 00 40 02 	rslcx 
    __asm("rfe");
80003aec:	00 80       	rfe 
}
80003aee:	00 90       	ret 

80003af0 <IfxCpu_Trap_instructionError>:
{
80003af0:	40 ae       	mov.aa %a14,%sp
80003af2:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80003af4:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80003af6:	b7 24 18 44 	insert %d4,%d4,2,8,24
80003afa:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80003afe:	8f 72 00 21 	and %d2,%d2,7
80003b02:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80003b06:	80 22       	mov.d %d2,%a2
80003b08:	0f 54 a0 30 	or %d3,%d4,%d5
80003b0c:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_IE_HOOK(trapWatch);
80003b10:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80003b14:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80003b16:	0d 00 40 02 	rslcx 
    __asm("rfe");
80003b1a:	00 80       	rfe 
}
80003b1c:	00 90       	ret 

80003b1e <IfxCpu_Trap_contextManagementError>:
{
80003b1e:	40 ae       	mov.aa %a14,%sp
80003b20:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80003b22:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80003b24:	b7 34 18 44 	insert %d4,%d4,3,8,24
80003b28:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80003b2c:	8f 72 00 21 	and %d2,%d2,7
80003b30:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80003b34:	80 22       	mov.d %d2,%a2
80003b36:	0f 54 a0 30 	or %d3,%d4,%d5
80003b3a:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_CME_HOOK(trapWatch);
80003b3e:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80003b42:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80003b44:	0d 00 40 02 	rslcx 
    __asm("rfe");
80003b48:	00 80       	rfe 
}
80003b4a:	00 90       	ret 

80003b4c <IfxCpu_Trap_busError>:
{
80003b4c:	40 ae       	mov.aa %a14,%sp
80003b4e:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80003b50:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80003b52:	b7 44 18 44 	insert %d4,%d4,4,8,24
80003b56:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80003b5a:	8f 72 00 21 	and %d2,%d2,7
80003b5e:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80003b62:	80 22       	mov.d %d2,%a2
80003b64:	0f 54 a0 30 	or %d3,%d4,%d5
80003b68:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_BE_HOOK(trapWatch);
80003b6c:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80003b70:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80003b72:	0d 00 40 02 	rslcx 
    __asm("rfe");
80003b76:	00 80       	rfe 
}
80003b78:	00 90       	ret 

80003b7a <IfxCpu_Trap_assertion>:
{
80003b7a:	40 ae       	mov.aa %a14,%sp
80003b7c:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80003b7e:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80003b80:	8f f4 0f 41 	and %d4,%d4,255
80003b84:	3b 00 50 20 	mov %d2,1280
80003b88:	a6 24       	or %d4,%d2
80003b8a:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80003b8e:	8f 72 00 21 	and %d2,%d2,7
80003b92:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80003b96:	80 22       	mov.d %d2,%a2
80003b98:	0f 54 a0 30 	or %d3,%d4,%d5
80003b9c:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_ASSERT_HOOK(trapWatch);
80003ba0:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80003ba4:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80003ba6:	0d 00 40 02 	rslcx 
    __asm("rfe");
80003baa:	00 80       	rfe 
}
80003bac:	00 90       	ret 

80003bae <IfxCpu_Trap_systemCall_Cpu0>:
{
80003bae:	40 ae       	mov.aa %a14,%sp
80003bb0:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80003bb2:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80003bb4:	b7 64 18 44 	insert %d4,%d4,6,8,24
80003bb8:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80003bbc:	8f 72 00 21 	and %d2,%d2,7
80003bc0:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80003bc4:	80 22       	mov.d %d2,%a2
80003bc6:	0f 54 a0 30 	or %d3,%d4,%d5
80003bca:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU0_HOOK(trapWatch);
80003bce:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80003bd2:	0d 00 40 02 	rslcx 
    __asm("rfe");
80003bd6:	00 80       	rfe 
}
80003bd8:	00 90       	ret 

80003bda <IfxCpu_Trap_systemCall_Cpu1>:
{
80003bda:	40 ae       	mov.aa %a14,%sp
80003bdc:	20 08       	sub.a %sp,8
80003bde:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80003be0:	b7 64 18 44 	insert %d4,%d4,6,8,24
80003be4:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80003be8:	8f 72 00 21 	and %d2,%d2,7
80003bec:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80003bf0:	80 22       	mov.d %d2,%a2
80003bf2:	0f 54 a0 30 	or %d3,%d4,%d5
80003bf6:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU1_HOOK(trapWatch);
80003bfa:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80003bfe:	0d 00 40 02 	rslcx 
    __asm("rfe");
80003c02:	00 80       	rfe 
}
80003c04:	00 90       	ret 

80003c06 <IfxCpu_Trap_systemCall_Cpu2>:
{
80003c06:	40 ae       	mov.aa %a14,%sp
80003c08:	20 08       	sub.a %sp,8
80003c0a:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80003c0c:	b7 64 18 44 	insert %d4,%d4,6,8,24
80003c10:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80003c14:	8f 72 00 21 	and %d2,%d2,7
80003c18:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80003c1c:	80 22       	mov.d %d2,%a2
80003c1e:	0f 54 a0 30 	or %d3,%d4,%d5
80003c22:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU2_HOOK(trapWatch);
80003c26:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80003c2a:	0d 00 40 02 	rslcx 
    __asm("rfe");
80003c2e:	00 80       	rfe 
}
80003c30:	00 90       	ret 

80003c32 <IfxCpu_Trap_nonMaskableInterrupt>:
{
80003c32:	40 ae       	mov.aa %a14,%sp
80003c34:	20 08       	sub.a %sp,8
80003c36:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80003c38:	b7 74 18 44 	insert %d4,%d4,7,8,24
80003c3c:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80003c40:	8f 72 00 21 	and %d2,%d2,7
80003c44:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80003c48:	80 22       	mov.d %d2,%a2
80003c4a:	0f 54 a0 30 	or %d3,%d4,%d5
80003c4e:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_NMI_HOOK(trapWatch);    
80003c52:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80003c56:	0d 00 40 02 	rslcx 
    __asm("rfe");
80003c5a:	00 80       	rfe 
}
80003c5c:	00 90       	ret 

80003c5e <IfxCpu_getIndex>:
    return cpuMode;
}


IfxCpu_ResourceCpu IfxCpu_getIndex(Ifx_CPU *cpu)
{
80003c5e:	40 ae       	mov.aa %a14,%sp
    IfxCpu_ResourceCpu result;
    uint32             index;
    result = IfxCpu_ResourceCpu_none;

    for (index = 0; index < IFXCPU_NUM_MODULES; index++)
80003c60:	82 02       	mov %d2,0
80003c62:	1d 00 03 00 	j 80003c68 <IfxCpu_getIndex+0xa>
80003c66:	c2 12       	add %d2,1
80003c68:	ff 32 18 80 	jge.u %d2,3,80003c98 <IfxCpu_getIndex+0x3a>
    {
        if (IfxCpu_cfg_indexMap[index].module == cpu)
80003c6c:	8f 32 00 30 	sh %d3,%d2,3
80003c70:	91 00 00 28 	movh.a %a2,32768
80003c74:	d9 22 20 a0 	lea %a2,[%a2]672 <800002a0 <IfxCpu_cfg_indexMap>>
80003c78:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80003c7c:	54 23       	ld.w %d3,[%a2]
80003c7e:	80 44       	mov.d %d4,%a4
80003c80:	5f 43 f3 ff 	jne %d3,%d4,80003c66 <IfxCpu_getIndex+0x8>
        {
            result = (IfxCpu_ResourceCpu)IfxCpu_cfg_indexMap[index].index;
80003c84:	06 32       	sh %d2,3
80003c86:	91 00 00 28 	movh.a %a2,32768
80003c8a:	d9 22 20 a0 	lea %a2,[%a2]672 <800002a0 <IfxCpu_cfg_indexMap>>
80003c8e:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80003c92:	19 22 04 00 	ld.w %d2,[%a2]4
            break;
80003c96:	00 90       	ret 
    result = IfxCpu_ResourceCpu_none;
80003c98:	82 32       	mov %d2,3
        }
    }

    return result;
}
80003c9a:	00 90       	ret 

80003c9c <IfxCpu_getCoreMode>:
{
80003c9c:	40 ae       	mov.aa %a14,%sp
80003c9e:	80 48       	mov.d %d8,%a4
    IfxCpu_ResourceCpu index = IfxCpu_getIndex(cpu);
80003ca0:	6d ff df ff 	call 80003c5e <IfxCpu_getIndex>


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80003ca4:	4d c0 e1 3f 	mfcr %d3,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80003ca8:	8f 73 00 31 	and %d3,%d3,7
    if (IfxCpu_getCoreIndex() != index)
80003cac:	5f 32 22 00 	jeq %d2,%d3,80003cf0 <IfxCpu_getCoreMode+0x54>
        dbgsr = cpu->DBGSR;
80003cb0:	bb 00 d0 3f 	mov.u %d3,64768
80003cb4:	60 82       	mov.a %a2,%d8
80003cb6:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80003cba:	54 23       	ld.w %d3,[%a2]
    if (dbgsr.B.HALT == (uint32)IfxCpu_DBGST_HALT_halt)
80003cbc:	37 03 e2 40 	extr.u %d4,%d3,1,2
80003cc0:	df 14 1c 00 	jeq %d4,1,80003cf8 <IfxCpu_getCoreMode+0x5c>
        if (dbgsr.B.HALT == (uint32)IfxCpu_DBGST_HALT_run)
80003cc4:	df 04 1c 80 	jne %d4,0,80003cfc <IfxCpu_getCoreMode+0x60>
            pmcsr_val = &MODULE_SCU.PMCSR[index];
80003cc8:	06 22       	sh %d2,2
80003cca:	7b 30 00 3f 	movh %d3,61443
80003cce:	1b 43 0d 36 	addi %d3,%d3,24788
80003cd2:	60 32       	mov.a %a2,%d3
80003cd4:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
            if (pmcsr_val->B.PMST == (uint32)IfxCpu_PMCSR_PMST_normalMode)
80003cd8:	54 22       	ld.w %d2,[%a2]
80003cda:	37 02 63 24 	extr.u %d2,%d2,8,3
80003cde:	df 12 11 00 	jeq %d2,1,80003d00 <IfxCpu_getCoreMode+0x64>
                if (pmcsr_val->B.PMST == (uint32)IfxCpu_PMCSR_PMST_idleMode)
80003ce2:	54 22       	ld.w %d2,[%a2]
80003ce4:	37 02 63 24 	extr.u %d2,%d2,8,3
80003ce8:	df 32 0e 00 	jeq %d2,3,80003d04 <IfxCpu_getCoreMode+0x68>
    cpuMode = IfxCpu_CoreMode_unknown;
80003cec:	82 52       	mov %d2,5
80003cee:	00 90       	ret 
        dbgsr.U = __mfcr(CPU_DBGSR);
80003cf0:	4d 00 d0 3f 	mfcr %d3,$dbgsr
80003cf4:	1d ff e4 ff 	j 80003cbc <IfxCpu_getCoreMode+0x20>
        cpuMode = IfxCpu_CoreMode_halt;
80003cf8:	82 02       	mov %d2,0
80003cfa:	00 90       	ret 
            cpuMode = IfxCpu_CoreMode_unknown;
80003cfc:	82 52       	mov %d2,5
80003cfe:	00 90       	ret 
                cpuMode = IfxCpu_CoreMode_run;
80003d00:	82 12       	mov %d2,1
80003d02:	00 90       	ret 
                    cpuMode = IfxCpu_CoreMode_idle;
80003d04:	82 22       	mov %d2,2
}
80003d06:	00 90       	ret 

80003d08 <IfxCpu_setCoreMode>:
    *lock = 0;
}


boolean IfxCpu_setCoreMode(Ifx_CPU *cpu, IfxCpu_CoreMode mode)
{
80003d08:	40 ae       	mov.aa %a14,%sp
80003d0a:	80 4c       	mov.d %d12,%a4
80003d0c:	02 48       	mov %d8,%d4
    uint8              reqslp;
    boolean            retValue;
    IfxCpu_ResourceCpu index = IfxCpu_getIndex(cpu);
80003d0e:	6d ff a8 ff 	call 80003c5e <IfxCpu_getIndex>
80003d12:	02 2a       	mov %d10,%d2

    /*Modes such as HALT, SLEEP and STBY are not handled at CPU level */
    retValue = ((mode == IfxCpu_CoreMode_halt) || (mode == IfxCpu_CoreMode_sleep)
80003d14:	8b 08 20 42 	ne %d4,%d8,0
80003d18:	8b 38 20 32 	ne %d3,%d8,3
80003d1c:	26 43       	and %d3,%d4
                || (mode == IfxCpu_CoreMode_stby)) ? FALSE : TRUE;
80003d1e:	df 03 0a 00 	jeq %d3,0,80003d32 <IfxCpu_setCoreMode+0x2a>
80003d22:	df 48 05 00 	jeq %d8,4,80003d2c <IfxCpu_setCoreMode+0x24>
80003d26:	82 19       	mov %d9,1
80003d28:	1d 00 06 00 	j 80003d34 <IfxCpu_setCoreMode+0x2c>
80003d2c:	82 09       	mov %d9,0
80003d2e:	1d 00 03 00 	j 80003d34 <IfxCpu_setCoreMode+0x2c>
80003d32:	82 09       	mov %d9,0
    retValue = ((mode == IfxCpu_CoreMode_halt) || (mode == IfxCpu_CoreMode_sleep)
80003d34:	8f f9 0f 91 	and %d9,%d9,255

    reqslp = (mode == IfxCpu_CoreMode_idle) ? IfxScu_PMCSR_REQSLP_Idle : IfxScu_PMCSR_REQSLP_Run;
80003d38:	8b 28 00 82 	eq %d8,%d8,2

    if (retValue == TRUE)
80003d3c:	df 09 04 80 	jne %d9,0,80003d44 <IfxCpu_setCoreMode+0x3c>
            IfxScuWdt_setCpuEndinit(cpuWdtPw);
        }
    }

    return retValue;
}
80003d40:	02 92       	mov %d2,%d9
80003d42:	00 90       	ret 
    reg.U = __mfcr(CPU_CORE_ID);
80003d44:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80003d48:	8f 72 00 21 	and %d2,%d2,7
        if (IfxCpu_getCoreIndex() != index)
80003d4c:	5f 2a 24 00 	jeq %d10,%d2,80003d94 <IfxCpu_setCoreMode+0x8c>
            uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
80003d50:	6d ff 56 f2 	call 800021fc <IfxScuWdt_getSafetyWatchdogPassword>
80003d54:	02 2b       	mov %d11,%d2
            IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
80003d56:	02 24       	mov %d4,%d2
80003d58:	6d ff fc f0 	call 80001f50 <IfxScuWdt_clearSafetyEndinit>
            MODULE_SCU.PMCSR[(uint32)IfxCpu_getIndex(cpu)].B.REQSLP = reqslp;
80003d5c:	1b 5a 03 20 	addi %d2,%d10,53
80003d60:	06 22       	sh %d2,2
80003d62:	7b 30 00 3f 	movh %d3,61443
80003d66:	1b 03 00 36 	addi %d3,%d3,24576
80003d6a:	60 32       	mov.a %a2,%d3
80003d6c:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80003d70:	54 23       	ld.w %d3,[%a2]
80003d72:	37 83 02 30 	insert %d3,%d3,%d8,0,2
80003d76:	74 23       	st.w [%a2],%d3
            IfxScuWdt_setSafetyEndinit(safetyWdtPw);
80003d78:	02 b4       	mov %d4,%d11
80003d7a:	6d ff 71 f2 	call 8000225c <IfxScuWdt_setSafetyEndinit>
            cpu->DBGSR.B.HALT = 2; /*reset the HALT bit, if it is already done it is no harm in writing again */
80003d7e:	bb 00 d0 2f 	mov.u %d2,64768
80003d82:	60 c2       	mov.a %a2,%d12
80003d84:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80003d88:	54 22       	ld.w %d2,[%a2]
80003d8a:	b7 22 82 20 	insert %d2,%d2,2,1,2
80003d8e:	74 22       	st.w [%a2],%d2
80003d90:	1d ff d8 ff 	j 80003d40 <IfxCpu_setCoreMode+0x38>
            uint16 cpuWdtPw = IfxScuWdt_getCpuWatchdogPassword();
80003d94:	6d ff 22 f2 	call 800021d8 <IfxScuWdt_getCpuWatchdogPassword>
80003d98:	02 2b       	mov %d11,%d2
            IfxScuWdt_clearCpuEndinit(cpuWdtPw);
80003d9a:	02 24       	mov %d4,%d2
80003d9c:	6d ff b5 f0 	call 80001f06 <IfxScuWdt_clearCpuEndinit>
            MODULE_SCU.PMCSR[(uint32)index].B.REQSLP = reqslp;
80003da0:	1b 5a 03 20 	addi %d2,%d10,53
80003da4:	06 22       	sh %d2,2
80003da6:	7b 30 00 3f 	movh %d3,61443
80003daa:	1b 03 00 36 	addi %d3,%d3,24576
80003dae:	60 32       	mov.a %a2,%d3
80003db0:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80003db4:	54 23       	ld.w %d3,[%a2]
80003db6:	37 83 02 30 	insert %d3,%d3,%d8,0,2
80003dba:	74 23       	st.w [%a2],%d3
            IfxScuWdt_setCpuEndinit(cpuWdtPw);
80003dbc:	02 b4       	mov %d4,%d11
80003dbe:	6d ff 2a f2 	call 80002212 <IfxScuWdt_setCpuEndinit>
80003dc2:	1d ff bf ff 	j 80003d40 <IfxCpu_setCoreMode+0x38>

80003dc6 <IfxCpu_setProgramCounter>:


boolean IfxCpu_setProgramCounter(Ifx_CPU *cpu, uint32 programCounter)
{
80003dc6:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
80003dc8:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80003dcc:	8f 72 00 21 	and %d2,%d2,7
    if (cpu < IfxCpu_ResourceCpu_none)
80003dd0:	ff 32 17 80 	jge.u %d2,3,80003dfe <IfxCpu_setProgramCounter+0x38>
        module = (Ifx_CPU *)IfxCpu_cfg_indexMap[cpu].module;
80003dd4:	06 32       	sh %d2,3
80003dd6:	91 00 00 28 	movh.a %a2,32768
80003dda:	d9 22 20 a0 	lea %a2,[%a2]672 <800002a0 <IfxCpu_cfg_indexMap>>
80003dde:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80003de2:	54 22       	ld.w %d2,[%a2]
    boolean retVal = TRUE;

    if (cpu == IfxCpu_getAddress(IfxCpu_getCoreIndex()))
80003de4:	80 43       	mov.d %d3,%a4
80003de6:	5f 23 0f 00 	jeq %d3,%d2,80003e04 <IfxCpu_setProgramCounter+0x3e>
    {
        retVal = FALSE;
    }
    else
    {
        cpu->PC.B.PC = programCounter >> 1;
80003dea:	bb 80 e0 2f 	mov.u %d2,65032
80003dee:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
80003df2:	54 42       	ld.w %d2,[%a4]
80003df4:	37 24 01 20 	insert %d2,%d4,%d2,0,1
80003df8:	74 42       	st.w [%a4],%d2
    boolean retVal = TRUE;
80003dfa:	82 12       	mov %d2,1
80003dfc:	00 90       	ret 
        module = NULL_PTR;
80003dfe:	82 02       	mov %d2,0
80003e00:	1d ff f2 ff 	j 80003de4 <IfxCpu_setProgramCounter+0x1e>
        retVal = FALSE;
80003e04:	82 02       	mov %d2,0
    }

    return retVal;
}
80003e06:	00 90       	ret 

80003e08 <IfxCpu_startCore>:
    return retVal;
}


boolean IfxCpu_startCore(Ifx_CPU *cpu, uint32 programCounter)
{
80003e08:	40 ae       	mov.aa %a14,%sp
80003e0a:	80 49       	mov.d %d9,%a4
    boolean retVal = TRUE;

    /* Set the PC for Core 1 */
    retVal &= IfxCpu_setProgramCounter(cpu, programCounter);
80003e0c:	6d ff dd ff 	call 80003dc6 <IfxCpu_setProgramCounter>
80003e10:	8f 12 00 81 	and %d8,%d2,1
    /* Get the mode for Core 1 and set it to RUNNING */

    /* Core not running already */
    if (IfxCpu_getCoreMode(cpu) == IfxCpu_CoreMode_halt)
80003e14:	60 94       	mov.a %a4,%d9
80003e16:	6d ff 43 ff 	call 80003c9c <IfxCpu_getCoreMode>
80003e1a:	df 02 04 00 	jeq %d2,0,80003e22 <IfxCpu_startCore+0x1a>
    {
        retVal &= IfxCpu_setCoreMode(cpu, IfxCpu_CoreMode_run);
    }

    return retVal;
}
80003e1e:	02 82       	mov %d2,%d8
80003e20:	00 90       	ret 
        retVal &= IfxCpu_setCoreMode(cpu, IfxCpu_CoreMode_run);
80003e22:	82 14       	mov %d4,1
80003e24:	60 94       	mov.a %a4,%d9
80003e26:	6d ff 71 ff 	call 80003d08 <IfxCpu_setCoreMode>
80003e2a:	26 28       	and %d8,%d2
80003e2c:	1d ff f9 ff 	j 80003e1e <IfxCpu_startCore+0x16>

80003e30 <IfxCpu_waitEvent>:


boolean IfxCpu_waitEvent(IfxCpu_syncEvent *event, uint32 timeoutMilliSec)
{
80003e30:	40 ae       	mov.aa %a14,%sp
80003e32:	40 4c       	mov.aa %a12,%a4
80003e34:	02 48       	mov %d8,%d4
    volatile uint32 *sync          = (volatile uint32 *)IFXCPU_GLB_ADDR_DSPR(__mfcr(CPU_CORE_ID), event);
80003e36:	80 42       	mov.d %d2,%a4
80003e38:	b7 02 1c 20 	insert %d2,%d2,0,0,28
80003e3c:	7b 00 00 3d 	movh %d3,53248
80003e40:	5f 32 28 00 	jeq %d2,%d3,80003e90 <IfxCpu_waitEvent+0x60>
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
80003e44:	6d ff 46 ee 	call 80001ad0 <IfxScuCcu_getSourceFrequency>
80003e48:	91 30 00 2f 	movh.a %a2,61443
80003e4c:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
80003e50:	54 23       	ld.w %d3,[%a2]
80003e52:	37 03 64 34 	extr.u %d3,%d3,8,4
80003e56:	4b 03 41 31 	itof %d3,%d3
80003e5a:	4b 32 51 20 	div.f %d2,%d2,%d3

    boolean          errorcnt      = 0U;
    /* Divide with 1000, gives the count value equivalent to milliseconds */
    uint32           stmCount      = (uint32)((IfxScuCcu_getStmFrequency() / 1000) * timeoutMilliSec);
80003e5e:	7b a0 47 34 	movh %d3,17530
80003e62:	4b 32 51 20 	div.f %d2,%d2,%d3
80003e66:	4b 08 61 41 	utof %d4,%d8
80003e6a:	4b 24 41 40 	mul.f %d4,%d4,%d2
80003e6e:	4b 04 71 31 	ftouz %d3,%d4
    uint32           stmCountBegin = STM0_TIM0.U;
80003e72:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x5fff8010>

    while ((*sync & IFXCPU_CFG_ALLCORE_DONE) != IFXCPU_CFG_ALLCORE_DONE)
80003e76:	54 c2       	ld.w %d2,[%a12]
80003e78:	8f 72 00 21 	and %d2,%d2,7
80003e7c:	df 72 18 00 	jeq %d2,7,80003eac <IfxCpu_waitEvent+0x7c>
    __asm__ volatile ("nop" : : : "memory");
80003e80:	00 00       	nop 
    {
        __nop();

        if ((uint32)(STM0_TIM0.U - stmCountBegin) >= stmCount)
80003e82:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x5fff8010>
80003e86:	a2 42       	sub %d2,%d4
80003e88:	3f 32 f7 ff 	jlt.u %d2,%d3,80003e76 <IfxCpu_waitEvent+0x46>
        {
            errorcnt = 1;
80003e8c:	82 12       	mov %d2,1
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }

    return errorcnt;
}
80003e8e:	00 90       	ret 
    volatile uint32 *sync          = (volatile uint32 *)IFXCPU_GLB_ADDR_DSPR(__mfcr(CPU_CORE_ID), event);
80003e90:	80 42       	mov.d %d2,%a4
80003e92:	b7 02 0c 3a 	insert %d3,%d2,0,20,12
80003e96:	b7 f3 03 3e 	insert %d3,%d3,15,28,3
80003e9a:	4d c0 e1 2f 	mfcr %d2,$core_id
80003e9e:	8f c2 01 20 	sh %d2,%d2,28
80003ea2:	0b 23 80 20 	sub %d2,%d3,%d2
80003ea6:	60 2c       	mov.a %a12,%d2
80003ea8:	1d ff ce ff 	j 80003e44 <IfxCpu_waitEvent+0x14>
    boolean          errorcnt      = 0U;
80003eac:	82 02       	mov %d2,0
80003eae:	00 90       	ret 

80003eb0 <IfxCpu_emitEvent>:


void IfxCpu_emitEvent(IfxCpu_syncEvent *event)
{
80003eb0:	40 ae       	mov.aa %a14,%sp
    Ifx__imaskldmst(event, 1, __mfcr(CPU_CORE_ID), 1);
80003eb2:	4d c0 e1 2f 	mfcr %d2,$core_id
80003eb6:	82 13       	mov %d3,1
80003eb8:	57 30 21 22 	imask %e2,%d3,%d2,1
80003ebc:	49 42 40 08 	ldmst [%a4]0,%e2
}
80003ec0:	00 90       	ret 

80003ec2 <Ifx_Cpp_Init>:
#pragma section
#elif defined(__DCC__)
#pragma section CONST
#endif
static void Ifx_Cpp_Init(void)
{
80003ec2:	40 ae       	mov.aa %a14,%sp
    Ifx_C_Init();           /*Initialization of C runtime variables */
80003ec4:	6d 00 5a 04 	call 80004778 <Ifx_C_Init>
#elif defined (__HIGHTEC__)
extern void _init(void); /* cpp initialization */
    _init();
#elif defined (__GNUC__) && !defined(__HIGHTEC__)
    extern void _init(void); /* cpp initialization */
    _init();
80003ec8:	6d 00 3a 0c 	call 8000573c <_init>
#endif
}
80003ecc:	00 90       	ret 

80003ece <hardware_init_hook>:
{}
80003ece:	00 90       	ret 

80003ed0 <software_init_hook>:
{}
80003ed0:	00 90       	ret 

80003ed2 <_Core0_start>:
    uint16 password;

    /* Read Password from CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
80003ed2:	91 30 00 2f 	movh.a %a2,61443
80003ed6:	19 22 00 46 	ld.w %d2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
    __setareg(sp, __USTACK(0));
80003eda:	91 20 00 37 	movh.a %a3,28674
80003ede:	37 02 6e 21 	extr.u %d2,%d2,2,14
80003ee2:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
80003ee6:	8f f2 83 81 	xor %d8,%d2,63
80003eea:	80 32       	mov.d %d2,%a3
80003eec:	1b 02 60 29 	addi %d2,%d2,-27136
80003ef0:	60 2a       	mov.a %sp,%d2
    __asm__ volatile ("dsync" : : : "memory");
80003ef2:	0d 00 80 04 	dsync 
    __mtcr(CPU_PSW, IFXCSTART0_PSW_DEFAULT);
80003ef6:	3b 00 98 20 	mov %d2,2432
80003efa:	cd 42 e0 0f 	mtcr $psw,%d2
    pcxi  = __mfcr(CPU_PCXI);
80003efe:	4d 00 e0 2f 	mfcr %d2,$pcxi
    pcxi &= IFXCSTART0_PCX_O_S_DEFAULT; /*0xfff00000; */
80003f02:	b7 02 14 20 	insert %d2,%d2,0,0,20
    __mtcr(CPU_PCXI, pcxi);
80003f06:	cd 02 e0 0f 	mtcr $pcxi,%d2
    if (enable)
    {                           /* Step 3: Initiate invalidation of current cache contents if any */
        Ifx_CPU_PCON1 pcon1;
        pcon1.U       = 0;
        pcon1.B.PCINV = 1;
        __mtcr(CPU_PCON1, pcon1.U);
80003f0a:	82 12       	mov %d2,1
80003f0c:	cd 42 20 09 	mtcr $pcon1,%d2
    reg.U = __mfcr(CPU_CORE_ID);
80003f10:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80003f14:	8f 72 00 21 	and %d2,%d2,7
    }

    uint32 coreIndex   = IfxCpu_getCoreIndex();
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80003f18:	01 22 03 26 	addsc.a %a2,%a2,%d2,3
80003f1c:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
80003f20:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
80003f22:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
80003f24:	37 02 6e 21 	extr.u %d2,%d2,2,14
    /*PCACHE enable steps */
    {                           /* Step 1: Set PCBYP to 0 if cache is enabled */
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
80003f28:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
80003f2c:	6f 13 41 81 	jnz.t %d3,1,800041ae <_Core0_start+0x2dc>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80003f30:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80003f34:	54 22       	ld.w %d2,[%a2]
80003f36:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80003f3a:	a6 32       	or %d2,%d3
80003f3c:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80003f40:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80003f42:	54 22       	ld.w %d2,[%a2]
80003f44:	6f 02 ff ff 	jnz.t %d2,0,80003f42 <_Core0_start+0x70>
        Ifx_CPU_PCON0 pcon0;
        pcon0.U       = 0;
        pcon0.B.PCBYP = enable ? 0 : 1; /*depending on the enable bypass bit is reset/set */
        __mtcr(CPU_PCON0, pcon0.U);
80003f48:	82 02       	mov %d2,0
80003f4a:	cd c2 20 09 	mtcr $pcon0,%d2
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80003f4e:	54 22       	ld.w %d2,[%a2]
80003f50:	6f 12 09 00 	jz.t %d2,1,80003f62 <_Core0_start+0x90>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80003f54:	54 22       	ld.w %d2,[%a2]
80003f56:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80003f5a:	a6 32       	or %d2,%d3
80003f5c:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80003f60:	74 22       	st.w [%a2],%d2

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80003f62:	54 22       	ld.w %d2,[%a2]
80003f64:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80003f68:	a6 32       	or %d2,%d3
80003f6a:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80003f6e:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80003f70:	54 22       	ld.w %d2,[%a2]
80003f72:	6f 02 ff 7f 	jz.t %d2,0,80003f70 <_Core0_start+0x9e>
    __asm__ volatile ("isync" : : : "memory");
80003f76:	0d 00 c0 04 	isync 
    reg.U = __mfcr(CPU_CORE_ID);
80003f7a:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80003f7e:	7b 30 00 3f 	movh %d3,61443
80003f82:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80003f86:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80003f8a:	13 c2 20 23 	madd %d2,%d3,%d2,12
80003f8e:	60 22       	mov.a %a2,%d2
    password  = watchdog->CON0.B.PW;
80003f90:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
80003f92:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
80003f94:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
80003f98:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
80003f9c:	6f 13 fd 80 	jnz.t %d3,1,80004196 <_Core0_start+0x2c4>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80003fa0:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80003fa4:	54 22       	ld.w %d2,[%a2]
80003fa6:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80003faa:	a6 32       	or %d2,%d3
80003fac:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80003fb0:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80003fb2:	54 22       	ld.w %d2,[%a2]
80003fb4:	6f 02 ff ff 	jnz.t %d2,0,80003fb2 <_Core0_start+0xe0>
        __mtcr(CPU_DCON0, dcon0.U);
80003fb8:	82 22       	mov %d2,2
80003fba:	cd 02 04 09 	mtcr $dcon0,%d2
    if (watchdog->CON0.B.LCK)
80003fbe:	54 22       	ld.w %d2,[%a2]
80003fc0:	6f 12 09 00 	jz.t %d2,1,80003fd2 <_Core0_start+0x100>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80003fc4:	54 22       	ld.w %d2,[%a2]
80003fc6:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80003fca:	a6 32       	or %d2,%d3
80003fcc:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80003fd0:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80003fd2:	54 22       	ld.w %d2,[%a2]
80003fd4:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80003fd8:	a6 32       	or %d2,%d3
80003fda:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80003fde:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80003fe0:	54 22       	ld.w %d2,[%a2]
80003fe2:	6f 02 ff 7f 	jz.t %d2,0,80003fe0 <_Core0_start+0x10e>
80003fe6:	0d 00 c0 04 	isync 
    if (watchdog->CON0.B.LCK)
80003fea:	91 30 00 2f 	movh.a %a2,61443
80003fee:	19 22 00 46 	ld.w %d2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
80003ff2:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80003ff6:	8f 28 00 30 	sh %d3,%d8,2
    if (watchdog->CON0.B.LCK)
80003ffa:	6f 12 09 00 	jz.t %d2,1,8000400c <_Core0_start+0x13a>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80003ffe:	54 22       	ld.w %d2,[%a2]
80004000:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004004:	a6 32       	or %d2,%d3
80004006:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000400a:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000400c:	91 30 00 2f 	movh.a %a2,61443
80004010:	19 22 00 46 	ld.w %d2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
80004014:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
80004018:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000401c:	a6 32       	or %d2,%d3
8000401e:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80004022:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80004024:	54 22       	ld.w %d2,[%a2]
80004026:	6f 02 ff ff 	jnz.t %d2,0,80004024 <_Core0_start+0x152>
    __mtcr(CPU_BTV, (uint32)__TRAPTAB(0));
8000402a:	91 00 00 38 	movh.a %a3,32768
8000402e:	80 32       	mov.d %d2,%a3
80004030:	1b 02 10 20 	addi %d2,%d2,256
80004034:	cd 42 e2 0f 	mtcr $btv,%d2
    __mtcr(CPU_BIV, (uint32)__INTTAB(0));
80004038:	91 f0 01 38 	movh.a %a3,32799
8000403c:	80 32       	mov.d %d2,%a3
8000403e:	1b 02 00 24 	addi %d2,%d2,16384
80004042:	cd 02 e2 0f 	mtcr $biv,%d2
    __mtcr(CPU_ISP, (uint32)__ISTACK(0));
80004046:	91 20 00 37 	movh.a %a3,28674
8000404a:	80 32       	mov.d %d2,%a3
8000404c:	1b 02 b0 29 	addi %d2,%d2,-25856
80004050:	cd 82 e2 0f 	mtcr $isp,%d2
    if (watchdog->CON0.B.LCK)
80004054:	54 22       	ld.w %d2,[%a2]
80004056:	6f 12 09 00 	jz.t %d2,1,80004068 <_Core0_start+0x196>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000405a:	54 22       	ld.w %d2,[%a2]
8000405c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004060:	a6 32       	or %d2,%d3
80004062:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80004066:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80004068:	91 30 00 2f 	movh.a %a2,61443
8000406c:	19 22 00 46 	ld.w %d2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
80004070:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
80004074:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004078:	a6 32       	or %d2,%d3
8000407a:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000407e:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80004080:	54 22       	ld.w %d2,[%a2]
80004082:	6f 02 ff 7f 	jz.t %d2,0,80004080 <_Core0_start+0x1ae>
    __setareg(a0, __SDATA1(0));
80004086:	91 10 00 26 	movh.a %a2,24577
8000408a:	80 22       	mov.d %d2,%a2
8000408c:	1b 02 00 28 	addi %d2,%d2,-32768
80004090:	60 20       	mov.a %a0,%d2
    __setareg(a1, __SDATA2(0));
80004092:	91 10 00 28 	movh.a %a2,32769
80004096:	80 22       	mov.d %d2,%a2
80004098:	1b 02 00 28 	addi %d2,%d2,-32768
8000409c:	60 21       	mov.a %a1,%d2
    __setareg(a8, __SDATA3(0));
8000409e:	91 10 00 28 	movh.a %a2,32769
800040a2:	80 22       	mov.d %d2,%a2
800040a4:	1b 02 00 28 	addi %d2,%d2,-32768
800040a8:	60 28       	mov.a %a8,%d2
    __setareg(a9, __SDATA4(0));
800040aa:	91 10 00 29 	movh.a %a2,36865
800040ae:	80 22       	mov.d %d2,%a2
800040b0:	1b 02 00 28 	addi %d2,%d2,-32768
800040b4:	60 29       	mov.a %a9,%d2
    uint32  numOfCsa    = (((uint32)csaEnd - (uint32)csaBegin) / 64U);
800040b6:	91 20 00 37 	movh.a %a3,28674
800040ba:	91 20 00 27 	movh.a %a2,28674
800040be:	d9 33 c0 09 	lea %a3,[%a3]-25600 <70019c00 <__CSA0>>
800040c2:	d9 22 c0 0b 	lea %a2,[%a2]-17408 <7001bc00 <__CSA0_END>>
800040c6:	01 32 20 20 	sub.a %a2,%a2,%a3
800040ca:	80 22       	mov.d %d2,%a2
800040cc:	8f a2 1f 70 	sh %d7,%d2,-6
    uint32 *prvCsa      = csaBegin;
800040d0:	40 32       	mov.aa %a2,%a3
        if (k == (numOfCsa - 3U))
800040d2:	1b d7 ff 0f 	addi %d0,%d7,-3
    for (k = 0U; k < numOfCsa; k++)
800040d6:	82 03       	mov %d3,0
    uint32 *nxtCsa      = csaBegin;
800040d8:	80 32       	mov.d %d2,%a3
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
800040da:	7b f0 00 40 	movh %d4,15
    for (k = 0U; k < numOfCsa; k++)
800040de:	df 07 27 00 	jeq %d7,0,8000412c <_Core0_start+0x25a>
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
800040e2:	37 02 70 53 	extr.u %d5,%d2,6,16
800040e6:	8f 42 1f 60 	sh %d6,%d2,-12
800040ea:	26 46       	and %d6,%d4
800040ec:	a6 65       	or %d5,%d6
        if (k == 0U)
800040ee:	df 03 16 00 	jeq %d3,0,8000411a <_Core0_start+0x248>
            *prvCsa = nxt_cxi_val;  /* Store null pointer in last CSA (= very first time!) */
800040f2:	74 25       	st.w [%a2],%d5
        if (k == (numOfCsa - 3U))
800040f4:	5f 03 04 80 	jne %d3,%d0,800040fc <_Core0_start+0x22a>
            __mtcr(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
800040f8:	cd c5 e3 0f 	mtcr $lcx,%d5
    for (k = 0U; k < numOfCsa; k++)
800040fc:	c2 13       	add %d3,1
800040fe:	60 22       	mov.a %a2,%d2
        nxtCsa += 16U;           /* next CSA */
80004100:	1b 02 04 50 	addi %d5,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80004104:	5f 37 0f 00 	jeq %d7,%d3,80004122 <_Core0_start+0x250>
        nxtCsa += 16U;           /* next CSA */
80004108:	02 52       	mov %d2,%d5
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
8000410a:	37 02 70 53 	extr.u %d5,%d2,6,16
8000410e:	8f 42 1f 60 	sh %d6,%d2,-12
80004112:	26 46       	and %d6,%d4
80004114:	a6 65       	or %d5,%d6
        if (k == 0U)
80004116:	df 03 ee ff 	jne %d3,0,800040f2 <_Core0_start+0x220>
            __mtcr(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
8000411a:	cd 85 e3 0f 	mtcr $fcx,%d5
8000411e:	1d ff eb ff 	j 800040f4 <_Core0_start+0x222>
80004122:	1b f7 ff 2f 	addi %d2,%d7,-1
80004126:	06 62       	sh %d2,6
80004128:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    *prvCsa = 0U;
8000412c:	82 02       	mov %d2,0
8000412e:	74 22       	st.w [%a2],%d2
        uint16 safetyWdtPassword = IfxScuWdt_getSafetyWatchdogPassword();
80004130:	6d ff 66 f0 	call 800021fc <IfxScuWdt_getSafetyWatchdogPassword>
        IfxScuWdt_disableCpuWatchdog(cpuWdtPassword);
80004134:	02 84       	mov %d4,%d8
        uint16 safetyWdtPassword = IfxScuWdt_getSafetyWatchdogPassword();
80004136:	02 29       	mov %d9,%d2
        IfxScuWdt_disableCpuWatchdog(cpuWdtPassword);
80004138:	6d ff 34 ef 	call 80001fa0 <IfxScuWdt_disableCpuWatchdog>
        IfxScuWdt_disableSafetyWatchdog(safetyWdtPassword);
8000413c:	02 94       	mov %d4,%d9
8000413e:	6d ff 70 ef 	call 8000201e <IfxScuWdt_disableSafetyWatchdog>
       	hardware_init_hook();
80004142:	6d ff c6 fe 	call 80003ece <hardware_init_hook>
        Ifx_Cpp_Init();
80004146:	6d ff be fe 	call 80003ec2 <Ifx_Cpp_Init>
       	software_init_hook();
8000414a:	6d ff c3 fe 	call 80003ed0 <software_init_hook>
        IfxScuWdt_enableCpuWatchdog(cpuWdtPassword);
8000414e:	02 84       	mov %d4,%d8
80004150:	6d ff b6 ef 	call 800020bc <IfxScuWdt_enableCpuWatchdog>
        IfxScuWdt_enableSafetyWatchdog(safetyWdtPassword);
80004154:	02 94       	mov %d4,%d9
80004156:	6d ff f2 ef 	call 8000213a <IfxScuWdt_enableSafetyWatchdog>
    IFXCPU_CSTART_CCU_INIT_HOOK();
8000415a:	91 00 00 48 	movh.a %a4,32768
8000415e:	d9 44 30 e0 	lea %a4,[%a4]944 <800003b0 <IfxScuCcu_defaultClockConfig>>
80004162:	6d ff 31 ed 	call 80001bc4 <IfxScuCcu_init>
    (void)IfxCpu_startCore(&MODULE_CPU1, (uint32)&_Core1_start);       /*The status returned by function call is ignored */
80004166:	91 00 00 28 	movh.a %a2,32768
8000416a:	80 22       	mov.d %d2,%a2
8000416c:	1b 62 1c 44 	addi %d4,%d2,16838
80004170:	91 30 88 4f 	movh.a %a4,63619
80004174:	6d ff 4a fe 	call 80003e08 <IfxCpu_startCore>
    (void)IfxCpu_startCore(&MODULE_CPU2, (uint32)&_Core2_start);       /*The status returned by function call is ignored */
80004178:	91 00 00 28 	movh.a %a2,32768
8000417c:	80 22       	mov.d %d2,%a2
8000417e:	1b 42 46 44 	addi %d4,%d2,17508
80004182:	91 50 88 4f 	movh.a %a4,63621
80004186:	6d ff 41 fe 	call 80003e08 <IfxCpu_startCore>
    __non_return_call(core0_main);
8000418a:	91 00 00 28 	movh.a %a2,32768
8000418e:	d9 22 be c4 	lea %a2,[%a2]19262 <80004b3e <core0_main>>
80004192:	dc 02       	ji %a2
}
80004194:	00 90       	ret 
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80004196:	54 24       	ld.w %d4,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004198:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000419c:	b7 04 10 40 	insert %d4,%d4,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800041a0:	0f 34 a0 20 	or %d2,%d4,%d3
800041a4:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800041a8:	74 22       	st.w [%a2],%d2
800041aa:	1d ff fd fe 	j 80003fa4 <_Core0_start+0xd2>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800041ae:	54 24       	ld.w %d4,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800041b0:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800041b4:	b7 04 10 40 	insert %d4,%d4,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800041b8:	0f 34 a0 20 	or %d2,%d4,%d3
800041bc:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800041c0:	74 22       	st.w [%a2],%d2
800041c2:	1d ff b9 fe 	j 80003f34 <_Core0_start+0x62>

800041c6 <_Core1_start>:
    password  = watchdog->CON0.B.PW;
800041c6:	91 30 00 2f 	movh.a %a2,61443
800041ca:	19 22 0c 46 	ld.w %d2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
800041ce:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
800041d2:	37 02 6e 21 	extr.u %d2,%d2,2,14
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[1]);

    IFX_CFG_CPU_CSTART_PRE_C_INIT_HOOK(1);  /*Test Stack, CSA and Cache */

    /* Load user stack pointer */
    __setareg(sp, __USTACK(1));
800041d6:	91 20 00 26 	movh.a %a2,24578
800041da:	8f f2 83 41 	xor %d4,%d2,63
800041de:	80 22       	mov.d %d2,%a2
800041e0:	1b 02 60 2b 	addi %d2,%d2,-18944
800041e4:	60 2a       	mov.a %sp,%d2
    __asm__ volatile ("dsync" : : : "memory");
800041e6:	0d 00 80 04 	dsync 
    __dsync();

    /* Set the PSW to its reset value in case of a warm start,clear PSW.IS */
    __mtcr(CPU_PSW, IFXCSTART1_PSW_DEFAULT);    /* 0x00000980 */
800041ea:	3b 00 98 20 	mov %d2,2432
800041ee:	cd 42 e0 0f 	mtcr $psw,%d2

    /* Set the PCXS and PCXO to its reset value in case of a warm start */
    pcxi  = __mfcr(CPU_PCXI);
800041f2:	4d 00 e0 2f 	mfcr %d2,$pcxi
    pcxi &= IFXCSTART1_PCX_O_S_DEFAULT; /*0xfff00000; */
800041f6:	b7 02 14 20 	insert %d2,%d2,0,0,20
    __mtcr(CPU_PCXI, pcxi);
800041fa:	cd 02 e0 0f 	mtcr $pcxi,%d2
        __mtcr(CPU_PCON1, pcon1.U);
800041fe:	82 12       	mov %d2,1
80004200:	cd 42 20 09 	mtcr $pcon1,%d2
    reg.U = __mfcr(CPU_CORE_ID);
80004204:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80004208:	7b 30 00 3f 	movh %d3,61443
8000420c:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80004210:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80004214:	13 c2 20 23 	madd %d2,%d3,%d2,12
80004218:	60 22       	mov.a %a2,%d2
8000421a:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
8000421c:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
8000421e:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
80004222:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
80004226:	6f 13 13 81 	jnz.t %d3,1,8000444c <_Core1_start+0x286>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000422a:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000422e:	54 22       	ld.w %d2,[%a2]
80004230:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004234:	a6 32       	or %d2,%d3
80004236:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000423a:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
8000423c:	54 22       	ld.w %d2,[%a2]
8000423e:	6f 02 ff ff 	jnz.t %d2,0,8000423c <_Core1_start+0x76>
        __mtcr(CPU_PCON0, pcon0.U);
80004242:	82 02       	mov %d2,0
80004244:	cd c2 20 09 	mtcr $pcon0,%d2
    if (watchdog->CON0.B.LCK)
80004248:	54 22       	ld.w %d2,[%a2]
8000424a:	6f 12 09 00 	jz.t %d2,1,8000425c <_Core1_start+0x96>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000424e:	54 22       	ld.w %d2,[%a2]
80004250:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004254:	a6 32       	or %d2,%d3
80004256:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000425a:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000425c:	54 22       	ld.w %d2,[%a2]
8000425e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004262:	a6 32       	or %d2,%d3
80004264:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80004268:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
8000426a:	54 22       	ld.w %d2,[%a2]
8000426c:	6f 02 ff 7f 	jz.t %d2,0,8000426a <_Core1_start+0xa4>
    __asm__ volatile ("isync" : : : "memory");
80004270:	0d 00 c0 04 	isync 
    reg.U = __mfcr(CPU_CORE_ID);
80004274:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80004278:	7b 30 00 3f 	movh %d3,61443
8000427c:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80004280:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80004284:	13 c2 20 23 	madd %d2,%d3,%d2,12
80004288:	60 22       	mov.a %a2,%d2
    password  = watchdog->CON0.B.PW;
8000428a:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
8000428c:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
8000428e:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
80004292:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
80004296:	6f 13 cf 80 	jnz.t %d3,1,80004434 <_Core1_start+0x26e>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000429a:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000429e:	54 22       	ld.w %d2,[%a2]
800042a0:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800042a4:	a6 32       	or %d2,%d3
800042a6:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800042aa:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800042ac:	54 22       	ld.w %d2,[%a2]
800042ae:	6f 02 ff ff 	jnz.t %d2,0,800042ac <_Core1_start+0xe6>
        __mtcr(CPU_DCON0, dcon0.U);
800042b2:	82 02       	mov %d2,0
800042b4:	cd 02 04 09 	mtcr $dcon0,%d2
    if (watchdog->CON0.B.LCK)
800042b8:	54 22       	ld.w %d2,[%a2]
800042ba:	6f 12 09 00 	jz.t %d2,1,800042cc <_Core1_start+0x106>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800042be:	54 22       	ld.w %d2,[%a2]
800042c0:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800042c4:	a6 32       	or %d2,%d3
800042c6:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800042ca:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800042cc:	54 22       	ld.w %d2,[%a2]
800042ce:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800042d2:	a6 32       	or %d2,%d3
800042d4:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800042d8:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
800042da:	54 22       	ld.w %d2,[%a2]
800042dc:	6f 02 ff 7f 	jz.t %d2,0,800042da <_Core1_start+0x114>
800042e0:	0d 00 c0 04 	isync 
    if (watchdog->CON0.B.LCK)
800042e4:	91 30 00 2f 	movh.a %a2,61443
800042e8:	19 22 0c 46 	ld.w %d2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
800042ec:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800042f0:	06 24       	sh %d4,2
    if (watchdog->CON0.B.LCK)
800042f2:	6f 12 09 00 	jz.t %d2,1,80004304 <_Core1_start+0x13e>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800042f6:	54 22       	ld.w %d2,[%a2]
800042f8:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800042fc:	a6 42       	or %d2,%d4
800042fe:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80004302:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80004304:	91 30 00 2f 	movh.a %a2,61443
80004308:	19 22 0c 46 	ld.w %d2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
8000430c:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
80004310:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004314:	a6 42       	or %d2,%d4
80004316:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000431a:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
8000431c:	54 22       	ld.w %d2,[%a2]
8000431e:	6f 02 ff ff 	jnz.t %d2,0,8000431c <_Core1_start+0x156>

    /* Clear the ENDINIT bit in the WDT_CON1 register, inline funtion */
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[1], wdtPassword);

    /* Load Base Address of Trap Vector Table. */
    __mtcr(CPU_BTV, (uint32)__TRAPTAB(1));
80004322:	91 f0 01 38 	movh.a %a3,32799
80004326:	80 32       	mov.d %d2,%a3
80004328:	1b 02 20 26 	addi %d2,%d2,25088
8000432c:	cd 42 e2 0f 	mtcr $btv,%d2

    /* Load Base Address of Interrupt Vector Table. we will do this later in the program */
    __mtcr(CPU_BIV, (uint32)__INTTAB(1));
80004330:	91 f0 01 38 	movh.a %a3,32799
80004334:	80 32       	mov.d %d2,%a3
80004336:	1b 02 00 24 	addi %d2,%d2,16384
8000433a:	cd 02 e2 0f 	mtcr $biv,%d2

    /* Load interupt stack pointer. */
    __mtcr(CPU_ISP, (uint32)__ISTACK(1));
8000433e:	91 20 00 36 	movh.a %a3,24578
80004342:	80 32       	mov.d %d2,%a3
80004344:	1b 02 b0 2b 	addi %d2,%d2,-17664
80004348:	cd 82 e2 0f 	mtcr $isp,%d2
    if (watchdog->CON0.B.LCK)
8000434c:	54 22       	ld.w %d2,[%a2]
8000434e:	6f 12 09 00 	jz.t %d2,1,80004360 <_Core1_start+0x19a>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80004352:	54 22       	ld.w %d2,[%a2]
80004354:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004358:	a6 42       	or %d2,%d4
8000435a:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000435e:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80004360:	91 30 00 2f 	movh.a %a2,61443
80004364:	19 22 0c 46 	ld.w %d2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
80004368:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
8000436c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004370:	a6 42       	or %d2,%d4
80004372:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80004376:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80004378:	54 22       	ld.w %d2,[%a2]
8000437a:	6f 02 ff 7f 	jz.t %d2,0,80004378 <_Core1_start+0x1b2>

    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[1], wdtPassword);

    /* initialize SDA base pointers */
    __setareg(a0, __SDATA1(1));
8000437e:	91 10 00 26 	movh.a %a2,24577
80004382:	80 22       	mov.d %d2,%a2
80004384:	1b 02 00 28 	addi %d2,%d2,-32768
80004388:	60 20       	mov.a %a0,%d2
    __setareg(a1, __SDATA2(1));
8000438a:	91 10 00 28 	movh.a %a2,32769
8000438e:	80 22       	mov.d %d2,%a2
80004390:	1b 02 00 28 	addi %d2,%d2,-32768
80004394:	60 21       	mov.a %a1,%d2

    /* These to be un commented if A8 and A9 are required to be initialised */
    __setareg(a8, __SDATA3(1));
80004396:	91 10 00 28 	movh.a %a2,32769
8000439a:	80 22       	mov.d %d2,%a2
8000439c:	1b 02 00 28 	addi %d2,%d2,-32768
800043a0:	60 28       	mov.a %a8,%d2
    __setareg(a9, __SDATA4(1));
800043a2:	91 10 00 29 	movh.a %a2,36865
800043a6:	80 22       	mov.d %d2,%a2
800043a8:	1b 02 00 28 	addi %d2,%d2,-32768
800043ac:	60 29       	mov.a %a9,%d2
    uint32  numOfCsa    = (((uint32)csaEnd - (uint32)csaBegin) / 64U);
800043ae:	91 20 00 36 	movh.a %a3,24578
800043b2:	91 20 00 26 	movh.a %a2,24578
800043b6:	d9 33 c0 0b 	lea %a3,[%a3]-17408 <6001bc00 <__CSA1>>
800043ba:	d9 22 c0 0d 	lea %a2,[%a2]-9216 <6001dc00 <__CSA1_END>>
800043be:	01 32 20 20 	sub.a %a2,%a2,%a3
800043c2:	80 22       	mov.d %d2,%a2
800043c4:	8f a2 1f 60 	sh %d6,%d2,-6
    uint32 *prvCsa      = csaBegin;
800043c8:	40 32       	mov.aa %a2,%a3
        if (k == (numOfCsa - 3U))
800043ca:	1b d6 ff 0f 	addi %d0,%d6,-3
    for (k = 0U; k < numOfCsa; k++)
800043ce:	82 03       	mov %d3,0
    uint32 *nxtCsa      = csaBegin;
800043d0:	80 32       	mov.d %d2,%a3
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
800043d2:	7b f0 00 70 	movh %d7,15
    for (k = 0U; k < numOfCsa; k++)
800043d6:	df 06 27 00 	jeq %d6,0,80004424 <_Core1_start+0x25e>
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
800043da:	37 02 70 43 	extr.u %d4,%d2,6,16
800043de:	8f 42 1f 50 	sh %d5,%d2,-12
800043e2:	26 75       	and %d5,%d7
800043e4:	a6 54       	or %d4,%d5
        if (k == 0U)
800043e6:	df 03 16 00 	jeq %d3,0,80004412 <_Core1_start+0x24c>
            *prvCsa = nxt_cxi_val;  /* Store null pointer in last CSA (= very first time!) */
800043ea:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
800043ec:	5f 03 04 80 	jne %d3,%d0,800043f4 <_Core1_start+0x22e>
            __mtcr(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
800043f0:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
800043f4:	c2 13       	add %d3,1
800043f6:	60 22       	mov.a %a2,%d2
        nxtCsa += 16U;           /* next CSA */
800043f8:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
800043fc:	5f 36 0f 00 	jeq %d6,%d3,8000441a <_Core1_start+0x254>
        nxtCsa += 16U;           /* next CSA */
80004400:	02 42       	mov %d2,%d4
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
80004402:	37 02 70 43 	extr.u %d4,%d2,6,16
80004406:	8f 42 1f 50 	sh %d5,%d2,-12
8000440a:	26 75       	and %d5,%d7
8000440c:	a6 54       	or %d4,%d5
        if (k == 0U)
8000440e:	df 03 ee ff 	jne %d3,0,800043ea <_Core1_start+0x224>
            __mtcr(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
80004412:	cd 84 e3 0f 	mtcr $fcx,%d4
80004416:	1d ff eb ff 	j 800043ec <_Core1_start+0x226>
8000441a:	1b f6 ff 2f 	addi %d2,%d6,-1
8000441e:	06 62       	sh %d2,6
80004420:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    *prvCsa = 0U;
80004424:	82 02       	mov %d2,0
80004426:	74 22       	st.w [%a2],%d2

    IfxCpu_initCSA((uint32 *)__CSA(1), (uint32 *)__CSA_END(1));

    /*Call main function of Cpu0 */
    __non_return_call(core1_main);
80004428:	91 00 00 28 	movh.a %a2,32768
8000442c:	d9 22 94 e4 	lea %a2,[%a2]19348 <80004b94 <core1_main>>
80004430:	dc 02       	ji %a2
}
80004432:	00 90       	ret 
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80004434:	54 25       	ld.w %d5,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004436:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000443a:	b7 05 10 50 	insert %d5,%d5,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000443e:	0f 35 a0 20 	or %d2,%d5,%d3
80004442:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80004446:	74 22       	st.w [%a2],%d2
80004448:	1d ff 2b ff 	j 8000429e <_Core1_start+0xd8>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000444c:	54 25       	ld.w %d5,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000444e:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80004452:	b7 05 10 50 	insert %d5,%d5,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004456:	0f 35 a0 20 	or %d2,%d5,%d3
8000445a:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000445e:	74 22       	st.w [%a2],%d2
80004460:	1d ff e7 fe 	j 8000422e <_Core1_start+0x68>

80004464 <_Core2_start>:
    password  = watchdog->CON0.B.PW;
80004464:	91 30 00 2f 	movh.a %a2,61443
80004468:	19 22 18 46 	ld.w %d2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
8000446c:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
80004470:	37 02 6e 21 	extr.u %d2,%d2,2,14
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[2]);

    IFX_CFG_CPU_CSTART_PRE_C_INIT_HOOK(2);  /*Test Stack, CSA and Cache */

    /* Load user stack pointer */
    __setareg(sp, __USTACK(2));
80004474:	91 20 00 25 	movh.a %a2,20482
80004478:	8f f2 83 41 	xor %d4,%d2,63
8000447c:	80 22       	mov.d %d2,%a2
8000447e:	1b 02 60 2b 	addi %d2,%d2,-18944
80004482:	60 2a       	mov.a %sp,%d2
    __asm__ volatile ("dsync" : : : "memory");
80004484:	0d 00 80 04 	dsync 
    __dsync();

    /* Set the PSW to its reset value in case of a warm start,clear PSW.IS */
    __mtcr(CPU_PSW, IFXCSTART2_PSW_DEFAULT);    /* 0x00000980 */
80004488:	3b 00 98 20 	mov %d2,2432
8000448c:	cd 42 e0 0f 	mtcr $psw,%d2

    /* Set the PCXS and PCXO to its reset value in case of a warm start */
    pcxi  = __mfcr(CPU_PCXI);
80004490:	4d 00 e0 2f 	mfcr %d2,$pcxi
    pcxi &= IFXCSTART2_PCX_O_S_DEFAULT; /*0xfff00000; */
80004494:	b7 02 14 20 	insert %d2,%d2,0,0,20
    __mtcr(CPU_PCXI, pcxi);
80004498:	cd 02 e0 0f 	mtcr $pcxi,%d2
        __mtcr(CPU_PCON1, pcon1.U);
8000449c:	82 12       	mov %d2,1
8000449e:	cd 42 20 09 	mtcr $pcon1,%d2
    reg.U = __mfcr(CPU_CORE_ID);
800044a2:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
800044a6:	7b 30 00 3f 	movh %d3,61443
800044aa:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800044ae:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
800044b2:	13 c2 20 23 	madd %d2,%d3,%d2,12
800044b6:	60 22       	mov.a %a2,%d2
800044b8:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
800044ba:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
800044bc:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
800044c0:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
800044c4:	6f 13 13 81 	jnz.t %d3,1,800046ea <_Core2_start+0x286>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800044c8:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800044cc:	54 22       	ld.w %d2,[%a2]
800044ce:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800044d2:	a6 32       	or %d2,%d3
800044d4:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800044d8:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800044da:	54 22       	ld.w %d2,[%a2]
800044dc:	6f 02 ff ff 	jnz.t %d2,0,800044da <_Core2_start+0x76>
        __mtcr(CPU_PCON0, pcon0.U);
800044e0:	82 02       	mov %d2,0
800044e2:	cd c2 20 09 	mtcr $pcon0,%d2
    if (watchdog->CON0.B.LCK)
800044e6:	54 22       	ld.w %d2,[%a2]
800044e8:	6f 12 09 00 	jz.t %d2,1,800044fa <_Core2_start+0x96>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800044ec:	54 22       	ld.w %d2,[%a2]
800044ee:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800044f2:	a6 32       	or %d2,%d3
800044f4:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800044f8:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800044fa:	54 22       	ld.w %d2,[%a2]
800044fc:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004500:	a6 32       	or %d2,%d3
80004502:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80004506:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80004508:	54 22       	ld.w %d2,[%a2]
8000450a:	6f 02 ff 7f 	jz.t %d2,0,80004508 <_Core2_start+0xa4>
    __asm__ volatile ("isync" : : : "memory");
8000450e:	0d 00 c0 04 	isync 
    reg.U = __mfcr(CPU_CORE_ID);
80004512:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80004516:	7b 30 00 3f 	movh %d3,61443
8000451a:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000451e:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80004522:	13 c2 20 23 	madd %d2,%d3,%d2,12
80004526:	60 22       	mov.a %a2,%d2
    password  = watchdog->CON0.B.PW;
80004528:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
8000452a:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
8000452c:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
80004530:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
80004534:	6f 13 cf 80 	jnz.t %d3,1,800046d2 <_Core2_start+0x26e>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004538:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000453c:	54 22       	ld.w %d2,[%a2]
8000453e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004542:	a6 32       	or %d2,%d3
80004544:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80004548:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
8000454a:	54 22       	ld.w %d2,[%a2]
8000454c:	6f 02 ff ff 	jnz.t %d2,0,8000454a <_Core2_start+0xe6>
        __mtcr(CPU_DCON0, dcon0.U);
80004550:	82 02       	mov %d2,0
80004552:	cd 02 04 09 	mtcr $dcon0,%d2
    if (watchdog->CON0.B.LCK)
80004556:	54 22       	ld.w %d2,[%a2]
80004558:	6f 12 09 00 	jz.t %d2,1,8000456a <_Core2_start+0x106>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000455c:	54 22       	ld.w %d2,[%a2]
8000455e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004562:	a6 32       	or %d2,%d3
80004564:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80004568:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000456a:	54 22       	ld.w %d2,[%a2]
8000456c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004570:	a6 32       	or %d2,%d3
80004572:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80004576:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80004578:	54 22       	ld.w %d2,[%a2]
8000457a:	6f 02 ff 7f 	jz.t %d2,0,80004578 <_Core2_start+0x114>
8000457e:	0d 00 c0 04 	isync 
    if (watchdog->CON0.B.LCK)
80004582:	91 30 00 2f 	movh.a %a2,61443
80004586:	19 22 18 46 	ld.w %d2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
8000458a:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000458e:	06 24       	sh %d4,2
    if (watchdog->CON0.B.LCK)
80004590:	6f 12 09 00 	jz.t %d2,1,800045a2 <_Core2_start+0x13e>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80004594:	54 22       	ld.w %d2,[%a2]
80004596:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000459a:	a6 42       	or %d2,%d4
8000459c:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800045a0:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800045a2:	91 30 00 2f 	movh.a %a2,61443
800045a6:	19 22 18 46 	ld.w %d2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
800045aa:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
800045ae:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800045b2:	a6 42       	or %d2,%d4
800045b4:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800045b8:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800045ba:	54 22       	ld.w %d2,[%a2]
800045bc:	6f 02 ff ff 	jnz.t %d2,0,800045ba <_Core2_start+0x156>

    /* Clear the ENDINIT bit in the Password register, inline funtion */
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[2], wdtPassword);

    /* Load Base Address of Trap Vector Table. */
    __mtcr(CPU_BTV, (uint32)__TRAPTAB(2));
800045c0:	91 f0 01 38 	movh.a %a3,32799
800045c4:	80 32       	mov.d %d2,%a3
800045c6:	1b 02 10 26 	addi %d2,%d2,24832
800045ca:	cd 42 e2 0f 	mtcr $btv,%d2

    /* Load Base Address of Interrupt Vector Table. we will do this later in the program */
    __mtcr(CPU_BIV, (uint32)__INTTAB(2));
800045ce:	91 f0 01 38 	movh.a %a3,32799
800045d2:	80 32       	mov.d %d2,%a3
800045d4:	1b 02 00 24 	addi %d2,%d2,16384
800045d8:	cd 02 e2 0f 	mtcr $biv,%d2

    /* Load interupt stack pointer. */
    __mtcr(CPU_ISP, (uint32)__ISTACK(2));
800045dc:	91 20 00 35 	movh.a %a3,20482
800045e0:	80 32       	mov.d %d2,%a3
800045e2:	1b 02 b0 2b 	addi %d2,%d2,-17664
800045e6:	cd 82 e2 0f 	mtcr $isp,%d2
    if (watchdog->CON0.B.LCK)
800045ea:	54 22       	ld.w %d2,[%a2]
800045ec:	6f 12 09 00 	jz.t %d2,1,800045fe <_Core2_start+0x19a>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800045f0:	54 22       	ld.w %d2,[%a2]
800045f2:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800045f6:	a6 42       	or %d2,%d4
800045f8:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800045fc:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800045fe:	91 30 00 2f 	movh.a %a2,61443
80004602:	19 22 18 46 	ld.w %d2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
80004606:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
8000460a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000460e:	a6 42       	or %d2,%d4
80004610:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80004614:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80004616:	54 22       	ld.w %d2,[%a2]
80004618:	6f 02 ff 7f 	jz.t %d2,0,80004616 <_Core2_start+0x1b2>

    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[2], wdtPassword);

    /* initialize SDA base pointers */
    __setareg(a0, __SDATA1(2));
8000461c:	91 10 00 26 	movh.a %a2,24577
80004620:	80 22       	mov.d %d2,%a2
80004622:	1b 02 00 28 	addi %d2,%d2,-32768
80004626:	60 20       	mov.a %a0,%d2
    __setareg(a1, __SDATA2(2));
80004628:	91 10 00 28 	movh.a %a2,32769
8000462c:	80 22       	mov.d %d2,%a2
8000462e:	1b 02 00 28 	addi %d2,%d2,-32768
80004632:	60 21       	mov.a %a1,%d2

    /* These to be un commented if A8 and A9 are required to be initialized */
    __setareg(a8, __SDATA3(2));
80004634:	91 10 00 28 	movh.a %a2,32769
80004638:	80 22       	mov.d %d2,%a2
8000463a:	1b 02 00 28 	addi %d2,%d2,-32768
8000463e:	60 28       	mov.a %a8,%d2
    __setareg(a9, __SDATA4(2));
80004640:	91 10 00 29 	movh.a %a2,36865
80004644:	80 22       	mov.d %d2,%a2
80004646:	1b 02 00 28 	addi %d2,%d2,-32768
8000464a:	60 29       	mov.a %a9,%d2
    uint32  numOfCsa    = (((uint32)csaEnd - (uint32)csaBegin) / 64U);
8000464c:	91 20 00 35 	movh.a %a3,20482
80004650:	91 20 00 25 	movh.a %a2,20482
80004654:	d9 33 c0 0b 	lea %a3,[%a3]-17408 <5001bc00 <__CSA2>>
80004658:	d9 22 c0 0d 	lea %a2,[%a2]-9216 <5001dc00 <__CSA2_END>>
8000465c:	01 32 20 20 	sub.a %a2,%a2,%a3
80004660:	80 22       	mov.d %d2,%a2
80004662:	8f a2 1f 60 	sh %d6,%d2,-6
    uint32 *prvCsa      = csaBegin;
80004666:	40 32       	mov.aa %a2,%a3
        if (k == (numOfCsa - 3U))
80004668:	1b d6 ff 0f 	addi %d0,%d6,-3
    for (k = 0U; k < numOfCsa; k++)
8000466c:	82 03       	mov %d3,0
    uint32 *nxtCsa      = csaBegin;
8000466e:	80 32       	mov.d %d2,%a3
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
80004670:	7b f0 00 70 	movh %d7,15
    for (k = 0U; k < numOfCsa; k++)
80004674:	df 06 27 00 	jeq %d6,0,800046c2 <_Core2_start+0x25e>
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
80004678:	37 02 70 43 	extr.u %d4,%d2,6,16
8000467c:	8f 42 1f 50 	sh %d5,%d2,-12
80004680:	26 75       	and %d5,%d7
80004682:	a6 54       	or %d4,%d5
        if (k == 0U)
80004684:	df 03 16 00 	jeq %d3,0,800046b0 <_Core2_start+0x24c>
            *prvCsa = nxt_cxi_val;  /* Store null pointer in last CSA (= very first time!) */
80004688:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
8000468a:	5f 03 04 80 	jne %d3,%d0,80004692 <_Core2_start+0x22e>
            __mtcr(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
8000468e:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
80004692:	c2 13       	add %d3,1
80004694:	60 22       	mov.a %a2,%d2
        nxtCsa += 16U;           /* next CSA */
80004696:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
8000469a:	5f 36 0f 00 	jeq %d6,%d3,800046b8 <_Core2_start+0x254>
        nxtCsa += 16U;           /* next CSA */
8000469e:	02 42       	mov %d2,%d4
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
800046a0:	37 02 70 43 	extr.u %d4,%d2,6,16
800046a4:	8f 42 1f 50 	sh %d5,%d2,-12
800046a8:	26 75       	and %d5,%d7
800046aa:	a6 54       	or %d4,%d5
        if (k == 0U)
800046ac:	df 03 ee ff 	jne %d3,0,80004688 <_Core2_start+0x224>
            __mtcr(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
800046b0:	cd 84 e3 0f 	mtcr $fcx,%d4
800046b4:	1d ff eb ff 	j 8000468a <_Core2_start+0x226>
800046b8:	1b f6 ff 2f 	addi %d2,%d6,-1
800046bc:	06 62       	sh %d2,6
800046be:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    *prvCsa = 0U;
800046c2:	82 02       	mov %d2,0
800046c4:	74 22       	st.w [%a2],%d2
    /* Setup the context save area linked list. */

    IfxCpu_initCSA((uint32 *)__CSA(2), (uint32 *)__CSA_END(2));

    /*Call main function of Cpu0 */
    __non_return_call(core2_main);
800046c6:	91 00 00 28 	movh.a %a2,32768
800046ca:	d9 22 82 f4 	lea %a2,[%a2]19394 <80004bc2 <core2_main>>
800046ce:	dc 02       	ji %a2
}
800046d0:	00 90       	ret 
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800046d2:	54 25       	ld.w %d5,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800046d4:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800046d8:	b7 05 10 50 	insert %d5,%d5,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800046dc:	0f 35 a0 20 	or %d2,%d5,%d3
800046e0:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800046e4:	74 22       	st.w [%a2],%d2
800046e6:	1d ff 2b ff 	j 8000453c <_Core2_start+0xd8>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800046ea:	54 25       	ld.w %d5,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800046ec:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800046f0:	b7 05 10 50 	insert %d5,%d5,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800046f4:	0f 35 a0 20 	or %d2,%d5,%d3
800046f8:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800046fc:	74 22       	st.w [%a2],%d2
800046fe:	1d ff e7 fe 	j 800044cc <_Core2_start+0x68>

80004702 <IfxStdIf_PwmHl_initConfig>:
 */

#include "IfxStdIf_PwmHl.h"

void IfxStdIf_PwmHl_initConfig(IfxStdIf_PwmHl_Config *config)
{
80004702:	40 ae       	mov.aa %a14,%sp
    config->deadtime         = 0;
80004704:	82 02       	mov %d2,0
80004706:	74 42       	st.w [%a4],%d2
    config->minPulse         = 0;
80004708:	59 42 04 00 	st.w [%a4]4,%d2
    config->channelCount     = 0;
8000470c:	82 02       	mov %d2,0
8000470e:	e9 42 08 00 	st.b [%a4]8,%d2
    config->emergencyEnabled = FALSE;
80004712:	e9 42 09 00 	st.b [%a4]9,%d2
    config->outputMode       = IfxPort_OutputMode_pushPull;
80004716:	3b 00 08 20 	mov %d2,128
8000471a:	59 42 0c 00 	st.w [%a4]12,%d2
    config->outputDriver     = IfxPort_PadDriver_cmosAutomotiveSpeed1;
8000471e:	82 02       	mov %d2,0
80004720:	59 42 10 00 	st.w [%a4]16,%d2
    config->ccxActiveState   = Ifx_ActiveState_high;
80004724:	82 12       	mov %d2,1
80004726:	59 42 1c 00 	st.w [%a4]28,%d2
    config->coutxActiveState = Ifx_ActiveState_high;
8000472a:	59 42 20 00 	st.w [%a4]32,%d2
}
8000472e:	00 90       	ret 

80004730 <IfxStdIf_Timer_initConfig>:
 */

#include "IfxStdIf_Timer.h"

void IfxStdIf_Timer_initConfig(IfxStdIf_Timer_Config *config)
{
80004730:	40 ae       	mov.aa %a14,%sp
    config->frequency                  = 1000;
80004732:	7b a0 47 24 	movh %d2,17530
80004736:	74 42       	st.w [%a4],%d2
    config->isrPriority                = 0;
80004738:	82 02       	mov %d2,0
8000473a:	f9 42 04 00 	st.h [%a4]4,%d2
    config->isrProvider                = IfxSrc_Tos_cpu0;
8000473e:	82 03       	mov %d3,0
80004740:	59 43 08 00 	st.w [%a4]8,%d3
    config->minResolution              = 0;
80004744:	82 04       	mov %d4,0
80004746:	59 44 0c 00 	st.w [%a4]12,%d4
    config->trigger.outputMode         = IfxPort_OutputMode_pushPull;
8000474a:	3b 00 08 50 	mov %d5,128
8000474e:	59 45 20 00 	st.w [%a4]32,%d5
    config->trigger.outputDriver       = IfxPort_PadDriver_cmosAutomotiveSpeed1;
80004752:	59 43 24 00 	st.w [%a4]36,%d3
    config->trigger.risingEdgeAtPeriod = FALSE;
80004756:	e9 42 28 00 	st.b [%a4]40,%d2
    config->trigger.outputEnabled      = FALSE;
8000475a:	e9 42 29 00 	st.b [%a4]41,%d2
    config->trigger.enabled            = FALSE;
8000475e:	e9 42 10 00 	st.b [%a4]16,%d2
    config->trigger.triggerPoint       = 0;
80004762:	59 43 14 00 	st.w [%a4]20,%d3
    config->trigger.isrPriority        = 0;
80004766:	f9 43 18 00 	st.h [%a4]24,%d3
    config->trigger.isrProvider        = IfxSrc_Tos_cpu0;
8000476a:	59 43 1c 00 	st.w [%a4]28,%d3
    config->countDir                   = IfxStdIf_Timer_CountDir_up;
8000476e:	59 43 2c 00 	st.w [%a4]44,%d3
    config->startOffset 					   = 0.0;
80004772:	59 44 30 00 	st.w [%a4]48,%d4
}
80004776:	00 90       	ret 

80004778 <Ifx_C_Init>:
 *
 * Parameters: Nil
 * Return: Nil
 */
void Ifx_C_Init(void)
{
80004778:	40 ae       	mov.aa %a14,%sp
8000477a:	20 08       	sub.a %sp,8
    IfxStart_CTablePtr pBlockDest, pBlockSrc;
    uint32             uiLength, uiCnt;
    uint32            *pTable;
    /* clear table */
    pTable = (uint32 *)&__clear_table;
8000477c:	91 00 00 28 	movh.a %a2,32768
80004780:	d9 22 4c 20 	lea %a2,[%a2]1164 <8000048c <__clear_table>>

    while (pTable)
80004784:	1d 00 32 00 	j 800047e8 <Ifx_C_Init+0x70>
            break;
        }

        uiCnt = uiLength / 8;

        while (uiCnt--)
80004788:	91 00 00 28 	movh.a %a2,32768
8000478c:	d9 22 74 30 	lea %a2,[%a2]1268 <800004f4 <__copy_table>>
80004790:	1d 00 7c 00 	j 80004888 <Ifx_C_Init+0x110>
            *pBlockDest.ullPtr++ = 0;
80004794:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80004798:	80 22       	mov.d %d2,%a2
8000479a:	1b 82 00 20 	addi %d2,%d2,8
8000479e:	59 e2 fc ff 	st.w [%a14]-4,%d2
800047a2:	d2 02       	mov %e2,0
800047a4:	89 22 40 09 	st.d [%a2],%e2
        while (uiCnt--)
800047a8:	02 52       	mov %d2,%d5
800047aa:	1b f2 ff 5f 	addi %d5,%d2,-1
800047ae:	df 02 f3 ff 	jne %d2,0,80004794 <Ifx_C_Init+0x1c>
        if (uiLength & 0x4)
800047b2:	6f 24 0a 00 	jz.t %d4,2,800047c6 <Ifx_C_Init+0x4e>
            *pBlockDest.uiPtr++ = 0;
800047b6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800047ba:	80 22       	mov.d %d2,%a2
800047bc:	c2 42       	add %d2,4
800047be:	59 e2 fc ff 	st.w [%a14]-4,%d2
800047c2:	82 02       	mov %d2,0
800047c4:	74 22       	st.w [%a2],%d2
        if (uiLength & 0x2)
800047c6:	6f 14 0a 00 	jz.t %d4,1,800047da <Ifx_C_Init+0x62>
            *pBlockDest.usPtr++ = 0;
800047ca:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800047ce:	80 22       	mov.d %d2,%a2
800047d0:	c2 22       	add %d2,2
800047d2:	59 e2 fc ff 	st.w [%a14]-4,%d2
800047d6:	82 02       	mov %d2,0
800047d8:	b4 22       	st.h [%a2],%d2
        if (uiLength & 0x1)
800047da:	6f 04 06 00 	jz.t %d4,0,800047e6 <Ifx_C_Init+0x6e>
            *pBlockDest.ucPtr = 0;
800047de:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800047e2:	82 02       	mov %d2,0
800047e4:	34 22       	st.b [%a2],%d2
        while (uiCnt--)
800047e6:	40 32       	mov.aa %a2,%a3
    while (pTable)
800047e8:	bd 02 d0 7f 	jz.a %a2,80004788 <Ifx_C_Init+0x10>
        pBlockDest.uiPtr = (uint32 *)*pTable++;
800047ec:	d9 23 08 00 	lea %a3,[%a2]8
800047f0:	54 22       	ld.w %d2,[%a2]
800047f2:	59 e2 fc ff 	st.w [%a14]-4,%d2
        uiLength         = *pTable++;
800047f6:	19 24 04 00 	ld.w %d4,[%a2]4
        if (uiLength == 0xFFFFFFFF)
800047fa:	df f4 c7 7f 	jeq %d4,-1,80004788 <Ifx_C_Init+0x10>
        uiCnt = uiLength / 8;
800047fe:	8f d4 1f 20 	sh %d2,%d4,-3
        while (uiCnt--)
80004802:	1d ff d4 ff 	j 800047aa <Ifx_C_Init+0x32>
        {
            *pBlockDest.ullPtr++ = *pBlockSrc.ullPtr++;
80004806:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000480a:	80 22       	mov.d %d2,%a2
8000480c:	1b 82 00 20 	addi %d2,%d2,8
80004810:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80004814:	99 e3 fc ff 	ld.a %a3,[%a14]-4
80004818:	80 32       	mov.d %d2,%a3
8000481a:	1b 82 00 20 	addi %d2,%d2,8
8000481e:	59 e2 fc ff 	st.w [%a14]-4,%d2
80004822:	09 26 40 09 	ld.d %e6,[%a2]
80004826:	89 36 40 09 	st.d [%a3],%e6
        while (uiCnt--)
8000482a:	02 42       	mov %d2,%d4
8000482c:	1b f2 ff 4f 	addi %d4,%d2,-1
80004830:	df 02 eb ff 	jne %d2,0,80004806 <Ifx_C_Init+0x8e>
        }

        if (uiLength & 0x4)
80004834:	6f 23 10 00 	jz.t %d3,2,80004854 <Ifx_C_Init+0xdc>
        {
            *pBlockDest.uiPtr++ = *pBlockSrc.uiPtr++;
80004838:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000483c:	80 22       	mov.d %d2,%a2
8000483e:	c2 42       	add %d2,4
80004840:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80004844:	99 e3 fc ff 	ld.a %a3,[%a14]-4
80004848:	80 32       	mov.d %d2,%a3
8000484a:	c2 42       	add %d2,4
8000484c:	59 e2 fc ff 	st.w [%a14]-4,%d2
80004850:	54 22       	ld.w %d2,[%a2]
80004852:	74 32       	st.w [%a3],%d2
        }

        if (uiLength & 0x2)
80004854:	6f 13 11 00 	jz.t %d3,1,80004876 <Ifx_C_Init+0xfe>
        {
            *pBlockDest.usPtr++ = *pBlockSrc.usPtr++;
80004858:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
8000485c:	80 32       	mov.d %d2,%a3
8000485e:	c2 22       	add %d2,2
80004860:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80004864:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80004868:	80 22       	mov.d %d2,%a2
8000486a:	c2 22       	add %d2,2
8000486c:	59 e2 fc ff 	st.w [%a14]-4,%d2
80004870:	b9 32 00 00 	ld.hu %d2,[%a3]0
80004874:	b4 22       	st.h [%a2],%d2
        }

        if (uiLength & 0x1)
80004876:	6f 03 08 00 	jz.t %d3,0,80004886 <Ifx_C_Init+0x10e>
        {
            *pBlockDest.ucPtr = *pBlockSrc.ucPtr;
8000487a:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
8000487e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80004882:	14 32       	ld.bu %d2,[%a3]
80004884:	34 22       	st.b [%a2],%d2
        while (uiCnt--)
80004886:	60 52       	mov.a %a2,%d5
    while (pTable)
80004888:	bd 02 14 00 	jz.a %a2,800048b0 <Ifx_C_Init+0x138>
        pBlockSrc.uiPtr  = (uint32 *)*pTable++;
8000488c:	54 22       	ld.w %d2,[%a2]
8000488e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        pBlockDest.uiPtr = (uint32 *)*pTable++;
80004892:	19 22 04 00 	ld.w %d2,[%a2]4
80004896:	59 e2 fc ff 	st.w [%a14]-4,%d2
        uiLength         = *pTable++;
8000489a:	80 22       	mov.d %d2,%a2
8000489c:	1b c2 00 50 	addi %d5,%d2,12
800048a0:	19 23 08 00 	ld.w %d3,[%a2]8
        if (uiLength == 0xFFFFFFFF)
800048a4:	df f3 06 00 	jeq %d3,-1,800048b0 <Ifx_C_Init+0x138>
        uiCnt = uiLength / 8;
800048a8:	8f d3 1f 20 	sh %d2,%d3,-3
        while (uiCnt--)
800048ac:	1d ff c0 ff 	j 8000482c <Ifx_C_Init+0xb4>
        }
    }
}
800048b0:	00 90       	ret 

800048b2 <init_GPIO>:
#include "GPIO.h"



void init_GPIO(void)
{
800048b2:	40 ae       	mov.aa %a14,%sp
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
800048b4:	3b 80 00 50 	mov %d5,8
800048b8:	82 34       	mov %d4,3
800048ba:	91 40 00 4f 	movh.a %a4,61444
800048be:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
800048c2:	6d ff f5 ec 	call 800022ac <IfxPort_setPinMode>
800048c6:	3b 80 00 50 	mov %d5,8
800048ca:	82 44       	mov %d4,4
800048cc:	91 40 00 4f 	movh.a %a4,61444
800048d0:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
800048d4:	6d ff ec ec 	call 800022ac <IfxPort_setPinMode>
    IfxPort_setPinModeInput(PORT_023, IfxPort_InputMode_pullDown);
    IfxPort_setPinModeInput(PORT_024, IfxPort_InputMode_pullDown);
}
800048d8:	00 90       	ret 

800048da <Encoder>:
 */
#include "GPIO.h"
#include "Encoder.h"

void Encoder(void)
{
800048da:	40 ae       	mov.aa %a14,%sp
    return (__getbit(&port->IN.U, pinIndex) != 0) ? TRUE : FALSE;
800048dc:	91 40 00 2f 	movh.a %a2,61444
800048e0:	d9 22 00 8a 	lea %a2,[%a2]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
800048e4:	d9 23 24 00 	lea %a3,[%a2]36 <f0040024 <_SMALL_DATA4_+0x60038024>>
800048e8:	19 23 24 00 	ld.w %d3,[%a2]36 <f0040024 <_SMALL_DATA4_+0x60038024>>
800048ec:	37 03 e1 51 	extr.u %d5,%d3,3,1
800048f0:	54 38       	ld.w %d8,[%a3]
800048f2:	37 08 61 42 	extr.u %d4,%d8,4,1
   uint8 A = IfxPort_getPinState(PORT_023);
   uint8 B = IfxPort_getPinState(PORT_024);

   uint8 state = 0;

   if       (A == 0 && B == 0) {state = 0;}
800048f6:	87 83 23 82 	or.t %d8,%d3,3,%d8,4
800048fa:	df 08 14 00 	jeq %d8,0,80004922 <Encoder+0x48>
   else if  (A == 1 && B == 0) {state = 1;}
800048fe:	02 53       	mov %d3,%d5
80004900:	8f 14 80 21 	xor %d2,%d4,1
80004904:	26 52       	and %d2,%d5
80004906:	df 02 0d 80 	jne %d2,0,80004920 <Encoder+0x46>
   else if  (A == 1 && B == 1) {state = 2;}
8000490a:	26 43       	and %d3,%d4
8000490c:	df 03 4d 80 	jne %d3,0,800049a6 <Encoder+0xcc>
   else if  (A == 0 && B == 1) {state = 3;}
80004910:	8f 15 80 21 	xor %d2,%d5,1
80004914:	26 42       	and %d2,%d4
80004916:	df 02 4b 80 	jne %d2,0,800049ac <Encoder+0xd2>
   uint8 state = 0;
8000491a:	82 08       	mov %d8,0
8000491c:	1d 00 03 00 	j 80004922 <Encoder+0x48>
   else if  (A == 1 && B == 0) {state = 1;}
80004920:	82 18       	mov %d8,1

   if       (state-state_old==1 || state-state_old==-3) {encoderCNT++; encoderDir = 1;}
80004922:	91 00 00 26 	movh.a %a2,24576
80004926:	39 22 38 30 	ld.bu %d2,[%a2]248 <600000f8 <state_old>>
8000492a:	0b 28 80 20 	sub %d2,%d8,%d2
8000492e:	8b 12 00 32 	eq %d3,%d2,1
80004932:	8b d2 ff 34 	or.eq %d3,%d2,-3
80004936:	df 03 3e 00 	jeq %d3,0,800049b2 <Encoder+0xd8>
8000493a:	91 00 00 26 	movh.a %a2,24576
8000493e:	d9 23 34 30 	lea %a3,[%a2]244 <600000f4 <encoderCNT>>
80004942:	54 32       	ld.w %d2,[%a3]
80004944:	c2 12       	add %d2,1
80004946:	59 22 34 30 	st.w [%a2]244 <600000f4 <encoderCNT>>,%d2
8000494a:	91 00 00 26 	movh.a %a2,24576
8000494e:	82 12       	mov %d2,1
80004950:	59 22 30 30 	st.w [%a2]240 <600000f0 <encoderDir>>,%d2
   else if  (state-state_old==-1 || state-state_old==3) {encoderCNT--; encoderDir = -1;}

   theta = encoderCNT*1/16*0.25*360;    //한바퀴 1/16
80004954:	91 00 00 26 	movh.a %a2,24576
80004958:	19 22 34 30 	ld.w %d2,[%a2]244 <600000f4 <encoderCNT>>
8000495c:	8b 02 40 42 	lt %d4,%d2,0
80004960:	ab f2 00 44 	cadd %d4,%d4,%d2,15
80004964:	86 c4       	sha %d4,-4
80004966:	6d 00 68 04 	call 80005236 <__floatsidf>
8000496a:	82 06       	mov %d6,0
8000496c:	7b 00 fd 73 	movh %d7,16336
80004970:	0b 23 10 48 	mov %e4,%d3,%d2
80004974:	6d 00 a7 02 	call 80004ec2 <__muldf3>
80004978:	82 06       	mov %d6,0
8000497a:	7b 70 07 74 	movh %d7,16503
8000497e:	1b 07 00 78 	addi %d7,%d7,-32768
80004982:	0b 23 10 48 	mov %e4,%d3,%d2
80004986:	6d 00 9e 02 	call 80004ec2 <__muldf3>
8000498a:	0b 23 10 48 	mov %e4,%d3,%d2
8000498e:	6d 00 9f 04 	call 800052cc <__truncdfsf2>
80004992:	91 00 00 26 	movh.a %a2,24576
80004996:	d9 22 2c 30 	lea %a2,[%a2]236 <600000ec <theta>>
8000499a:	74 22       	st.w [%a2],%d2

   state_old = state;
8000499c:	91 00 00 26 	movh.a %a2,24576
800049a0:	e9 28 38 30 	st.b [%a2]248 <600000f8 <state_old>>,%d8
}
800049a4:	00 90       	ret 
   else if  (A == 1 && B == 1) {state = 2;}
800049a6:	82 28       	mov %d8,2
800049a8:	1d ff bd ff 	j 80004922 <Encoder+0x48>
   else if  (A == 0 && B == 1) {state = 3;}
800049ac:	82 38       	mov %d8,3
800049ae:	1d ff ba ff 	j 80004922 <Encoder+0x48>
   else if  (state-state_old==-1 || state-state_old==3) {encoderCNT--; encoderDir = -1;}
800049b2:	8b f2 1f 32 	eq %d3,%d2,-1
800049b6:	8b 32 e0 34 	or.eq %d3,%d2,3
800049ba:	df 03 cd 7f 	jeq %d3,0,80004954 <Encoder+0x7a>
800049be:	91 00 00 26 	movh.a %a2,24576
800049c2:	d9 23 34 30 	lea %a3,[%a2]244 <600000f4 <encoderCNT>>
800049c6:	54 32       	ld.w %d2,[%a3]
800049c8:	c2 f2       	add %d2,-1
800049ca:	59 22 34 30 	st.w [%a2]244 <600000f4 <encoderCNT>>,%d2
800049ce:	91 00 00 26 	movh.a %a2,24576
800049d2:	82 f2       	mov %d2,-1
800049d4:	59 22 30 30 	st.w [%a2]240 <600000f0 <encoderDir>>,%d2
800049d8:	1d ff be ff 	j 80004954 <Encoder+0x7a>

800049dc <init_ADC_Group>:
#include "ADC.h"
#include "STM.h"
#include "GPIO.h"

void init_ADC_Group(void)
{
800049dc:	40 ae       	mov.aa %a14,%sp
800049de:	20 a8       	sub.a %sp,168
    IfxVadc_Adc_Config      adcConf;                        /* Define a configuration structure for the VADC module */
    IfxVadc_Adc_initModuleConfig(&adcConf, &MODULE_VADC);   /* adcConf 값을 디폴트 값(MODULE_VADC)오로 초기화 */
800049e0:	91 20 00 5f 	movh.a %a5,61442
800049e4:	d9 e4 d8 ff 	lea %a4,[%a14]-40
800049e8:	6d ff 6f e6 	call 800016c6 <IfxVadc_Adc_initModuleConfig>
    IfxVadc_Adc_initModule(&Vadc, &adcConf);                /* Vadc를 adcConf 값으로 초기화 */
800049ec:	91 00 00 c6 	movh.a %a12,24576
800049f0:	d9 cc 38 50 	lea %a12,[%a12]376 <60000178 <Vadc>>
800049f4:	d9 e5 d8 ff 	lea %a5,[%a14]-40 <60000178 <Vadc>>
800049f8:	40 c4       	mov.aa %a4,%a12
800049fa:	6d ff dc e5 	call 800015b2 <IfxVadc_Adc_initModule>

    IfxVadc_Adc_GroupConfig     adcGroupConf;               /* Define a configuration structure for the VADC group */
    IfxVadc_Adc_initGroupConfig(&adcGroupConf, &Vadc);      /* adc 그룹 구조체 초기화 및 Vadc 값 반영 */
800049fe:	40 c5       	mov.aa %a5,%a12
80004a00:	d9 e4 dc df 	lea %a4,[%a14]-164
80004a04:	6d ff bc e5 	call 8000157c <IfxVadc_Adc_initGroupConfig>

    adcGroupConf.groupId = IfxVadc_GroupId_3;               /* Select the group 다른 아이디로는 그룹2, 그룹3으로 지정*/
80004a08:	82 32       	mov %d2,3
80004a0a:	59 e2 e0 df 	st.w [%a14]-160,%d2
    adcGroupConf.master = adcGroupConf.groupId;             /* Select the master group */
80004a0e:	59 e2 e4 df 	st.w [%a14]-156,%d2

    adcGroupConf.arbiter.requestSlotScanEnabled = TRUE;     /* Enabled scan source 별도의 설정없이 ADC변환*/
80004a12:	82 12       	mov %d2,1
80004a14:	e9 e2 d5 ff 	st.b [%a14]-43,%d2
    adcGroupConf.scanRequest.autoscanEnabled    = TRUE;     /* Enabled auto scan mode */
80004a18:	e9 e2 f8 df 	st.b [%a14]-136,%d2

    adcGroupConf.scanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;  /* 특정 트리거 조건 없이 항상 변환 수행/인터럽트일 때는 다른 모드 */
80004a1c:	82 12       	mov %d2,1
80004a1e:	59 e2 c4 ef 	st.w [%a14]-124,%d2

    IfxVadc_Adc_initGroup(&adcGroup3, &adcGroupConf);       /* adc 그룹 설정 값 반영 */
80004a22:	d9 e5 dc df 	lea %a5,[%a14]-164
80004a26:	91 00 00 46 	movh.a %a4,24576
80004a2a:	d9 44 2c 50 	lea %a4,[%a4]364 <6000016c <adcGroup3>>
80004a2e:	6d ff 65 e3 	call 800010f8 <IfxVadc_Adc_initGroup>
}
80004a32:	00 90       	ret 

80004a34 <init_ADC_G3_SingleCh>:

void init_ADC_G3_SingleCh(uint8 Channel)
{
80004a34:	40 ae       	mov.aa %a14,%sp
80004a36:	20 40       	sub.a %sp,64
80004a38:	8f f4 0f 81 	and %d8,%d4,255
    IfxVadc_Adc_ChannelConfig   adcChannelConfigInfo;
    uint32 ulTemp = ((uint32)1u << Channel);
80004a3c:	82 19       	mov %d9,1
80004a3e:	0f 89 00 90 	sh %d9,%d9,%d8

    IfxVadc_Adc_initChannelConfig(&adcChannelConfigInfo, &adcGroup3);           /* Fill it with default values */
80004a42:	91 00 00 c6 	movh.a %a12,24576
80004a46:	d9 cc 2c 50 	lea %a12,[%a12]364 <6000016c <adcGroup3>>
80004a4a:	40 c5       	mov.aa %a5,%a12
80004a4c:	d9 e4 c4 ff 	lea %a4,[%a14]-60
80004a50:	6d ff 49 e3 	call 800010e2 <IfxVadc_Adc_initChannelConfig>

    adcChannelConfigInfo.channelId      = (IfxVadc_ChannelId) Channel;          /* Select the channel ID */
80004a54:	59 e8 dc ff 	st.w [%a14]-36,%d8
    adcChannelConfigInfo.resultRegister = (IfxVadc_ChannelResult) (Channel);    /* Use dedicated result register */
80004a58:	59 e8 e8 ff 	st.w [%a14]-24,%d8

    /* Initialize the channel */
    IfxVadc_Adc_initChannel(&adcG3Channel[Channel], &adcChannelConfigInfo);     /* 채널 초기화 */
80004a5c:	d9 e5 c4 ff 	lea %a5,[%a14]-60
80004a60:	91 00 00 46 	movh.a %a4,24576
80004a64:	d9 44 0c 40 	lea %a4,[%a4]268 <6000010c <adcG3Channel>>
80004a68:	01 48 03 46 	addsc.a %a4,%a4,%d8,3
80004a6c:	01 48 02 46 	addsc.a %a4,%a4,%d8,2
80004a70:	6d ff 27 e2 	call 80000ebe <IfxVadc_Adc_initChannel>
}


IFX_INLINE void IfxVadc_Adc_setScan(IfxVadc_Adc_Group *group, uint32 channels, uint32 mask)
{
    IfxVadc_setScan(group->group, channels, mask);
80004a74:	02 95       	mov %d5,%d9
80004a76:	02 94       	mov %d4,%d9
80004a78:	99 c4 04 00 	ld.a %a4,[%a12]4 <60000004 <LCF_DSPR1_START+0x4>>
80004a7c:	6d ff ed e1 	call 80000e56 <IfxVadc_setScan>

    /* Add the channel to the scan sequence */
    IfxVadc_Adc_setScan(&adcGroup3, ulTemp, ulTemp);                            /* the background scan sequence */
}
80004a80:	00 90       	ret 

80004a82 <init_ADC_G3_Channel>:

void init_ADC_G3_Channel(void)
{
80004a82:	40 ae       	mov.aa %a14,%sp
    init_ADC_G3_SingleCh(ADC_G3_CH0);   /* 각 채널 초기화 */
80004a84:	82 04       	mov %d4,0
80004a86:	6d ff d7 ff 	call 80004a34 <init_ADC_G3_SingleCh>
    init_ADC_G3_SingleCh(ADC_G3_CH1);   //litekit A0(가변저항)
80004a8a:	82 14       	mov %d4,1
80004a8c:	6d ff d4 ff 	call 80004a34 <init_ADC_G3_SingleCh>
    init_ADC_G3_SingleCh(ADC_G3_CH2);
80004a90:	82 24       	mov %d4,2
80004a92:	6d ff d1 ff 	call 80004a34 <init_ADC_G3_SingleCh>
    init_ADC_G3_SingleCh(ADC_G3_CH3);
80004a96:	82 34       	mov %d4,3
80004a98:	6d ff ce ff 	call 80004a34 <init_ADC_G3_SingleCh>
    init_ADC_G3_SingleCh(ADC_G3_CH4);
80004a9c:	82 44       	mov %d4,4
80004a9e:	6d ff cb ff 	call 80004a34 <init_ADC_G3_SingleCh>
    init_ADC_G3_SingleCh(ADC_G3_CH5);
80004aa2:	82 54       	mov %d4,5
80004aa4:	6d ff c8 ff 	call 80004a34 <init_ADC_G3_SingleCh>
    init_ADC_G3_SingleCh(ADC_G3_CH6);
80004aa8:	82 64       	mov %d4,6
80004aaa:	6d ff c5 ff 	call 80004a34 <init_ADC_G3_SingleCh>
    init_ADC_G3_SingleCh(ADC_G3_CH7);   //가변저항
80004aae:	82 74       	mov %d4,7
80004ab0:	6d ff c2 ff 	call 80004a34 <init_ADC_G3_SingleCh>
}


IFX_INLINE void IfxVadc_Adc_startScan(IfxVadc_Adc_Group *group)
{
    IfxVadc_startScan(group->group);
80004ab4:	91 00 00 26 	movh.a %a2,24576
80004ab8:	d9 22 2c 50 	lea %a2,[%a2]364 <6000016c <adcGroup3>>
80004abc:	b0 42       	add.a %a2,4
80004abe:	d4 22       	ld.a %a2,[%a2]
    group->ASMR.B.LDEV = 1;     /* set Load event. Channels stored in ASSEL will be copied into pending register and conversion will start */
80004ac0:	d9 23 24 20 	lea %a3,[%a2]164
80004ac4:	19 22 24 20 	ld.w %d2,[%a2]164
80004ac8:	b7 12 81 24 	insert %d2,%d2,1,9,1
80004acc:	74 32       	st.w [%a3],%d2

    IfxVadc_Adc_startScan(&adcGroup3);  //아날로그값이 실제값으로 변환
    }
80004ace:	00 90       	ret 

80004ad0 <ADC_G3_GetData>:

void ADC_G3_GetData(void)   //실제값을 디지털로 변환해서 가져오는 함수
{
80004ad0:	40 ae       	mov.aa %a14,%sp
    Ifx_VADC_RES    ADC_result;                                     /* 변환 결과 값 구조체 선언 */

    uint8 ch;
    for (ch = ADC_G3_CH0; ch < ADC_G3_MAX; ch++)
80004ad2:	82 03       	mov %d3,0
80004ad4:	1d 00 25 00 	j 80004b1e <ADC_G3_GetData+0x4e>
    return IfxVadc_getResult(channel->group->group, channel->resultreg);
80004ad8:	91 00 00 26 	movh.a %a2,24576
80004adc:	80 22       	mov.d %d2,%a2
80004ade:	1b c2 10 20 	addi %d2,%d2,268
80004ae2:	13 c3 20 22 	madd %d2,%d2,%d3,12
80004ae6:	60 22       	mov.a %a2,%d2
80004ae8:	99 23 08 00 	ld.a %a3,[%a2]8
80004aec:	19 34 04 00 	ld.w %d4,[%a3]4
80004af0:	19 22 04 00 	ld.w %d2,[%a2]4
    tmpResult.U = group->RES[resultIdx].U;
80004af4:	1b 02 0a 20 	addi %d2,%d2,160
80004af8:	06 22       	sh %d2,2
80004afa:	60 42       	mov.a %a2,%d4
80004afc:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80004b00:	54 22       	ld.w %d2,[%a2]
    {
        do{
            ADC_result = IfxVadc_Adc_getResult(&adcG3Channel[ch]);  /* 결과 값 가져오기 */
        }while(!ADC_result.B.VF);
80004b02:	ff 02 eb 7f 	jge %d2,0,80004ad8 <ADC_G3_GetData+0x8>

        ADC_G3_RAWDATA[ch] = ADC_result.B.RESULT;                   /* 결과 값 저장 */
80004b06:	8f 13 00 40 	sh %d4,%d3,1
80004b0a:	91 00 00 26 	movh.a %a2,24576
80004b0e:	d9 22 3c 30 	lea %a2,[%a2]252 <600000fc <ADC_G3_RAWDATA>>
80004b12:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80004b16:	b4 22       	st.h [%a2],%d2
    for (ch = ADC_G3_CH0; ch < ADC_G3_MAX; ch++)
80004b18:	c2 13       	add %d3,1
80004b1a:	8f f3 0f 31 	and %d3,%d3,255
80004b1e:	bf 83 dd ff 	jlt.u %d3,8,80004ad8 <ADC_G3_GetData+0x8>
    IfxVadc_startScan(group->group);
80004b22:	91 00 00 26 	movh.a %a2,24576
80004b26:	d9 22 2c 50 	lea %a2,[%a2]364 <6000016c <adcGroup3>>
80004b2a:	b0 42       	add.a %a2,4
80004b2c:	d4 22       	ld.a %a2,[%a2]
    group->ASMR.B.LDEV = 1;     /* set Load event. Channels stored in ASSEL will be copied into pending register and conversion will start */
80004b2e:	d9 23 24 20 	lea %a3,[%a2]164
80004b32:	19 22 24 20 	ld.w %d2,[%a2]164
80004b36:	b7 12 81 24 	insert %d2,%d2,1,9,1
80004b3a:	74 32       	st.w [%a3],%d2
    }

    IfxVadc_Adc_startScan(&adcGroup3);
}
80004b3c:	00 90       	ret 

80004b3e <core0_main>:

IfxCpu_syncEvent g_cpuSyncEvent = 0;


void core0_main(void)
{
80004b3e:	40 ae       	mov.aa %a14,%sp
    __enable();
80004b40:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
80004b44:	6d ff 4a eb 	call 800021d8 <IfxScuWdt_getCpuWatchdogPassword>
80004b48:	02 24       	mov %d4,%d2
80004b4a:	6d ff 2b ea 	call 80001fa0 <IfxScuWdt_disableCpuWatchdog>
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
80004b4e:	6d ff 57 eb 	call 800021fc <IfxScuWdt_getSafetyWatchdogPassword>
80004b52:	02 24       	mov %d4,%d2
80004b54:	6d ff 65 ea 	call 8000201e <IfxScuWdt_disableSafetyWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
80004b58:	91 00 00 c6 	movh.a %a12,24576
80004b5c:	d9 cc 00 10 	lea %a12,[%a12]64 <60000040 <g_cpuSyncEvent>>
80004b60:	40 c4       	mov.aa %a4,%a12
80004b62:	6d ff a7 f9 	call 80003eb0 <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
80004b66:	82 14       	mov %d4,1
80004b68:	40 c4       	mov.aa %a4,%a12
80004b6a:	6d ff 63 f9 	call 80003e30 <IfxCpu_waitEvent>

    init_GPIO();
80004b6e:	6d ff a2 fe 	call 800048b2 <init_GPIO>
    init_STM();
80004b72:	6d ff d3 dd 	call 80000718 <init_STM>
    init_ADC_Group(); init_ADC_G3_Channel();
80004b76:	6d ff 33 ff 	call 800049dc <init_ADC_Group>
80004b7a:	6d ff 84 ff 	call 80004a82 <init_ADC_G3_Channel>
    init_GTM();
80004b7e:	6d ff a5 df 	call 80000ac8 <init_GTM>
    direction =1;
80004b82:	91 00 00 26 	movh.a %a2,24576
80004b86:	82 12       	mov %d2,1
80004b88:	59 22 28 30 	st.w [%a2]232 <600000e8 <direction>>,%d2

    while(1)
    {
        AppScheduling();
80004b8c:	6d ff 9f dd 	call 800006ca <AppScheduling>
    while(1)
80004b90:	1d ff fe ff 	j 80004b8c <core0_main+0x4e>

80004b94 <core1_main>:
#include "Header_USER.h"

extern IfxCpu_syncEvent g_cpuSyncEvent;

void core1_main(void)
{
80004b94:	40 ae       	mov.aa %a14,%sp
80004b96:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG1 IS DISABLED HERE!!
     * Enable the watchdog and service it periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
80004b9a:	6d ff 1f eb 	call 800021d8 <IfxScuWdt_getCpuWatchdogPassword>
80004b9e:	02 24       	mov %d4,%d2
80004ba0:	6d ff 00 ea 	call 80001fa0 <IfxScuWdt_disableCpuWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
80004ba4:	91 00 00 c6 	movh.a %a12,24576
80004ba8:	d9 cc 00 10 	lea %a12,[%a12]64 <60000040 <g_cpuSyncEvent>>
80004bac:	40 c4       	mov.aa %a4,%a12
80004bae:	6d ff 81 f9 	call 80003eb0 <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
80004bb2:	82 14       	mov %d4,1
80004bb4:	40 c4       	mov.aa %a4,%a12
80004bb6:	6d ff 3d f9 	call 80003e30 <IfxCpu_waitEvent>
    
    while(1)
    {
        Encoder();
80004bba:	6d ff 90 fe 	call 800048da <Encoder>
    while(1)
80004bbe:	1d ff fe ff 	j 80004bba <core1_main+0x26>

80004bc2 <core2_main>:
#include "IfxScuWdt.h"

extern IfxCpu_syncEvent g_cpuSyncEvent;

void core2_main(void)
{
80004bc2:	40 ae       	mov.aa %a14,%sp
80004bc4:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG2 IS DISABLED HERE!!
     * Enable the watchdog and service it periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
80004bc8:	6d ff 08 eb 	call 800021d8 <IfxScuWdt_getCpuWatchdogPassword>
80004bcc:	02 24       	mov %d4,%d2
80004bce:	6d ff e9 e9 	call 80001fa0 <IfxScuWdt_disableCpuWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
80004bd2:	91 00 00 c6 	movh.a %a12,24576
80004bd6:	d9 cc 00 10 	lea %a12,[%a12]64 <60000040 <g_cpuSyncEvent>>
80004bda:	40 c4       	mov.aa %a4,%a12
80004bdc:	6d ff 6a f9 	call 80003eb0 <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
80004be0:	82 14       	mov %d4,1
80004be2:	40 c4       	mov.aa %a4,%a12
80004be4:	6d ff 26 f9 	call 80003e30 <IfxCpu_waitEvent>
    
    while(1)
80004be8:	1d 00 00 00 	j 80004be8 <core2_main+0x26>

80004bec <memset>:
80004bec:	40 42       	mov.aa %a2,%a4
80004bee:	df 05 07 00 	jeq %d5,0,80004bfc <memset+0x10>
80004bf2:	60 53       	mov.a %a3,%d5
80004bf4:	b0 f3       	add.a %a3,-1
80004bf6:	24 44       	st.b [%a4+],%d4
80004bf8:	fd 30 ff 7f 	loop %a3,80004bf6 <memset+0xa>
80004bfc:	00 90       	ret 

80004bfe <__extendsfdf2>:
80004bfe:	20 20       	sub.a %sp,32
80004c00:	d9 a5 10 00 	lea %a5,[%sp]16
80004c04:	d9 a4 0c 00 	lea %a4,[%sp]12
80004c08:	59 a4 0c 00 	st.w [%sp]12,%d4
80004c0c:	6d 00 7f 03 	call 8000530a <__unpack_f>
80004c10:	19 a2 1c 00 	ld.w %d2,[%sp]28
80004c14:	19 a6 18 00 	ld.w %d6,[%sp]24
80004c18:	53 12 40 40 	mul.u %e4,%d2,1
80004c1c:	77 45 00 3f 	dextr %d3,%d5,%d4,30
80004c20:	8f e4 01 20 	sh %d2,%d4,30
80004c24:	19 a5 14 00 	ld.w %d5,[%sp]20
80004c28:	19 a4 10 00 	ld.w %d4,[%sp]16
80004c2c:	74 a2       	st.w [%sp],%d2
80004c2e:	59 a3 04 00 	st.w [%sp]4,%d3
80004c32:	6d 00 3d 03 	call 800052ac <__make_dp>
80004c36:	00 90       	ret 

80004c38 <_fpadd_parts>:
80004c38:	54 42       	ld.w %d2,[%a4]
80004c3a:	40 42       	mov.aa %a2,%a4
80004c3c:	bf 22 c2 80 	jlt.u %d2,2,80004dc0 <_fpadd_parts+0x188>
80004c40:	54 53       	ld.w %d3,[%a5]
80004c42:	40 52       	mov.aa %a2,%a5
80004c44:	bf 23 be 80 	jlt.u %d3,2,80004dc0 <_fpadd_parts+0x188>
80004c48:	df 42 e3 00 	jeq %d2,4,80004e0e <_fpadd_parts+0x1d6>
80004c4c:	df 43 ba 00 	jeq %d3,4,80004dc0 <_fpadd_parts+0x188>
80004c50:	df 23 b9 00 	jeq %d3,2,80004dc2 <_fpadd_parts+0x18a>
80004c54:	df 22 b6 00 	jeq %d2,2,80004dc0 <_fpadd_parts+0x188>
80004c58:	19 40 08 00 	ld.w %d0,[%a4]8
80004c5c:	19 57 08 00 	ld.w %d7,[%a5]8
80004c60:	09 44 4c 09 	ld.d %e4,[%a4]12
80004c64:	0b 70 80 60 	sub %d6,%d0,%d7
80004c68:	09 52 4c 09 	ld.d %e2,[%a5]12
80004c6c:	bf 06 c2 00 	jlt %d6,0,80004df0 <_fpadd_parts+0x1b8>
80004c70:	8b 06 84 12 	ge %d1,%d6,64
80004c74:	df 01 c4 80 	jne %d1,0,80004dfc <_fpadd_parts+0x1c4>
80004c78:	df 06 2a 00 	jeq %d6,0,80004ccc <_fpadd_parts+0x94>
80004c7c:	8b 06 82 72 	ge %d7,%d6,32
80004c80:	2b 32 50 97 	seln %d9,%d7,%d2,%d3
80004c84:	ab 03 a0 87 	seln %d8,%d7,%d3,0
80004c88:	8f f6 01 71 	and %d7,%d6,31
80004c8c:	8b 07 02 11 	rsub %d1,%d7,32
80004c90:	17 98 80 11 	dextr %d1,%d8,%d9,%d1
80004c94:	2b 91 40 17 	sel %d1,%d7,%d1,%d9
80004c98:	8b 06 82 a2 	ge %d10,%d6,32
80004c9c:	32 57       	rsub %d7
80004c9e:	02 19       	mov %d9,%d1
80004ca0:	8f f6 01 61 	and %d6,%d6,31
80004ca4:	82 f1       	mov %d1,-1
80004ca6:	0f 78 00 80 	sh %d8,%d8,%d7
80004caa:	17 11 80 76 	dextr %d7,%d1,%d1,%d6
80004cae:	0f 61 00 60 	sh %d6,%d1,%d6
80004cb2:	2b 67 50 7a 	seln %d7,%d10,%d7,%d6
80004cb6:	ab 06 a0 6a 	seln %d6,%d10,%d6,0
80004cba:	0f 62 e0 10 	andn %d1,%d2,%d6
80004cbe:	0f 73 e0 60 	andn %d6,%d3,%d7
80004cc2:	a6 16       	or %d6,%d1
80004cc4:	8b 06 00 95 	or.ne %d9,%d6,0
80004cc8:	0b 98 10 28 	mov %e2,%d8,%d9
80004ccc:	19 41 04 00 	ld.w %d1,[%a4]4
80004cd0:	19 56 04 00 	ld.w %d6,[%a5]4
80004cd4:	5f 61 4c 00 	jeq %d1,%d6,80004d6c <_fpadd_parts+0x134>
80004cd8:	0b 24 c0 60 	subx %d6,%d4,%d2
80004cdc:	0b 35 d0 70 	subc %d7,%d5,%d3
80004ce0:	df 01 06 00 	jeq %d1,0,80004cec <_fpadd_parts+0xb4>
80004ce4:	0b 42 c0 60 	subx %d6,%d2,%d4
80004ce8:	0b 53 d0 70 	subc %d7,%d3,%d5
80004cec:	8b 07 00 31 	rsub %d3,%d7,0
80004cf0:	8b 06 00 91 	rsub %d9,%d6,0
80004cf4:	ab f3 1f 36 	cadd %d3,%d6,%d3,-1
80004cf8:	82 12       	mov %d2,1
80004cfa:	bf 07 05 00 	jlt %d7,0,80004d04 <_fpadd_parts+0xcc>
80004cfe:	02 69       	mov %d9,%d6
80004d00:	02 73       	mov %d3,%d7
80004d02:	82 02       	mov %d2,0
80004d04:	8b f9 9f 70 	addx %d7,%d9,-1
80004d08:	82 f5       	mov %d5,-1
80004d0a:	8b f3 bf 60 	addc %d6,%d3,-1
80004d0e:	06 c5       	sh %d5,-4
80004d10:	59 62 04 00 	st.w [%a6]4,%d2
80004d14:	82 e1       	mov %d1,-2
80004d16:	0b 56 00 21 	eq %d2,%d6,%d5
80004d1a:	0b 71 30 22 	and.lt.u %d2,%d1,%d7
80004d1e:	59 60 08 00 	st.w [%a6]8,%d0
80004d22:	59 69 0c 00 	st.w [%a6]12,%d9
80004d26:	59 63 10 00 	st.w [%a6]16,%d3
80004d2a:	0b 65 a0 22 	or.lt.u %d2,%d5,%d6
80004d2e:	df 02 2b 80 	jne %d2,0,80004d84 <_fpadd_parts+0x14c>
80004d32:	1b f0 ff 7f 	addi %d7,%d0,-1
80004d36:	77 93 80 30 	dextr %d3,%d3,%d9,1
80004d3a:	06 19       	sh %d9,1
80004d3c:	8b f9 9f 00 	addx %d0,%d9,-1
80004d40:	8b f3 bf 60 	addc %d6,%d3,-1
80004d44:	0b 56 00 21 	eq %d2,%d6,%d5
80004d48:	0b 01 50 22 	and.ge.u %d2,%d1,%d0
80004d4c:	0b 56 a0 22 	or.lt.u %d2,%d6,%d5
80004d50:	02 78       	mov %d8,%d7
80004d52:	c2 f7       	add %d7,-1
80004d54:	df 02 f1 ff 	jne %d2,0,80004d36 <_fpadd_parts+0xfe>
80004d58:	82 32       	mov %d2,3
80004d5a:	59 69 0c 00 	st.w [%a6]12,%d9
80004d5e:	59 63 10 00 	st.w [%a6]16,%d3
80004d62:	59 68 08 00 	st.w [%a6]8,%d8
80004d66:	74 62       	st.w [%a6],%d2
80004d68:	40 62       	mov.aa %a2,%a6
80004d6a:	00 90       	ret 
80004d6c:	0b 24 40 90 	addx %d9,%d4,%d2
80004d70:	0b 35 50 30 	addc %d3,%d5,%d3
80004d74:	59 61 04 00 	st.w [%a6]4,%d1
80004d78:	59 60 08 00 	st.w [%a6]8,%d0
80004d7c:	59 69 0c 00 	st.w [%a6]12,%d9
80004d80:	59 63 10 00 	st.w [%a6]16,%d3
80004d84:	82 32       	mov %d2,3
80004d86:	7b 00 00 52 	movh %d5,8192
80004d8a:	40 62       	mov.aa %a2,%a6
80004d8c:	74 62       	st.w [%a6],%d2
80004d8e:	0b 53 00 21 	eq %d2,%d3,%d5
80004d92:	b7 02 01 20 	insert %d2,%d2,0,0,1
80004d96:	0b 53 a0 22 	or.lt.u %d2,%d3,%d5
80004d9a:	df 02 13 80 	jne %d2,0,80004dc0 <_fpadd_parts+0x188>
80004d9e:	8f f3 1f 20 	sh %d2,%d3,-1
80004da2:	77 93 80 5f 	dextr %d5,%d3,%d9,31
80004da6:	8f 19 00 31 	and %d3,%d9,1
80004daa:	59 62 10 00 	st.w [%a6]16,%d2
80004dae:	19 62 08 00 	ld.w %d2,[%a6]8
80004db2:	a6 53       	or %d3,%d5
80004db4:	c2 12       	add %d2,1
80004db6:	d9 63 08 00 	lea %a3,[%a6]8
80004dba:	59 63 0c 00 	st.w [%a6]12,%d3
80004dbe:	74 32       	st.w [%a3],%d2
80004dc0:	00 90       	ret 
80004dc2:	40 42       	mov.aa %a2,%a4
80004dc4:	df 22 fe ff 	jne %d2,2,80004dc0 <_fpadd_parts+0x188>
80004dc8:	40 63       	mov.aa %a3,%a6
80004dca:	09 44 48 01 	ld.d %e4,[%a4+]8
80004dce:	89 34 48 01 	st.d [%a3+]8,%e4
80004dd2:	09 44 48 01 	ld.d %e4,[%a4+]8
80004dd6:	89 34 48 01 	st.d [%a3+]8,%e4
80004dda:	44 44       	ld.w %d4,[%a4+]
80004ddc:	64 34       	st.w [%a3+],%d4
80004dde:	19 23 04 00 	ld.w %d3,[%a2]4
80004de2:	19 52 04 00 	ld.w %d2,[%a5]4
80004de6:	40 62       	mov.aa %a2,%a6
80004de8:	26 32       	and %d2,%d3
80004dea:	59 62 04 00 	st.w [%a6]4,%d2
80004dee:	00 90       	ret 
80004df0:	0b 07 80 60 	sub %d6,%d7,%d0
80004df4:	8b 06 44 12 	lt %d1,%d6,64
80004df8:	df 01 1d 80 	jne %d1,0,80004e32 <_fpadd_parts+0x1fa>
80004dfc:	3f 07 06 00 	jlt %d7,%d0,80004e08 <_fpadd_parts+0x1d0>
80004e00:	d2 04       	mov %e4,0
80004e02:	02 70       	mov %d0,%d7
80004e04:	1d ff 64 ff 	j 80004ccc <_fpadd_parts+0x94>
80004e08:	d2 02       	mov %e2,0
80004e0a:	1d ff 61 ff 	j 80004ccc <_fpadd_parts+0x94>
80004e0e:	40 42       	mov.aa %a2,%a4
80004e10:	df 43 d8 ff 	jne %d3,4,80004dc0 <_fpadd_parts+0x188>
80004e14:	19 43 04 00 	ld.w %d3,[%a4]4
80004e18:	19 52 04 00 	ld.w %d2,[%a5]4
80004e1c:	7b 00 00 48 	movh %d4,32768
80004e20:	0b 23 10 21 	ne %d2,%d3,%d2
80004e24:	1b 04 20 40 	addi %d4,%d4,512
80004e28:	80 43       	mov.d %d3,%a4
80004e2a:	2b 43 50 22 	seln %d2,%d2,%d3,%d4
80004e2e:	60 22       	mov.a %a2,%d2
80004e30:	00 90       	ret 
80004e32:	8b 06 82 02 	ge %d0,%d6,32
80004e36:	2b 54 50 90 	seln %d9,%d0,%d4,%d5
80004e3a:	ab 05 a0 80 	seln %d8,%d0,%d5,0
80004e3e:	8f f6 01 01 	and %d0,%d6,31
80004e42:	8b 00 02 11 	rsub %d1,%d0,32
80004e46:	17 98 80 11 	dextr %d1,%d8,%d9,%d1
80004e4a:	2b 91 40 10 	sel %d1,%d0,%d1,%d9
80004e4e:	8b 06 82 a2 	ge %d10,%d6,32
80004e52:	32 50       	rsub %d0
80004e54:	02 19       	mov %d9,%d1
80004e56:	8f f6 01 61 	and %d6,%d6,31
80004e5a:	82 f1       	mov %d1,-1
80004e5c:	0f 08 00 80 	sh %d8,%d8,%d0
80004e60:	17 11 80 06 	dextr %d0,%d1,%d1,%d6
80004e64:	0f 61 00 60 	sh %d6,%d1,%d6
80004e68:	2b 60 50 0a 	seln %d0,%d10,%d0,%d6
80004e6c:	ab 06 a0 6a 	seln %d6,%d10,%d6,0
80004e70:	0f 64 e0 10 	andn %d1,%d4,%d6
80004e74:	0f 05 e0 60 	andn %d6,%d5,%d0
80004e78:	a6 16       	or %d6,%d1
80004e7a:	8b 06 00 95 	or.ne %d9,%d6,0
80004e7e:	0b 98 10 48 	mov %e4,%d8,%d9
80004e82:	02 70       	mov %d0,%d7
80004e84:	1d ff 24 ff 	j 80004ccc <_fpadd_parts+0x94>

80004e88 <__adddf3>:
80004e88:	20 50       	sub.a %sp,80
80004e8a:	d9 a5 14 00 	lea %a5,[%sp]20
80004e8e:	d9 a4 04 00 	lea %a4,[%sp]4
80004e92:	89 a4 44 09 	st.d [%sp]4,%e4
80004e96:	89 a6 4c 09 	st.d [%sp]12,%e6
80004e9a:	6d 00 57 03 	call 80005548 <__unpack_d>
80004e9e:	d9 a5 28 00 	lea %a5,[%sp]40
80004ea2:	d9 a4 0c 00 	lea %a4,[%sp]12
80004ea6:	6d 00 51 03 	call 80005548 <__unpack_d>
80004eaa:	d9 a4 14 00 	lea %a4,[%sp]20
80004eae:	d9 a6 3c 00 	lea %a6,[%sp]60
80004eb2:	d9 a5 28 00 	lea %a5,[%sp]40
80004eb6:	6d ff c1 fe 	call 80004c38 <_fpadd_parts>
80004eba:	40 24       	mov.aa %a4,%a2
80004ebc:	6d 00 77 02 	call 800053aa <__pack_d>
80004ec0:	00 90       	ret 

80004ec2 <__muldf3>:
80004ec2:	20 50       	sub.a %sp,80
80004ec4:	d9 a5 14 00 	lea %a5,[%sp]20
80004ec8:	d9 a4 04 00 	lea %a4,[%sp]4
80004ecc:	89 a4 44 09 	st.d [%sp]4,%e4
80004ed0:	89 a6 4c 09 	st.d [%sp]12,%e6
80004ed4:	6d 00 3a 03 	call 80005548 <__unpack_d>
80004ed8:	d9 a5 28 00 	lea %a5,[%sp]40
80004edc:	d9 a4 0c 00 	lea %a4,[%sp]12
80004ee0:	6d 00 34 03 	call 80005548 <__unpack_d>
80004ee4:	19 a2 14 00 	ld.w %d2,[%sp]20
80004ee8:	ff 22 0f 80 	jge.u %d2,2,80004f06 <__muldf3+0x44>
80004eec:	19 a3 18 00 	ld.w %d3,[%sp]24
80004ef0:	19 a2 2c 00 	ld.w %d2,[%sp]44
80004ef4:	d9 a4 14 00 	lea %a4,[%sp]20
80004ef8:	0b 23 10 21 	ne %d2,%d3,%d2
80004efc:	59 a2 18 00 	st.w [%sp]24,%d2
80004f00:	6d 00 55 02 	call 800053aa <__pack_d>
80004f04:	00 90       	ret 
80004f06:	19 a3 28 00 	ld.w %d3,[%sp]40
80004f0a:	bf 23 14 80 	jlt.u %d3,2,80004f32 <__muldf3+0x70>
80004f0e:	df 42 0a 80 	jne %d2,4,80004f22 <__muldf3+0x60>
80004f12:	91 00 00 48 	movh.a %a4,32768
80004f16:	d9 44 00 80 	lea %a4,[%a4]512 <80000200 <__thenan_df>>
80004f1a:	df 23 f3 7f 	jeq %d3,2,80004f00 <__muldf3+0x3e>
80004f1e:	1d ff e7 ff 	j 80004eec <__muldf3+0x2a>
80004f22:	df 43 15 80 	jne %d3,4,80004f4c <__muldf3+0x8a>
80004f26:	91 00 00 48 	movh.a %a4,32768
80004f2a:	d9 44 00 80 	lea %a4,[%a4]512 <80000200 <__thenan_df>>
80004f2e:	df 22 e9 7f 	jeq %d2,2,80004f00 <__muldf3+0x3e>
80004f32:	19 a2 2c 00 	ld.w %d2,[%sp]44
80004f36:	19 a3 18 00 	ld.w %d3,[%sp]24
80004f3a:	d9 a4 28 00 	lea %a4,[%sp]40
80004f3e:	0b 23 10 21 	ne %d2,%d3,%d2
80004f42:	59 a2 2c 00 	st.w [%sp]44,%d2
80004f46:	6d 00 32 02 	call 800053aa <__pack_d>
80004f4a:	00 90       	ret 
80004f4c:	19 a5 2c 00 	ld.w %d5,[%sp]44
80004f50:	19 a4 18 00 	ld.w %d4,[%sp]24
80004f54:	0b 45 10 a1 	ne %d10,%d5,%d4
80004f58:	df 22 aa 00 	jeq %d2,2,800050ac <__muldf3+0x1ea>
80004f5c:	df 23 ae 00 	jeq %d3,2,800050b8 <__muldf3+0x1f6>
80004f60:	19 a6 34 00 	ld.w %d6,[%sp]52
80004f64:	19 a4 20 00 	ld.w %d4,[%sp]32
80004f68:	82 03       	mov %d3,0
80004f6a:	73 46 68 00 	mul.u %e0,%d6,%d4
80004f6e:	19 a2 38 00 	ld.w %d2,[%sp]56
80004f72:	82 0b       	mov %d11,0
80004f74:	03 36 0a 11 	madd %d1,%d1,%d6,%d3
80004f78:	02 48       	mov %d8,%d4
80004f7a:	19 a7 24 00 	ld.w %d7,[%sp]36
80004f7e:	03 4b 0a 11 	madd %d1,%d1,%d11,%d4
80004f82:	73 42 68 40 	mul.u %e4,%d2,%d4
80004f86:	82 0d       	mov %d13,0
80004f88:	82 0c       	mov %d12,0
80004f8a:	03 32 0a 55 	madd %d5,%d5,%d2,%d3
80004f8e:	03 8d 0a 55 	madd %d5,%d5,%d13,%d8
80004f92:	73 27 68 80 	mul.u %e8,%d7,%d2
80004f96:	03 d7 0a 99 	madd %d9,%d9,%d7,%d13
80004f9a:	03 2c 0a 99 	madd %d9,%d9,%d12,%d2
80004f9e:	03 67 68 24 	madd.u %e2,%e4,%d7,%d6
80004fa2:	03 b7 0a 33 	madd %d3,%d3,%d7,%d11
80004fa6:	03 6c 0a 33 	madd %d3,%d3,%d12,%d6
80004faa:	0b 35 00 61 	eq %d6,%d5,%d3
80004fae:	0b 42 30 62 	and.lt.u %d6,%d2,%d4
80004fb2:	0b 53 a0 62 	or.lt.u %d6,%d3,%d5
80004fb6:	02 67       	mov %d7,%d6
80004fb8:	82 06       	mov %d6,0
80004fba:	0b 06 40 60 	addx %d6,%d6,%d0
80004fbe:	0b 12 50 50 	addc %d5,%d2,%d1
80004fc2:	0b 51 00 41 	eq %d4,%d1,%d5
80004fc6:	0b 06 50 42 	and.ge.u %d4,%d6,%d0
80004fca:	0b 51 a0 42 	or.lt.u %d4,%d1,%d5
80004fce:	df 04 06 80 	jne %d4,0,80004fda <__muldf3+0x118>
80004fd2:	8b 1b 80 b0 	addx %d11,%d11,1
80004fd6:	8b 07 a0 70 	addc %d7,%d7,0
80004fda:	82 04       	mov %d4,0
80004fdc:	0b 83 40 30 	addx %d3,%d3,%d8
80004fe0:	0b 94 50 20 	addc %d2,%d4,%d9
80004fe4:	0b b3 40 30 	addx %d3,%d3,%d11
80004fe8:	0b 72 50 20 	addc %d2,%d2,%d7
80004fec:	19 a4 1c 00 	ld.w %d4,[%sp]28
80004ff0:	19 a7 30 00 	ld.w %d7,[%sp]48
80004ff4:	59 aa 00 10 	st.w [%sp]64,%d10
80004ff8:	0b 74 00 10 	add %d1,%d4,%d7
80004ffc:	7b 00 00 42 	movh %d4,8192
80005000:	1b 41 00 00 	addi %d0,%d1,4
80005004:	0b 42 00 71 	eq %d7,%d2,%d4
80005008:	b7 07 01 70 	insert %d7,%d7,0,0,1
8000500c:	59 a0 04 10 	st.w [%sp]68,%d0
80005010:	0b 42 a0 72 	or.lt.u %d7,%d2,%d4
80005014:	df 07 2b 80 	jne %d7,0,8000506a <__muldf3+0x1a8>
80005018:	1b 51 00 70 	addi %d7,%d1,5
8000501c:	8f 13 00 01 	and %d0,%d3,1
80005020:	02 71       	mov %d1,%d7
80005022:	df 00 07 00 	jeq %d0,0,80005030 <__muldf3+0x16e>
80005026:	77 65 80 6f 	dextr %d6,%d5,%d6,31
8000502a:	06 f5       	sh %d5,-1
8000502c:	b7 f5 81 5f 	insert %d5,%d5,15,31,1
80005030:	77 32 80 3f 	dextr %d3,%d2,%d3,31
80005034:	06 f2       	sh %d2,-1
80005036:	0b 24 30 01 	lt.u %d0,%d4,%d2
8000503a:	0b 24 70 02 	or.eq %d0,%d4,%d2
8000503e:	c2 17       	add %d7,1
80005040:	df 00 ee ff 	jne %d0,0,8000501c <__muldf3+0x15a>
80005044:	59 a1 04 10 	st.w [%sp]68,%d1
80005048:	8f f3 0f 41 	and %d4,%d3,255
8000504c:	8b 04 28 42 	ne %d4,%d4,128
80005050:	df 04 3a 00 	jeq %d4,0,800050c4 <__muldf3+0x202>
80005054:	59 a2 0c 10 	st.w [%sp]76,%d2
80005058:	82 32       	mov %d2,3
8000505a:	59 a3 08 10 	st.w [%sp]72,%d3
8000505e:	d9 a4 3c 00 	lea %a4,[%sp]60
80005062:	59 a2 3c 00 	st.w [%sp]60,%d2
80005066:	1d ff 4d ff 	j 80004f00 <__muldf3+0x3e>
8000506a:	7b 00 00 71 	movh %d7,4096
8000506e:	0b 27 30 41 	lt.u %d4,%d7,%d2
80005072:	0b 27 70 42 	or.eq %d4,%d7,%d2
80005076:	df 04 e9 ff 	jne %d4,0,80005048 <__muldf3+0x186>
8000507a:	77 32 80 20 	dextr %d2,%d2,%d3,1
8000507e:	c2 f0       	add %d0,-1
80005080:	06 13       	sh %d3,1
80005082:	ff 05 06 00 	jge %d5,0,8000508e <__muldf3+0x1cc>
80005086:	8f 13 40 11 	or %d1,%d3,1
8000508a:	0b 21 10 28 	mov %e2,%d1,%d2
8000508e:	0b 72 00 41 	eq %d4,%d2,%d7
80005092:	b7 04 01 40 	insert %d4,%d4,0,0,1
80005096:	77 65 80 50 	dextr %d5,%d5,%d6,1
8000509a:	0b 72 a0 42 	or.lt.u %d4,%d2,%d7
8000509e:	06 16       	sh %d6,1
800050a0:	df 04 ed ff 	jne %d4,0,8000507a <__muldf3+0x1b8>
800050a4:	59 a0 04 10 	st.w [%sp]68,%d0
800050a8:	1d ff d0 ff 	j 80005048 <__muldf3+0x186>
800050ac:	59 aa 18 00 	st.w [%sp]24,%d10
800050b0:	d9 a4 14 00 	lea %a4,[%sp]20
800050b4:	1d ff 26 ff 	j 80004f00 <__muldf3+0x3e>
800050b8:	59 aa 2c 00 	st.w [%sp]44,%d10
800050bc:	d9 a4 28 00 	lea %a4,[%sp]40
800050c0:	1d ff 20 ff 	j 80004f00 <__muldf3+0x3e>
800050c4:	77 32 00 4c 	dextr %d4,%d2,%d3,24
800050c8:	a6 65       	or %d5,%d6
800050ca:	8b 05 20 52 	ne %d5,%d5,0
800050ce:	0f 45 e0 40 	andn %d4,%d5,%d4
800050d2:	df 04 c1 7f 	jeq %d4,0,80005054 <__muldf3+0x192>
800050d6:	8b 03 88 30 	addx %d3,%d3,128
800050da:	8b 02 a0 20 	addc %d2,%d2,0
800050de:	8f f3 cf 31 	andn %d3,%d3,255
800050e2:	1d ff b9 ff 	j 80005054 <__muldf3+0x192>

800050e6 <__divdf3>:
800050e6:	20 38       	sub.a %sp,56
800050e8:	d9 a5 10 00 	lea %a5,[%sp]16
800050ec:	40 a4       	mov.aa %a4,%sp
800050ee:	89 a4 40 09 	st.d [%sp],%e4
800050f2:	89 a6 48 09 	st.d [%sp]8,%e6
800050f6:	6d 00 29 02 	call 80005548 <__unpack_d>
800050fa:	d9 a5 24 00 	lea %a5,[%sp]36
800050fe:	d9 a4 08 00 	lea %a4,[%sp]8
80005102:	6d 00 23 02 	call 80005548 <__unpack_d>
80005106:	19 a2 10 00 	ld.w %d2,[%sp]16
8000510a:	ff 22 07 80 	jge.u %d2,2,80005118 <__divdf3+0x32>
8000510e:	d9 a4 10 00 	lea %a4,[%sp]16
80005112:	6d 00 4c 01 	call 800053aa <__pack_d>
80005116:	00 90       	ret 
80005118:	19 a3 24 00 	ld.w %d3,[%sp]36
8000511c:	d9 a4 24 00 	lea %a4,[%sp]36
80005120:	bf 23 f9 ff 	jlt.u %d3,2,80005112 <__divdf3+0x2c>
80005124:	19 a5 14 00 	ld.w %d5,[%sp]20
80005128:	19 a4 28 00 	ld.w %d4,[%sp]40
8000512c:	c6 54       	xor %d4,%d5
8000512e:	59 a4 14 00 	st.w [%sp]20,%d4
80005132:	1b e2 ff 4f 	addi %d4,%d2,-2
80005136:	8f 24 c0 41 	andn %d4,%d4,2
8000513a:	df 04 0a 80 	jne %d4,0,8000514e <__divdf3+0x68>
8000513e:	91 00 00 48 	movh.a %a4,32768
80005142:	d9 44 00 80 	lea %a4,[%a4]512 <80000200 <__thenan_df>>
80005146:	5f 32 e4 ff 	jne %d2,%d3,8000510e <__divdf3+0x28>
8000514a:	1d ff e4 ff 	j 80005112 <__divdf3+0x2c>
8000514e:	df 43 51 00 	jeq %d3,4,800051f0 <__divdf3+0x10a>
80005152:	df 23 5a 00 	jeq %d3,2,80005206 <__divdf3+0x120>
80005156:	19 a3 18 00 	ld.w %d3,[%sp]24
8000515a:	19 a2 2c 00 	ld.w %d2,[%sp]44
8000515e:	09 a4 70 09 	ld.d %e4,[%sp]48
80005162:	0b 23 80 00 	sub %d0,%d3,%d2
80005166:	09 a2 5c 09 	ld.d %e2,[%sp]28
8000516a:	0b 53 00 61 	eq %d6,%d3,%d5
8000516e:	02 67       	mov %d7,%d6
80005170:	0b 42 50 72 	and.ge.u %d7,%d2,%d4
80005174:	59 a0 18 00 	st.w [%sp]24,%d0
80005178:	0b 35 a0 72 	or.lt.u %d7,%d5,%d3
8000517c:	df 07 0b 80 	jne %d7,0,80005192 <__divdf3+0xac>
80005180:	1b f0 ff 6f 	addi %d6,%d0,-1
80005184:	77 23 80 30 	dextr %d3,%d3,%d2,1
80005188:	06 12       	sh %d2,1
8000518a:	59 a6 18 00 	st.w [%sp]24,%d6
8000518e:	0b 53 00 61 	eq %d6,%d3,%d5
80005192:	3b d0 03 10 	mov %d1,61
80005196:	d2 08       	mov %e8,0
80005198:	82 00       	mov %d0,0
8000519a:	7b 00 00 71 	movh %d7,4096
8000519e:	1d 00 04 00 	j 800051a6 <__divdf3+0xc0>
800051a2:	0b 53 00 61 	eq %d6,%d3,%d5
800051a6:	0b 42 30 62 	and.lt.u %d6,%d2,%d4
800051aa:	0b 53 a0 62 	or.lt.u %d6,%d3,%d5
800051ae:	df 06 0c 80 	jne %d6,0,800051c6 <__divdf3+0xe0>
800051b2:	0f 08 a0 a0 	or %d10,%d8,%d0
800051b6:	0f 79 a0 60 	or %d6,%d9,%d7
800051ba:	0b 42 c0 20 	subx %d2,%d2,%d4
800051be:	0b a6 10 88 	mov %e8,%d6,%d10
800051c2:	0b 53 d0 30 	subc %d3,%d3,%d5
800051c6:	c2 f1       	add %d1,-1
800051c8:	77 07 80 0f 	dextr %d0,%d7,%d0,31
800051cc:	77 23 80 30 	dextr %d3,%d3,%d2,1
800051d0:	06 f7       	sh %d7,-1
800051d2:	06 12       	sh %d2,1
800051d4:	df 01 e7 ff 	jne %d1,0,800051a2 <__divdf3+0xbc>
800051d8:	8f f8 0f 41 	and %d4,%d8,255
800051dc:	8b 04 28 42 	ne %d4,%d4,128
800051e0:	df 04 1a 00 	jeq %d4,0,80005214 <__divdf3+0x12e>
800051e4:	59 a8 1c 00 	st.w [%sp]28,%d8
800051e8:	59 a9 20 00 	st.w [%sp]32,%d9
800051ec:	1d ff 91 ff 	j 8000510e <__divdf3+0x28>
800051f0:	82 02       	mov %d2,0
800051f2:	a0 02       	mov.a %a2,0
800051f4:	a0 03       	mov.a %a3,0
800051f6:	89 a2 dc 09 	st.da [%sp]28,%a2
800051fa:	59 a2 18 00 	st.w [%sp]24,%d2
800051fe:	d9 a4 10 00 	lea %a4,[%sp]16
80005202:	1d ff 88 ff 	j 80005112 <__divdf3+0x2c>
80005206:	82 42       	mov %d2,4
80005208:	d9 a4 10 00 	lea %a4,[%sp]16
8000520c:	59 a2 10 00 	st.w [%sp]16,%d2
80005210:	1d ff 81 ff 	j 80005112 <__divdf3+0x2c>
80005214:	a6 32       	or %d2,%d3
80005216:	77 89 00 4c 	dextr %d4,%d9,%d8,24
8000521a:	8b 02 20 32 	ne %d3,%d2,0
8000521e:	0f 43 e0 20 	andn %d2,%d3,%d4
80005222:	df 02 e1 7f 	jeq %d2,0,800051e4 <__divdf3+0xfe>
80005226:	8b 08 88 80 	addx %d8,%d8,128
8000522a:	8b 09 a0 90 	addc %d9,%d9,0
8000522e:	8f f8 cf 81 	andn %d8,%d8,255
80005232:	1d ff d9 ff 	j 800051e4 <__divdf3+0xfe>

80005236 <__floatsidf>:
80005236:	82 32       	mov %d2,3
80005238:	20 18       	sub.a %sp,24
8000523a:	59 a2 04 00 	st.w [%sp]4,%d2
8000523e:	8f 14 1e 20 	sh %d2,%d4,-31
80005242:	59 a2 08 00 	st.w [%sp]8,%d2
80005246:	df 04 0e 80 	jne %d4,0,80005262 <__floatsidf+0x2c>
8000524a:	82 22       	mov %d2,2
8000524c:	59 a2 04 00 	st.w [%sp]4,%d2
80005250:	d9 a4 04 00 	lea %a4,[%sp]4
80005254:	6d 00 ab 00 	call 800053aa <__pack_d>
80005258:	60 25       	mov.a %a5,%d2
8000525a:	60 34       	mov.a %a4,%d3
8000525c:	80 52       	mov.d %d2,%a5
8000525e:	80 43       	mov.d %d3,%a4
80005260:	00 90       	ret 
80005262:	ff 04 0a 00 	jge %d4,0,80005276 <__floatsidf+0x40>
80005266:	7b 00 00 28 	movh %d2,32768
8000526a:	a0 05       	mov.a %a5,0
8000526c:	91 00 1e 4c 	movh.a %a4,49632
80005270:	5f 24 f6 7f 	jeq %d4,%d2,8000525c <__floatsidf+0x26>
80005274:	32 54       	rsub %d4
80005276:	0f 04 b0 61 	clz %d6,%d4
8000527a:	1b d6 01 60 	addi %d6,%d6,29
8000527e:	8f f6 01 21 	and %d2,%d6,31
80005282:	82 05       	mov %d5,0
80005284:	8b 06 82 72 	ge %d7,%d6,32
80005288:	17 45 80 32 	dextr %d3,%d5,%d4,%d2
8000528c:	0f 24 00 20 	sh %d2,%d4,%d2
80005290:	2b 23 50 37 	seln %d3,%d7,%d3,%d2
80005294:	8b c6 03 61 	rsub %d6,%d6,60
80005298:	ab 02 a0 27 	seln %d2,%d7,%d2,0
8000529c:	59 a3 14 00 	st.w [%sp]20,%d3
800052a0:	59 a6 0c 00 	st.w [%sp]12,%d6
800052a4:	59 a2 10 00 	st.w [%sp]16,%d2
800052a8:	1d ff d4 ff 	j 80005250 <__floatsidf+0x1a>

800052ac <__make_dp>:
800052ac:	20 18       	sub.a %sp,24
800052ae:	09 a2 d8 09 	ld.da %a2,[%sp]24
800052b2:	d9 a4 04 00 	lea %a4,[%sp]4
800052b6:	59 a4 04 00 	st.w [%sp]4,%d4
800052ba:	59 a5 08 00 	st.w [%sp]8,%d5
800052be:	59 a6 0c 00 	st.w [%sp]12,%d6
800052c2:	89 a2 d0 09 	st.da [%sp]16,%a2
800052c6:	6d 00 72 00 	call 800053aa <__pack_d>
800052ca:	00 90       	ret 

800052cc <__truncdfsf2>:
800052cc:	20 20       	sub.a %sp,32
800052ce:	d9 a5 0c 00 	lea %a5,[%sp]12
800052d2:	d9 a4 04 00 	lea %a4,[%sp]4
800052d6:	89 a4 44 09 	st.d [%sp]4,%e4
800052da:	6d 00 37 01 	call 80005548 <__unpack_d>
800052de:	19 a3 18 00 	ld.w %d3,[%sp]24
800052e2:	19 a2 1c 00 	ld.w %d2,[%sp]28
800052e6:	77 32 00 21 	dextr %d2,%d2,%d3,2
800052ea:	b7 03 02 3f 	insert %d3,%d3,0,30,2
800052ee:	02 27       	mov %d7,%d2
800052f0:	df 03 04 00 	jeq %d3,0,800052f8 <__truncdfsf2+0x2c>
800052f4:	8f 12 40 71 	or %d7,%d2,1
800052f8:	19 a6 14 00 	ld.w %d6,[%sp]20
800052fc:	19 a5 10 00 	ld.w %d5,[%sp]16
80005300:	19 a4 0c 00 	ld.w %d4,[%sp]12
80005304:	6d 00 47 00 	call 80005392 <__make_fp>
80005308:	00 90       	ret 

8000530a <__unpack_f>:
8000530a:	54 42       	ld.w %d2,[%a4]
8000530c:	8f 12 1e 50 	sh %d5,%d2,-31
80005310:	37 02 e8 3b 	extr.u %d3,%d2,23,8
80005314:	b7 02 89 4b 	insert %d4,%d2,0,23,9
80005318:	59 55 04 00 	st.w [%a5]4,%d5
8000531c:	df 03 16 80 	jne %d3,0,80005348 <__unpack_f+0x3e>
80005320:	df 04 25 00 	jeq %d4,0,8000536a <__unpack_f+0x60>
80005324:	82 33       	mov %d3,3
80005326:	8f 74 00 20 	sh %d2,%d4,7
8000532a:	7b 00 00 54 	movh %d5,16384
8000532e:	74 53       	st.w [%a5],%d3
80005330:	3b 10 f8 3f 	mov %d3,-127
80005334:	06 12       	sh %d2,1
80005336:	02 34       	mov %d4,%d3
80005338:	c2 f3       	add %d3,-1
8000533a:	3f 52 fd ff 	jlt.u %d2,%d5,80005334 <__unpack_f+0x2a>
8000533e:	59 54 08 00 	st.w [%a5]8,%d4
80005342:	59 52 0c 00 	st.w [%a5]12,%d2
80005346:	00 90       	ret 
80005348:	8b f3 2f 52 	ne %d5,%d3,255
8000534c:	df 05 12 00 	jeq %d5,0,80005370 <__unpack_f+0x66>
80005350:	82 32       	mov %d2,3
80005352:	1b 13 f8 3f 	addi %d3,%d3,-127
80005356:	74 52       	st.w [%a5],%d2
80005358:	8f 74 00 20 	sh %d2,%d4,7
8000535c:	b7 f2 01 2f 	insert %d2,%d2,15,30,1
80005360:	59 53 08 00 	st.w [%a5]8,%d3
80005364:	59 52 0c 00 	st.w [%a5]12,%d2
80005368:	00 90       	ret 
8000536a:	82 22       	mov %d2,2
8000536c:	74 52       	st.w [%a5],%d2
8000536e:	00 90       	ret 
80005370:	df 04 05 80 	jne %d4,0,8000537a <__unpack_f+0x70>
80005374:	82 42       	mov %d2,4
80005376:	74 52       	st.w [%a5],%d2
80005378:	00 90       	ret 
8000537a:	37 02 61 3b 	extr.u %d3,%d2,22,1
8000537e:	06 72       	sh %d2,7
80005380:	74 53       	st.w [%a5],%d3
80005382:	7b 00 00 32 	movh %d3,8192
80005386:	1b 03 f8 3f 	addi %d3,%d3,-128
8000538a:	26 32       	and %d2,%d3
8000538c:	59 52 0c 00 	st.w [%a5]12,%d2
80005390:	00 90       	ret 

80005392 <__make_fp>:
80005392:	20 10       	sub.a %sp,16
80005394:	40 a4       	mov.aa %a4,%sp
80005396:	74 a4       	st.w [%sp],%d4
80005398:	59 a5 04 00 	st.w [%sp]4,%d5
8000539c:	59 a6 08 00 	st.w [%sp]8,%d6
800053a0:	59 a7 0c 00 	st.w [%sp]12,%d7
800053a4:	6d 00 31 01 	call 80005606 <__pack_f>
800053a8:	00 90       	ret 

800053aa <__pack_d>:
800053aa:	54 44       	ld.w %d4,[%a4]
800053ac:	19 43 0c 00 	ld.w %d3,[%a4]12
800053b0:	19 42 10 00 	ld.w %d2,[%a4]16
800053b4:	19 41 04 00 	ld.w %d1,[%a4]4
800053b8:	bf 24 56 80 	jlt.u %d4,2,80005464 <__pack_d+0xba>
800053bc:	7b 00 ff 57 	movh %d5,32752
800053c0:	d2 06       	mov %e6,0
800053c2:	df 44 0b 00 	jeq %d4,4,800053d8 <__pack_d+0x2e>
800053c6:	0f 23 a0 50 	or %d5,%d3,%d2
800053ca:	8b 05 00 02 	eq %d0,%d5,0
800053ce:	8b 24 e0 04 	or.eq %d0,%d4,2
800053d2:	82 05       	mov %d5,0
800053d4:	df 00 0c 00 	jeq %d0,0,800053ec <__pack_d+0x42>
800053d8:	0b 10 00 28 	mov %e2,%d1
800053dc:	a6 75       	or %d5,%d7
800053de:	8f f2 01 20 	sh %d2,%d2,31
800053e2:	0f 25 a0 40 	or %d4,%d5,%d2
800053e6:	02 43       	mov %d3,%d4
800053e8:	02 62       	mov %d2,%d6
800053ea:	00 90       	ret 
800053ec:	19 44 08 00 	ld.w %d4,[%a4]8
800053f0:	3b 20 c0 0f 	mov %d0,-1022
800053f4:	3f 04 41 00 	jlt %d4,%d0,80005476 <__pack_d+0xcc>
800053f8:	3b 00 40 00 	mov %d0,1024
800053fc:	7b 00 ff 57 	movh %d5,32752
80005400:	7f 04 ec 7f 	jge %d4,%d0,800053d8 <__pack_d+0x2e>
80005404:	8f f3 0f 51 	and %d5,%d3,255
80005408:	8b 05 28 52 	ne %d5,%d5,128
8000540c:	df 05 1b 00 	jeq %d5,0,80005442 <__pack_d+0x98>
80005410:	8b f3 87 30 	addx %d3,%d3,127
80005414:	8b 02 a0 20 	addc %d2,%d2,0
80005418:	7b 00 00 52 	movh %d5,8192
8000541c:	0b 25 30 61 	lt.u %d6,%d5,%d2
80005420:	0b 25 70 62 	or.eq %d6,%d5,%d2
80005424:	df 06 19 80 	jne %d6,0,80005456 <__pack_d+0xac>
80005428:	1b f4 3f 40 	addi %d4,%d4,1023
8000542c:	0b 40 00 48 	mov %e4,%d4
80005430:	77 32 00 6c 	dextr %d6,%d2,%d3,24
80005434:	06 82       	sh %d2,-8
80005436:	b7 02 0c 7a 	insert %d7,%d2,0,20,12
8000543a:	8f 44 01 50 	sh %d5,%d4,20
8000543e:	1d ff cd ff 	j 800053d8 <__pack_d+0x2e>
80005442:	8f 03 10 51 	and %d5,%d3,256
80005446:	df 05 e9 7f 	jeq %d5,0,80005418 <__pack_d+0x6e>
8000544a:	8b 03 88 30 	addx %d3,%d3,128
8000544e:	8b 02 a0 20 	addc %d2,%d2,0
80005452:	1d ff e3 ff 	j 80005418 <__pack_d+0x6e>
80005456:	77 32 80 3f 	dextr %d3,%d2,%d3,31
8000545a:	1b 04 40 40 	addi %d4,%d4,1024
8000545e:	06 f2       	sh %d2,-1
80005460:	1d ff e6 ff 	j 8000542c <__pack_d+0x82>
80005464:	77 32 00 6c 	dextr %d6,%d2,%d3,24
80005468:	06 82       	sh %d2,-8
8000546a:	b7 12 8d 79 	insert %d7,%d2,1,19,13
8000546e:	7b 00 ff 57 	movh %d5,32752
80005472:	1d ff b3 ff 	j 800053d8 <__pack_d+0x2e>
80005476:	0b 40 80 40 	sub %d4,%d0,%d4
8000547a:	8b 94 83 02 	ge %d0,%d4,57
8000547e:	df 00 ad ff 	jne %d0,0,800053d8 <__pack_d+0x2e>
80005482:	8b 04 82 52 	ge %d5,%d4,32
80005486:	2b 23 50 05 	seln %d0,%d5,%d3,%d2
8000548a:	ab 02 a0 75 	seln %d7,%d5,%d2,0
8000548e:	8f f4 01 51 	and %d5,%d4,31
80005492:	8b 05 02 61 	rsub %d6,%d5,32
80005496:	17 07 80 66 	dextr %d6,%d7,%d0,%d6
8000549a:	2b 06 40 65 	sel %d6,%d5,%d6,%d0
8000549e:	8b 04 82 82 	ge %d8,%d4,32
800054a2:	32 55       	rsub %d5
800054a4:	02 60       	mov %d0,%d6
800054a6:	8f f4 01 41 	and %d4,%d4,31
800054aa:	82 f6       	mov %d6,-1
800054ac:	0f 57 00 70 	sh %d7,%d7,%d5
800054b0:	17 66 80 54 	dextr %d5,%d6,%d6,%d4
800054b4:	0f 46 00 40 	sh %d4,%d6,%d4
800054b8:	2b 45 50 58 	seln %d5,%d8,%d5,%d4
800054bc:	ab 04 a0 48 	seln %d4,%d8,%d4,0
800054c0:	0f 43 e0 30 	andn %d3,%d3,%d4
800054c4:	0f 52 e0 20 	andn %d2,%d2,%d5
800054c8:	a6 32       	or %d2,%d3
800054ca:	02 03       	mov %d3,%d0
800054cc:	8b 02 00 35 	or.ne %d3,%d2,0
800054d0:	8f f3 0f 51 	and %d5,%d3,255
800054d4:	82 12       	mov %d2,1
800054d6:	8b 05 08 24 	and.eq %d2,%d5,128
800054da:	02 74       	mov %d4,%d7
800054dc:	df 02 14 80 	jne %d2,0,80005504 <__pack_d+0x15a>
800054e0:	8b f3 87 30 	addx %d3,%d3,127
800054e4:	8b 07 a0 20 	addc %d2,%d7,0
800054e8:	77 32 00 6c 	dextr %d6,%d2,%d3,24
800054ec:	7b 00 00 31 	movh %d3,4096
800054f0:	8f 82 1f 70 	sh %d7,%d2,-8
800054f4:	0b 32 50 21 	ge.u %d2,%d2,%d3
800054f8:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
800054fc:	8f 42 01 50 	sh %d5,%d2,20
80005500:	1d ff 6c ff 	j 800053d8 <__pack_d+0x2e>
80005504:	8b 03 88 60 	addx %d6,%d3,128
80005508:	8b 07 a0 20 	addc %d2,%d7,0
8000550c:	7b 00 00 a1 	movh %d10,4096
80005510:	8f 82 1f 70 	sh %d7,%d2,-8
80005514:	77 62 00 6c 	dextr %d6,%d2,%d6,24
80005518:	0b a2 50 21 	ge.u %d2,%d2,%d10
8000551c:	53 12 40 80 	mul.u %e8,%d2,1
80005520:	8f 03 10 01 	and %d0,%d3,256
80005524:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
80005528:	8f 48 01 50 	sh %d5,%d8,20
8000552c:	df 00 56 ff 	jne %d0,0,800053d8 <__pack_d+0x2e>
80005530:	8f 84 1f 70 	sh %d7,%d4,-8
80005534:	0b a4 50 21 	ge.u %d2,%d4,%d10
80005538:	77 34 00 6c 	dextr %d6,%d4,%d3,24
8000553c:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
80005540:	8f 42 01 50 	sh %d5,%d2,20
80005544:	1d ff 4a ff 	j 800053d8 <__pack_d+0x2e>

80005548 <__unpack_d>:
80005548:	09 48 40 09 	ld.d %e8,[%a4]
8000554c:	3b f0 7f 00 	mov %d0,2047
80005550:	8f 19 1e 70 	sh %d7,%d9,-31
80005554:	37 09 6b 5a 	extr.u %d5,%d9,20,11
80005558:	b7 09 0c 6a 	insert %d6,%d9,0,20,12
8000555c:	59 57 04 00 	st.w [%a5]4,%d7
80005560:	df 05 26 80 	jne %d5,0,800055ac <__unpack_d+0x64>
80005564:	8b 08 20 22 	ne %d2,%d8,0
80005568:	8b 06 00 25 	or.ne %d2,%d6,0
8000556c:	df 02 33 00 	jeq %d2,0,800055d2 <__unpack_d+0x8a>
80005570:	82 32       	mov %d2,3
80005572:	77 86 00 34 	dextr %d3,%d6,%d8,8
80005576:	8f 88 00 40 	sh %d4,%d8,8
8000557a:	74 52       	st.w [%a5],%d2
8000557c:	3b 10 c0 5f 	mov %d5,-1023
80005580:	7b 00 00 61 	movh %d6,4096
80005584:	77 43 80 30 	dextr %d3,%d3,%d4,1
80005588:	02 57       	mov %d7,%d5
8000558a:	0b 63 00 21 	eq %d2,%d3,%d6
8000558e:	b7 02 01 20 	insert %d2,%d2,0,0,1
80005592:	06 14       	sh %d4,1
80005594:	0b 63 a0 22 	or.lt.u %d2,%d3,%d6
80005598:	c2 f5       	add %d5,-1
8000559a:	df 02 f5 ff 	jne %d2,0,80005584 <__unpack_d+0x3c>
8000559e:	59 57 08 00 	st.w [%a5]8,%d7
800055a2:	59 54 0c 00 	st.w [%a5]12,%d4
800055a6:	59 53 10 00 	st.w [%a5]16,%d3
800055aa:	00 90       	ret 
800055ac:	5f 05 16 00 	jeq %d5,%d0,800055d8 <__unpack_d+0x90>
800055b0:	82 32       	mov %d2,3
800055b2:	1b 15 c0 5f 	addi %d5,%d5,-1023
800055b6:	8f 88 00 40 	sh %d4,%d8,8
800055ba:	74 52       	st.w [%a5],%d2
800055bc:	77 86 00 24 	dextr %d2,%d6,%d8,8
800055c0:	59 55 08 00 	st.w [%a5]8,%d5
800055c4:	b7 f2 01 2e 	insert %d2,%d2,15,28,1
800055c8:	59 54 0c 00 	st.w [%a5]12,%d4
800055cc:	59 52 10 00 	st.w [%a5]16,%d2
800055d0:	00 90       	ret 
800055d2:	82 22       	mov %d2,2
800055d4:	74 52       	st.w [%a5],%d2
800055d6:	00 90       	ret 
800055d8:	8b 08 20 52 	ne %d5,%d8,0
800055dc:	8b 06 00 55 	or.ne %d5,%d6,0
800055e0:	df 05 05 80 	jne %d5,0,800055ea <__unpack_d+0xa2>
800055e4:	82 42       	mov %d2,4
800055e6:	74 52       	st.w [%a5],%d2
800055e8:	00 90       	ret 
800055ea:	77 89 00 34 	dextr %d3,%d9,%d8,8
800055ee:	37 09 e1 49 	extr.u %d4,%d9,19,1
800055f2:	b7 03 85 3d 	insert %d3,%d3,0,27,5
800055f6:	8f 88 00 20 	sh %d2,%d8,8
800055fa:	74 54       	st.w [%a5],%d4
800055fc:	59 52 0c 00 	st.w [%a5]12,%d2
80005600:	59 53 10 00 	st.w [%a5]16,%d3
80005604:	00 90       	ret 

80005606 <__pack_f>:
80005606:	54 44       	ld.w %d4,[%a4]
80005608:	19 43 0c 00 	ld.w %d3,[%a4]12
8000560c:	19 47 04 00 	ld.w %d7,[%a4]4
80005610:	bf 24 3f 80 	jlt.u %d4,2,8000568e <__pack_f+0x88>
80005614:	7b 00 f8 57 	movh %d5,32640
80005618:	82 06       	mov %d6,0
8000561a:	df 44 09 00 	jeq %d4,4,8000562c <__pack_f+0x26>
8000561e:	8b 03 00 22 	eq %d2,%d3,0
80005622:	8b 24 e0 24 	or.eq %d2,%d4,2
80005626:	82 05       	mov %d5,0
80005628:	df 02 08 00 	jeq %d2,0,80005638 <__pack_f+0x32>
8000562c:	8f f7 01 70 	sh %d7,%d7,31
80005630:	0f 56 a0 20 	or %d2,%d6,%d5
80005634:	a6 72       	or %d2,%d7
80005636:	00 90       	ret 
80005638:	19 42 08 00 	ld.w %d2,[%a4]8
8000563c:	8b 22 98 42 	ge %d4,%d2,-126
80005640:	df 04 33 00 	jeq %d4,0,800056a6 <__pack_f+0xa0>
80005644:	8b 02 88 42 	ge %d4,%d2,128
80005648:	7b 00 f8 57 	movh %d5,32640
8000564c:	df 04 f0 ff 	jne %d4,0,8000562c <__pack_f+0x26>
80005650:	8f f3 07 51 	and %d5,%d3,127
80005654:	8f 03 08 41 	and %d4,%d3,128
80005658:	8b 05 24 52 	ne %d5,%d5,64
8000565c:	ab 03 04 44 	cadd %d4,%d4,%d3,64
80005660:	1b f3 03 30 	addi %d3,%d3,63
80005664:	2b 43 40 35 	sel %d3,%d5,%d3,%d4
80005668:	1b f2 07 50 	addi %d5,%d2,127
8000566c:	bf 03 0c 00 	jlt %d3,0,80005684 <__pack_f+0x7e>
80005670:	37 03 f7 63 	extr.u %d6,%d3,7,23
80005674:	8f 75 01 50 	sh %d5,%d5,23
80005678:	8f f7 01 70 	sh %d7,%d7,31
8000567c:	0f 56 a0 20 	or %d2,%d6,%d5
80005680:	a6 72       	or %d2,%d7
80005682:	00 90       	ret 
80005684:	06 f3       	sh %d3,-1
80005686:	1b 02 08 50 	addi %d5,%d2,128
8000568a:	1d ff f3 ff 	j 80005670 <__pack_f+0x6a>
8000568e:	37 03 f6 33 	extr.u %d3,%d3,7,22
80005692:	7b 00 f8 57 	movh %d5,32640
80005696:	b7 f3 01 6b 	insert %d6,%d3,15,22,1
8000569a:	8f f7 01 70 	sh %d7,%d7,31
8000569e:	0f 56 a0 20 	or %d2,%d6,%d5
800056a2:	a6 72       	or %d2,%d7
800056a4:	00 90       	ret 
800056a6:	8b 22 18 21 	rsub %d2,%d2,-126
800056aa:	8b a2 81 42 	ge %d4,%d2,26
800056ae:	df 04 bf ff 	jne %d4,0,8000562c <__pack_f+0x26>
800056b2:	82 f5       	mov %d5,-1
800056b4:	8b 02 00 41 	rsub %d4,%d2,0
800056b8:	0f 25 00 20 	sh %d2,%d5,%d2
800056bc:	0f 43 00 40 	sh %d4,%d3,%d4
800056c0:	0f 23 e0 30 	andn %d3,%d3,%d2
800056c4:	8b 03 00 45 	or.ne %d4,%d3,0
800056c8:	8f f4 07 31 	and %d3,%d4,127
800056cc:	8b 03 04 32 	eq %d3,%d3,64
800056d0:	df 03 0e 80 	jne %d3,0,800056ec <__pack_f+0xe6>
800056d4:	1b f4 03 20 	addi %d2,%d4,63
800056d8:	7b 00 00 34 	movh %d3,16384
800056dc:	37 02 f7 63 	extr.u %d6,%d2,7,23
800056e0:	0b 32 50 21 	ge.u %d2,%d2,%d3
800056e4:	8f 72 01 50 	sh %d5,%d2,23
800056e8:	1d ff a2 ff 	j 8000562c <__pack_f+0x26>
800056ec:	1b 04 04 30 	addi %d3,%d4,64
800056f0:	7b 00 00 24 	movh %d2,16384
800056f4:	37 03 f7 63 	extr.u %d6,%d3,7,23
800056f8:	0b 23 50 31 	ge.u %d3,%d3,%d2
800056fc:	8f 73 01 50 	sh %d5,%d3,23
80005700:	6f 74 96 ff 	jnz.t %d4,7,8000562c <__pack_f+0x26>
80005704:	0b 24 50 21 	ge.u %d2,%d4,%d2
80005708:	37 04 f7 63 	extr.u %d6,%d4,7,23
8000570c:	8f 72 01 50 	sh %d5,%d2,23
80005710:	1d ff 8e ff 	j 8000562c <__pack_f+0x26>

80005714 <__do_global_ctors_aux>:
80005714:	91 00 00 28 	movh.a %a2,32768
80005718:	d9 22 58 d5 	lea %a2,[%a2]22360 <80005758 <__CTOR_END__>>
8000571c:	19 22 fc ff 	ld.w %d2,[%a2]-4 <7ffffffc <__CSA0_END+0xffe43fc>>
80005720:	d9 23 fc ff 	lea %a3,[%a2]-4 <7ffffffc <__CSA0_END+0xffe43fc>>
80005724:	df f2 0a 00 	jeq %d2,-1,80005738 <__do_global_ctors_aux+0x24>
80005728:	40 3c       	mov.aa %a12,%a3
8000572a:	60 22       	mov.a %a2,%d2
8000572c:	b0 cc       	add.a %a12,-4
8000572e:	2d 02 00 00 	calli %a2
80005732:	54 c2       	ld.w %d2,[%a12]
80005734:	df f2 fb ff 	jne %d2,-1,8000572a <__do_global_ctors_aux+0x16>
80005738:	00 90       	ret 
	...

Disassembly of section .init:

8000573c <_init>:
8000573c:	6d ff a2 d7 	call 80000680 <frame_dummy>
80005740:	6d ff ea ff 	call 80005714 <__do_global_ctors_aux>
80005744:	00 90       	ret 
	...

Disassembly of section .fini:

80005748 <_fini>:
80005748:	6d ff 6a d7 	call 8000061c <__do_global_dtors_aux>
8000574c:	00 90       	ret 
	...

Disassembly of section .traptab_tc2:

801f6100 <IfxCpu_Trap_vectorTable2>:
#pragma ghs section text=".traptab_cpu2"
#endif

void IfxCpu_Trap_vectorTable2(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
801f6100:	0d 00 00 02 	svlcx 
801f6104:	02 f4       	mov %d4,%d15
801f6106:	91 00 00 28 	movh.a %a2,32768
801f610a:	d9 22 94 a3 	lea %a2,[%a2]14996 <80003a94 <IfxCpu_Trap_memoryManagementError>>
801f610e:	dc 02       	ji %a2
801f6110:	00 80       	rfe 
	...
801f611e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
801f6120:	0d 00 00 02 	svlcx 
801f6124:	02 f4       	mov %d4,%d15
801f6126:	91 00 00 28 	movh.a %a2,32768
801f612a:	d9 22 82 b3 	lea %a2,[%a2]15042 <80003ac2 <IfxCpu_Trap_internalProtectionError>>
801f612e:	dc 02       	ji %a2
801f6130:	00 80       	rfe 
	...
801f613e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
801f6140:	0d 00 00 02 	svlcx 
801f6144:	02 f4       	mov %d4,%d15
801f6146:	91 00 00 28 	movh.a %a2,32768
801f614a:	d9 22 b0 b3 	lea %a2,[%a2]15088 <80003af0 <IfxCpu_Trap_instructionError>>
801f614e:	dc 02       	ji %a2
801f6150:	00 80       	rfe 
	...
801f615e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
801f6160:	02 f4       	mov %d4,%d15
801f6162:	91 00 00 28 	movh.a %a2,32768
801f6166:	d9 22 9e c3 	lea %a2,[%a2]15134 <80003b1e <IfxCpu_Trap_contextManagementError>>
801f616a:	dc 02       	ji %a2
801f616c:	00 80       	rfe 
	...
801f617e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
801f6180:	0d 00 00 02 	svlcx 
801f6184:	02 f4       	mov %d4,%d15
801f6186:	91 00 00 28 	movh.a %a2,32768
801f618a:	d9 22 8c d3 	lea %a2,[%a2]15180 <80003b4c <IfxCpu_Trap_busError>>
801f618e:	dc 02       	ji %a2
801f6190:	00 80       	rfe 
	...
801f619e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
801f61a0:	0d 00 00 02 	svlcx 
801f61a4:	02 f4       	mov %d4,%d15
801f61a6:	91 00 00 28 	movh.a %a2,32768
801f61aa:	d9 22 ba d3 	lea %a2,[%a2]15226 <80003b7a <IfxCpu_Trap_assertion>>
801f61ae:	dc 02       	ji %a2
801f61b0:	00 80       	rfe 
	...
801f61be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu2);
801f61c0:	0d 00 00 02 	svlcx 
801f61c4:	02 f4       	mov %d4,%d15
801f61c6:	91 00 00 28 	movh.a %a2,32768
801f61ca:	d9 22 c6 03 	lea %a2,[%a2]15366 <80003c06 <IfxCpu_Trap_systemCall_Cpu2>>
801f61ce:	dc 02       	ji %a2
801f61d0:	00 80       	rfe 
	...
801f61de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
801f61e0:	0d 00 00 02 	svlcx 
801f61e4:	02 f4       	mov %d4,%d15
801f61e6:	91 00 00 28 	movh.a %a2,32768
801f61ea:	d9 22 f2 03 	lea %a2,[%a2]15410 <80003c32 <IfxCpu_Trap_nonMaskableInterrupt>>
801f61ee:	dc 02       	ji %a2
801f61f0:	00 80       	rfe 
}
801f61f2:	00 90       	ret 

801f61f4 <IfxCpu_Trap_vectorTable2_end>:
	...

Disassembly of section .traptab_tc1:

801f6200 <IfxCpu_Trap_vectorTable1>:
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
801f6200:	0d 00 00 02 	svlcx 
801f6204:	02 f4       	mov %d4,%d15
801f6206:	91 00 00 28 	movh.a %a2,32768
801f620a:	d9 22 94 a3 	lea %a2,[%a2]14996 <80003a94 <IfxCpu_Trap_memoryManagementError>>
801f620e:	dc 02       	ji %a2
801f6210:	00 80       	rfe 
	...
801f621e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
801f6220:	0d 00 00 02 	svlcx 
801f6224:	02 f4       	mov %d4,%d15
801f6226:	91 00 00 28 	movh.a %a2,32768
801f622a:	d9 22 82 b3 	lea %a2,[%a2]15042 <80003ac2 <IfxCpu_Trap_internalProtectionError>>
801f622e:	dc 02       	ji %a2
801f6230:	00 80       	rfe 
	...
801f623e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
801f6240:	0d 00 00 02 	svlcx 
801f6244:	02 f4       	mov %d4,%d15
801f6246:	91 00 00 28 	movh.a %a2,32768
801f624a:	d9 22 b0 b3 	lea %a2,[%a2]15088 <80003af0 <IfxCpu_Trap_instructionError>>
801f624e:	dc 02       	ji %a2
801f6250:	00 80       	rfe 
	...
801f625e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
801f6260:	02 f4       	mov %d4,%d15
801f6262:	91 00 00 28 	movh.a %a2,32768
801f6266:	d9 22 9e c3 	lea %a2,[%a2]15134 <80003b1e <IfxCpu_Trap_contextManagementError>>
801f626a:	dc 02       	ji %a2
801f626c:	00 80       	rfe 
	...
801f627e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
801f6280:	0d 00 00 02 	svlcx 
801f6284:	02 f4       	mov %d4,%d15
801f6286:	91 00 00 28 	movh.a %a2,32768
801f628a:	d9 22 8c d3 	lea %a2,[%a2]15180 <80003b4c <IfxCpu_Trap_busError>>
801f628e:	dc 02       	ji %a2
801f6290:	00 80       	rfe 
	...
801f629e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
801f62a0:	0d 00 00 02 	svlcx 
801f62a4:	02 f4       	mov %d4,%d15
801f62a6:	91 00 00 28 	movh.a %a2,32768
801f62aa:	d9 22 ba d3 	lea %a2,[%a2]15226 <80003b7a <IfxCpu_Trap_assertion>>
801f62ae:	dc 02       	ji %a2
801f62b0:	00 80       	rfe 
	...
801f62be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu1);
801f62c0:	0d 00 00 02 	svlcx 
801f62c4:	02 f4       	mov %d4,%d15
801f62c6:	91 00 00 28 	movh.a %a2,32768
801f62ca:	d9 22 9a f3 	lea %a2,[%a2]15322 <80003bda <IfxCpu_Trap_systemCall_Cpu1>>
801f62ce:	dc 02       	ji %a2
801f62d0:	00 80       	rfe 
	...
801f62de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
801f62e0:	0d 00 00 02 	svlcx 
801f62e4:	02 f4       	mov %d4,%d15
801f62e6:	91 00 00 28 	movh.a %a2,32768
801f62ea:	d9 22 f2 03 	lea %a2,[%a2]15410 <80003c32 <IfxCpu_Trap_nonMaskableInterrupt>>
801f62ee:	dc 02       	ji %a2
801f62f0:	00 80       	rfe 
}
801f62f2:	00 90       	ret 

801f62f4 <IfxCpu_Trap_vectorTable1_end>:
	...

Disassembly of section .inttab_tc0_064:

801f4c80 <__intvec_tc0_100>:
801f4c80:	0d 00 00 02 	svlcx 
801f4c84:	91 00 00 e8 	movh.a %a14,32768
801f4c88:	d9 ee 6c d0 	lea %a14,[%a14]1900 <8000076c <ISR_STM>>
801f4c8c:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_0C8:

801f5900 <__intvec_tc0_200>:
801f5900:	0d 00 00 02 	svlcx 
801f5904:	91 00 00 e8 	movh.a %a14,32768
801f5908:	d9 ee 84 00 	lea %a14,[%a14]2052 <80000804 <ISR_PWM_GTM>>
801f590c:	dc 0e       	ji %a14
